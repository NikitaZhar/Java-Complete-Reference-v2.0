2025-10-10 12:06
Tags: #Types #Values #PrimitiveTypes 



# 4.1.1. Понятие типа (`Type`)
_Тип_ в Java — это формальная характеристика данных, определяющая:

1. **множество допустимых значений**, которые может принимать сущность данного типа;
2. **набор операций**, которые допустимы для этих значений;
3. **правила совместимости** с другими типами;
4. **контракт поведения** на уровне времени компиляции и времени выполнения.

Тип не существует сам по себе — он является математической моделью, реализуемой средствами языка и исполняющей системой (JVM).

## Двойная роль типа в Java
- `Compile-time type` **(статический тип)** — используется компилятором для проверки корректности кода, определения допустимых операций и выбора перегруженных методов.
- `Runtime type` **(исполняемый тип)** — фактический тип объекта в памяти JVM во время выполнения программы.

> _Все выражения, переменные, параметры и поля в Java имеют тип. Java — строго типизированный язык: невозможно выполнить операцию, не определённую типом._

# 4.1.2. Понятие значения (`Value`)
_Значение_ — конкретная сущность, полученная в результате вычисления выражения, либо заданная напрямую с использованием литерала.

Каждое значение принадлежит **ровно одному типу**. Значение может существовать:
- непосредственно (для примитивных типов)
- или опосредованно, через ссылку (для ссылочных типов)

## Классификация значений

| Категория            | Примеры              | Хранение                      | Возможность быть `null`          |
| -------------------- | -------------------- | ----------------------------- | -------------------------------- |
| Примитивные значения | `42`, `3.14`, `true` | в стеке или в объекте         | Нет                              |
| Ссылочные значения   | ссылка на объект     | ссылка в стеке, объект в куче | Да (реализовано через `null`)    |
| `null`               | `null`               | специальное значение          | означает «никакого объекта»      |
| Литералы класса      | `String.class`       | объект типа `Class`           | не допускает `null` при создании |

# 4.1.3. Высокоуровневая классификация типов
Java различает **два базовых рода типов**:

## 1. Примитивные типы (`Primitive Types`)
- Определяют непосредственные значения.
- Не являются объектами.
- Имеют фиксированный размер и представление.
- Не допускают значение `null`.

## 2. Ссылочные типы (`Reference Types`)
- Представляют ссылки на объекты.
- Объекты размещаются в куче.
- Допускают `null` как специальное значение.

К ним относятся:

- Классы
- Интерфейсы
- Массивы
- Типовые переменные (`type variables`) `generics`

> Все пользовательские и встроенные сложные структуры данных являются **ссылочными типами**.

### Пример корректной работы с примитивом и ссылкой
```java
int a = 5;
int b = a;
b = 10;
System.out.println(a); // 5 (значение копируется)

String s1 = "Java";
String s2 = s1;
s2 = s2.toUpperCase();
System.out.println(s1); // "Java" (ссылки переназначаются, объект неизменяем)
```
_Пояснение:_ Примитив копируется по значению, ссылки — по адресу.

## 4.1.4. Тип vs Значение: фундаментальное различие
- Тип — _абстракция_ уровня языка (математическое множество).
- Значение — _конкретная сущность_ уровня выполнения.
- Тип существует и при отсутствии значения (например, `int` как абстракция).
- Значение не может существовать вне типа (например, `42` имеет тип `int`).

```java
int x;        // тип: int; значение пока отсутствует (неинициализированная переменная)
x = 42;       // теперь переменная x содержит значение 42, принадлежащее типу int
String s = null; // переменная s имеет ссылочный тип String, значение: null (нет объекта)
```

### Пример `incompatible types`
```java
int x = null; // Ошибка компиляции: примитивный тип не допускает null
String s = 123; // Ошибка: нельзя присваивать значение примитивного типа ссылочному типу
```

### Смешение типа и значения
```java
Object o = "text";
int x = o; // Ошибка компиляции: несоответствие типов
```

> _Тип определяет, какие операции допустимы. Значение `"text"` существует, но его тип String не совместим с int._

# 4.1.5. Статический и исполняемый тип

|Характеристика|Статический тип|Исполняемый тип|
|---|---|---|
|Определяется|на этапе компиляции|во время выполнения|
|Контролируется|компилятором|JVM|
|Может ли отличаться|Нет для примитивовДа для ссылок (полиморфизм)|Да|

### Пример полиморфизма:
```java
Number n = Integer.valueOf(10);
System.out.println(n.getClass()); // Integer, хотя статический тип: Number
```

Статический тип ограничивает, какие **операции разрешены**.
Исполняемый тип определяет, какое **поведение будет выполнено**.

### Статический vs runtime тип
Пример: значение соблюдает контракт типа
```java
Number num = Double.valueOf(3.14);
System.out.println(num instanceof Double); // true
System.out.println(num instanceof Integer); // false
```

Ошибка из-за неверного предсказания `runtime`-типа
```java
Number num = Double.valueOf(3.14);
Integer x = (Integer) num; // ClassCastException at runtime
```

> _Статический тип `Number` допускает оба подтипа, но фактический объект — `Double`._

# 4.1.6. Подтипы и надтипы (`Subtypes and Supertypes`)

Тип `B` **является подтипом** типа `A`, если значение типа `B` может быть использовано в любом контексте, где ожидается значение типа `A`, без нарушения типобезопасности.

Это отношение записывается:  
**B <: A** (B — подтип A)
**A :> B** (A — надтип B)

Основные формы подтипирования:
1. **Наследование классов (extends)**  
    `class Integer extends Number` → `Integer` <: `Number`
2. **Реализация интерфейсов (implements)**  
    `class ArrayList implements List` → `ArrayList` <: `List`
3. **Массивы: ковариантность**  
    `String[]` <: `Object[]` (_допускается, но потенциально опасно во время выполнения_)
4. **Параметризованные типы**  
    В Java обобщённые типы **инвариантны**:  
    `List<String>` **не является** подтипом `List<Object>`

### Пример корректного подтипирования:
```java
Number n = Integer.valueOf(5); // Integer <: Number
```

### Ошибочный пример (некорректное подтипирование `generics`):
```java
List<Object> list = new ArrayList<String>(); // Ошибка компиляции
```

### Особый случай: `null`
Значение `null` является **подтипом всех ссылочных типов**, но не является типом само по себе.

```java
String s = null;
Object o = null; // допустимо
int x = null;    // ошибка (примитивы не допускают null)
```

### Подтипы: корректное и некорректное использование
```java
List<? extends Number> list = new ArrayList<Integer>(); // корректно: ковариантность wildcard
list.add(5); // ошибка компиляции: нельзя добавлять элементы
```

> _Хотя Integer <: Number, wildcard `? extends` делает список только для чтения._

# 4.1.7. Модель памяти JVM и представление типов

Java использует _двухуровневую модель памяти_:

| Область        | Назначение                       | Что хранится                                    |
| -------------- | -------------------------------- | ----------------------------------------------- |
| Стек (`Stack`) | Временные данные вызовов методов | переменные примитивного типа, ссылки на объекты |
| Куча (`Heap`)  | Долговременное хранение          | объекты, массивы, строки                        |

**Примитивы** → хранятся в стеке или внутри объекта (как часть его состояния).  
**Ссылки** (`reference values`) → хранятся в стеке; сами объекты хранятся в куче.

Пример:
```java
String s = "Hello";
int x = 10;
```

- `x` хранится непосредственно (например, в стеке).
- `s` хранит ссылку (в стеке), объект `"Hello"` — в куче.

### Одинаковые значения ≠ одинаковые объекты
```java
String a = new String("abc");
String b = new String("abc");
System.out.println(a == b); // false (разные объекты)
System.out.println(a.equals(b)); // true (одинаковое значение)
```

# 4.1.8. Типичные ошибки разработчиков, связанные с неверным пониманием видов типов и значений

|Ошибка|Причина|Пример|Последствие|
|---|---|---|---|
|Использование `==` для ссылок|Путают сравнение ссылок со сравнением значений|`"abc" == new String("abc")`|Логические ошибки|
|Неверное использование `null`|Не учитывают возможность отсутствия объекта|`obj.toString()` если `obj = null`|`NullPointerException`|
|Перепутали статический тип и runtime-тип|Не учитывают полиморфизм|`Number x = 1.5; ((Integer)x)`|`ClassCastException`|
|Ошибка при работе с массивами|Ковариантность массивов|`Object[] arr = new String[1]; arr[0] = 10;`|`ArrayStoreException`|
|Неправильное предположение о типах generics|Стирание типов|`List<String> list = new ArrayList<>(); list.add((Object)10);`|Ошибка runtime|

## Ошибка с ковариантностью массивов
### Что такое ковариантность массивов?

**Ковариантность массивов** — это свойство языка Java, при котором если тип `B` является подтипом типа `A`, то массив `B[]` также считается подтипом массива `A[]`.

Например:
```java
String[] strings = new String[5];
Object[] objects = strings; // это разрешено компилятором
```

Поскольку `String` является подтипом `Object`, Java позволяет присваивать `String[]` переменной типа `Object[]`.

### Почему в примере возникает ошибка?

Рассмотрим код:
```java
Object[] arr = new String[1];
arr[0] = 10; // ArrayStoreException at runtime
```

Что происходит:

1. Создаётся массив `String[1]` — массив, который может хранить только строки.
2. Ссылка на этот массив присваивается переменной типа `Object[]`.
3. Компилятор видит переменную `arr` как `Object[]` и разрешает присваивание любого объекта (включая `Integer` со значением 10).
4. Однако **во время выполнения** JVM знает, что `arr` на самом деле указывает на `String[]`.
5. При попытке записать `Integer` в массив строк JVM выбрасывает `ArrayStoreException`.

### Подробное пояснение комментария

> _«Компилятор допускает присваивание, но JVM выбрасывает исключение, так как фактический тип массива — String[].»_

Компилятор допускает присваивание:

- На этапе компиляции проверяется только **объявленный тип** переменной `arr`, который является `Object[]`.
- Компилятор не отслеживает, что реальный объект в памяти — это `String[]`.
- Поскольку `Integer` — это подтип `Object`, компилятор считает присваивание `arr[0] = 10` корректным.

JVM выбрасывает исключение:

- Во время выполнения JVM хранит информацию о **реальном типе массива**.
- Когда происходит попытка записи, JVM проверяет совместимость типов.
- Обнаруживается несоответствие: попытка записать `Integer` в массив `String[]`.
- JVM выбрасывает `ArrayStoreException` для предотвращения нарушения типобезопасности.

### Почему это проблема?

Ковариантность массивов нарушает принцип **типобезопасности на этапе компиляции**. Ошибки обнаруживаются только во время выполнения, что делает код менее надёжным.

**Сравнение с дженериками:**

В отличие от массивов, дженерики в Java являются **инвариантными**:

```java
List<String> strings = new ArrayList<>();
List<Object> objects = strings; // ошибка компиляции!

```

Это предотвращает подобные проблемы на этапе компиляции.

### Вывод

Ковариантность массивов — это историческая особенность Java, которая позволяет присваивать массивы подтипов переменным с типом массива супертипа. Однако это создаёт риск ошибок времени выполнения, когда JVM обнаруживает несоответствие типов при попытке записи в массив.

# 4.1.9. Null Type (тип `null`)
## Определение и статус типа

_Тип `null`_ (Null Type) – это **особый, уникальный тип в Java**, который:
- не имеет имени и не может быть использован явно в объявлениях переменных;
- имеет ровно одно значение — литерал `null`;
- является подтипом всех ссылочных типов, но не является подтипом ни одного примитивного типа;
- существует только на уровне языка и JVM-проверок, но не представлен как класс и не имеет объекта `Class`.

> Значение `null` означает «отсутствие объекта» или «пустая ссылка».

## Свойства Null Type

| Характеристика              | Значение                                                                             |
| --------------------------- | ------------------------------------------------------------------------------------ |
| Допустимые значения         | Только `null`                                                                        |
| Статус в иерархии типов     | **Подтип всех ссылочных типов**, включая `Object`, интерфейсы, массивы, enum, записи |
| Runtime-представление       | Отсутствие адреса объекта                                                            |
| Совместимость с generics    | `null` можно присвоить переменной любого ссылочного generic-типа                     |
| Возможность вызывать методы | **Нет** — любая попытка вызывает `NullPointerException`                              |

### Примеры корректного использования
```java
String s = null;           // допустимо
Object o = null;           // допустимо
List<String> list = null;  // допустимо
Runnable r = null;         // допустимо
```

### Ошибка при использовании null с примитивами
```java
int x = null; // Ошибка: incompatible types
```

> Примитивные типы **никогда не могут содержать null**.

### `NullPointerException`: Runtime последствия
```java
String s = null;
int len = s.length(); // Получаем NullPointerException
```

### `Null` и `pattern matching`
```java
Object obj = null;

if (obj instanceof String s) { // false, блок не будет выполнен
    System.out.println(s.toUpperCase());
}
```

> `instanceof` всегда возвращает `false`, если значение `null`.

### `Null` как элемент generics
```java
List<String> list = new ArrayList<>();
list.add(null); // допустимо — null подходит к любому ссылочному типу
```

### Связь с `Optional`

Java предоставляет `Optional<T>` как **типобезопасную альтернативу** `null`:
```java
Optional<String> opt = Optional.ofNullable(null); // корректно, без исключений
```

### Выводы по Null Type
- `Null Type` **неявен** — вы никогда не пишете его вручную, но компилятор и JVM используют его.
- `null` — **всегда допустимое значение** для любой ссылочной переменной, но **опасно в использовании**, так как не поддерживает операции.
- Основная роль: **универсальный placeholder отсутствия значения**.
- Рекомендуется **избегать** `null` в проектировании API и **использовать** `Optional` или `Null Object Pattern`, когда это возможно.

# 4.1.11. Тип `void` и псевдотип `Void`
- Используется **только** в сигнатурах методов для указания, что метод **не возвращает значение**.
- Не имеет значений.
- Не может быть использован как тип переменной или поля.

```java
void print() { } // допустимо
void x; // ошибка: нельзя объявлять переменные типа void
```

## Псевдотип `java.lang.Void`
- Класс-обёртка, предназначенный для случаев, где необходимо использовать `void` как объект (например, в `generics`).
- Единственное допустимое значение поля `Void.TYPE` представляет тип `void` как объект метаданных.

## `void` и `Void`
```java
Void v = null; // допустимо, т.к. Void — ссылочный тип
v.toString();  // NullPointerException при вызове
```

> _Тип `void` не может иметь значение, но тип `Void` существует как объектный тип._

# 4.1.12. Обёртки примитивных типов (`Wrapper Types`)
Java предоставляет классы-обёртки для каждого примитивного типа: `Integer`, `Double`, `Boolean`, `Character`, и т.д.

Свойства:
- Являются объектами.
- **Иммутабельны** — значение не может быть изменено после создания.
- Используются в generics, коллекциях и при автоупаковке.

## Пример автоупаковки и распаковки:
```java
int a = 10;
Integer b = a;  // автоупаковка
int c = b;      // распаковка
```

Подводный камень — кеширование:
```java
Integer x = 127;
Integer y = 127;
System.out.println(x == y); // true (используется кеш)
Integer m = 128;
Integer n = 128;
System.out.println(m == n); // false (разные объекты)
```

## `Wrapper Types`: кеширование
```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b); // true (кешируется)

Integer x = 200;
Integer y = 200;
System.out.println(x == y); // false (вне кеша)
```

# 4.1.13. Identity и Equality (тождество и равенство)
В Java существует **два принципиально разных вида сравнения значений**:
1. `Identity` **(тождество)** — проверка, являются ли два операнда **одним и тем же объектом** в памяти (для ссылочных типов) или имеют ли **одинаковое значение** (для примитивов). Используется оператор `==`.
2. `Equality` **(логическое равенство)** — проверка, эквивалентны ли **содержательные значения** объектов. Определяется методом `equals()`.

> Ошибочное смешение этих двух концепций — одна из самых распространённых причин логических ошибок в Java.

## 4.1.13.1. Сравнение примитивов
Для примитивных типов оператор `==` сравнивает **конкретные значения**:
```java
int a = 5;
int b = 5;
System.out.println(a == b); // true
```

> Примитивы не являются объектами и не имеют метода `equals()`.

## 4.1.13.2. Сравнение ссылочных типов

Identity (`==`)
Сравнивает **адреса в памяти** — указывают ли обе переменные на один объект.
```java
String s1 = new String("Java");
String s2 = new String("Java");
System.out.println(s1 == s2); // false (разные объекты)
```

Equality (`equals()`)
Сравнивает **содержательные значения** (если метод `equals()` переопределён корректно):
```java
System.out.println(s1.equals(s2)); // true
```

## 4.1.13.3. Особые случаи
Пул строк (`String Pool`)
```java
String a = "Java";
String b = "Java";
System.out.println(a == b); // true (оба указывают на один объект в пуле)
```

> `==` может случайно вернуть `true`, но это поведение зависит от интернирования.

- **Когда создаётся первая строка** (`String a = "Java"`), JVM проверяет пул строк. Если там нет строки `"Java"`, она создаётся и добавляется в пул.
- **Когда создаётся вторая строка** (`String b = "Java"`), JVM снова проверяет пул и находит там уже существующую строку `"Java"`. Вместо создания нового объекта, переменная `b` получает ссылку на тот же объект, что и `a`.
- **Результат сравнения** `a == b` возвращает `true`, потому что обе переменные указывают на один и тот же объект в памяти.

### Почему это важно
Оператор `==` сравнивает **ссылки** на объекты, а не их содержимое. В случае со строками из пула, он может случайно вернуть `true`, даже если ваше намерение было сравнить содержимое.

### Проблема интернирования
Это поведение зависит от **интернирования строк** (string interning) — процесса, при котором JVM переиспользует объекты строк. Однако не все строки автоматически интернируются:
```java
String c = new String("Java");
String d = new String("Java");
System.out.println(c == d); // false (создаются разные объекты в куче)
```

Когда строка создаётся через `new String()`, она создаётся в обычной области памяти (куче), а не в пуле строк. Поэтому `c == d` вернёт `false`.

### Вывод
Для сравнения содержимого строк всегда используйте метод `.equals()`, а не оператор `==`. Это гарантирует корректное сравнение независимо от того, где находится объект в памяти.
```java
String a = "Java";
String b = "Java";
String c = new String("Java");

System.out.println(a.equals(b)); // true
System.out.println(a.equals(c)); // true
System.out.println(a == c);      // false
```

### Обёртки примитивов и кеширование
```java
Integer x = 127;
Integer y = 127;
System.out.println(x == y); // true (в кеше)

Integer m = 200;
Integer n = 200;
System.out.println(m == n); // false (вне кеша)
```

### Правильное сравнение
```java
System.out.println(m.equals(n)); // true
```

## 4.1.13.4. Контракт `equals()` и `hashCode()`
Согласно спецификации (**Java Language Specification, JLS**), метод `equals()` должен быть:

|Свойство|Описание|
|---|---|
|Рефлексивным|`x.equals(x)` → `true`|
|Симметричным|`x.equals(y)` == `y.equals(x)`|
|Транзитивным|если `x==y` и `y==z`, то `x==z`|
|Консистентным|повторные вызовы дают один результат|
|Обработка `null`|`x.equals(null)` → `false`|

`hashCode`: если `a.equals(b) == true`, то `a.hashCode() == b.hashCode()` **обязан** быть одинаковым.

Ошибка: `equals` переопределён, но `hashCode` нет

```java
class Point {
    int x, y;
    public boolean equals(Object o) {
        if (!(o instanceof Point)) return false;
        Point p = (Point) o;
        return x == p.x && y == p.y;
    }
}
```

При использовании в `HashMap` или `HashSet` — потеря корректности структуры.

См подробнее
[[41.4 Overloading vs overriding]]

## 4.1.13.5. Практическое сравнение

|Тип значения|Рекомендуемый способ сравнения|
|---|---|
|Примитивы|`==`|
|String|`.equals()`|
|Обёртки|`.equals()`|
|Enum|`==` (гарантирован singleton)|
|Пользовательские классы|переопределить `equals`/`hashCode`|

Вывод
- `==` для примитивов → сравнивает значения
- `==` для объектов → сравнивает ссылки
- `.equals()` → сравнивает логическое содержимое
- Ошибки с кешированием, строковым пулом и обёртками — критичны в промышленном коде
- Соблюдение контракта `equals/hashCode` — основа корректной работы коллекций, кэширования и ORM


### Continue

# 4.1.14. Reifiable и Non-Reifiable Types
`Reifiable`-тип — тип, чья полная форма **известна во время выполнения** (JVM может её проверить). `Non-reifiable`-тип — теряет часть информации из-за стирания `generics` и **не может** быть полностью проверен в `runtime`.

Зачем это важно?
От `reifiable`- статуса зависят допустимость `instanceof` и создание массивов указанного типа без ошибок компиляции/`unchecked`-предупреждений.

Правило большого пальца.
- `Reifiable`: примитивы, непараметризованные ссылочные типы, raw-типы, `List<?>`/`Map<?,?>`, а также массивы, **чей компонентный тип** `reifiable`.
- Не `reifiable`: `List<String>`, `Map<Integer,String>`, `List<? extends Number>`, `List<? super T>`, типовые переменные `T` и любые массивы с такими компонентами.

Пример
```java
Object x = ...;

// ✅ Разрешено (reifiable)
if (x instanceof List<?>) { /* ... */ }
List<?>[] ok = new List<?>[10];

// ❌ Запрещено (non-reifiable)
if (x instanceof List<String>) { }              // ошибка компиляции
if (x instanceof List<? extends Number>) { }    // ошибка компиляции
List<String>[] bad = new List<String>[10];      // generic array creation — ошибка
```

> Полная классификация с таблицами и подводными камнями приведена в 4.1.41 (`Reifiable Types`: уточнение и строгая классификация). Для взаимодействия с массивами см. 4.1.27 (`Array Types`); для `varargs` и загрязнения кучи — 4.1.42 (`Heap Pollution` и `@SafeVarargs`).

# 4.1.15. Типы на уровне JVM
В Java виртуальная машина оперирует с типами на уровне байткода:

|Язык Java|JVM|Описание|
|---|---|---|
|`int`|I|32-битное целое|
|`float`|F|32-битное число с плавающей точкой|
|`reference`|L|ссылка на объект|
|`long`|J|64-битное целое|
|`double`|D|64-битное число с плавающей точкой|

JVM **не различает generics**, стирание типов приводит к тому, что `List<String>` и `List<Integer>` представлены одним и тем же типом в байткоде.

# 4.1.16. Class Literals и объекты метаданных
Каждый тип в Java соответствует экземпляру класса `java.lang.Class`.

```java
Class<String> c1 = String.class;
Class<Integer> c2 = int.class;
```

Особенности:
- Для каждого типа создаётся **ровно один объект Class**, загружаемый ClassLoader’ом.
- Через объект Class можно получить рефлективную информацию о типе.

# 4.1.17 `Enum Types` (Перечислимые типы)

_Перечислимый тип (`enum type`)_ — это ссылочный тип, определяемый с помощью ключевого слова `enum`. `Enum` представляет конечное, фиксированное множество именованных констант. Каждая константа enum является экземпляром самого перечисления. `Enum` автоматически наследует класс `java.lang.Enum` и не может наследовать другие классы, но может реализовывать интерфейсы.

## Свойства перечислимых типов
- Каждый элемент `enum` — это **единственный экземпляр** (`singleton`), созданный при инициализации класса.
- `Enum` являются **типобезопасной альтернативой статическим final-константам**.
- `Enum` поддерживают методы, поля, конструкторы.
- `Enum` **участвуют в системе типов** так же, как и классы, и являются полноценными ссылочными типами.

Пример
```java
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

Day d = Day.MONDAY;
System.out.println(d.name()); // "MONDAY"
System.out.println(d.ordinal()); // 0
```

Ошибка
```java
enum Color { RED, GREEN, BLUE }

Color c = 1; // Ошибка: нельзя присвоить числовое значение
```

Подводные камни
- Enum не поддерживают наследование между перечислениями.
- Каждая enum-константа — это объект, и к нему можно добавлять методы.

## `Enum Types` с логикой

```java
enum Status {
    NEW, IN_PROGRESS, DONE;
    public boolean isFinished() {
        return this == DONE;
    }
}

System.out.println(Status.NEW.isFinished()); // false
System.out.println(Status.DONE.isFinished()); // true
```

# 4.1.18 `Annotation Types` (Аннотационные типы)

_Аннотационный тип_ определяется с использованием ключевого слова `@interface` и является особым видом интерфейса. Аннотации применяются для снабжения кода метаданными и сами являются типами.

### Свойства:
- Аннотация — это **тип**, экземпляры которого создаются компилятором и доступны через рефлексию.
- Аннотации не имеют поведения, но влияют на компилятор, инструменты и runtime.
- Значения элементов аннотации должны быть `compile-time constants`.

Пример
```java
@interface Info {
    String author();
    int version() default 1;
}

@Info(author = "Alice", version = 2)
class MyClass {}
```

Ошибка
```java
@interface A { int x(); }

@A(x = 1 + Math.random()) // Ошибка: значение не является константой времени компиляции
class Test {}
```

## Annotation Types ошибка
```java
@interface A { int value(); }

@A(value = 2+2) // допустимо
@A(value = Math.max(1,2)) // ошибка: не константа времени компиляции
class Test {}
```

# 4.1.19 `Compile-Time Constant Values` (Константы времени компиляции)
  
_Константа времени компиляции_ (`compile-time constant`) — это значение примитивного типа или `String`, вычисляемое полностью на этапе компиляции. Такие значения могут встраиваться (`inlined`) в байткод.

Пример
```java
static final int SIZE = 10;
static final String NAME = "Java";
```

Особенности
- Константы могут использоваться в `switch-case`, аннотациях и массивах фиксированного размера.
- Ошибки возникают, если изменить значение и не перекомпилировать все зависимости.

## Compile-Time Constants
```java
static final int A = 10;
static final int B = A + 5; // compile-time constant
static final int C = new Integer(10); // не constant value
```

# 4.1.20 L-Values и R-Values
- **L-value** («left value») — выражение, представляющее _хранимую область памяти_, куда можно записывать значение.
- **R-value** — значение, получаемое в результате вычисления, которое можно использовать, но не изменять как хранение.

Пример
```java
int x = 5; // x — L-value; 5 — R-value
(x + 1) = 10; // Ошибка: (x + 1) не является местом хранения
```

## L-values / R-values
```java
int x = 5;   // x — l-value
(x + 1) = 10; // ошибка: выражение не является l-value
```

## 4.1.21 `Class Identity` и `ClassLoader`
Тип в Java идентифицируется не только именем, но и загрузчиком класса.

```java
ClassLoader loader1 = ...;
ClassLoader loader2 = ...;

Class<?> c1 = loader1.loadClass("com.Example");
Class<?> c2 = loader2.loadClass("com.Example");

System.out.println(c1 == c2); // false — несмотря на одинаковое имя
```

> Это фундамент JVM: один и тот же класс, загруженный разными загрузчиками, считается **разными типами**.

## ClassLoader Пример
```java
Class<?> c1 = Class.forName("com.MyClass");
Class<?> c2 = new CustomLoader().loadClass("com.MyClass");

System.out.println(c1 == c2); // false
```

# 4.1.22 Value Categories по спецификации
Java определяет значения следующих категорий:
- `numeric values` (целочисленные и с плавающей точкой)
- `boolean values`
- `character values`
- `reference values`
- `the null reference`
- `class literals`
- `enum constants`
- `annotation instances`

## Value Categories
```java
42, 3.14, 'a', true         // primitive values
"java"                      // reference value
null                        // null reference
Day.MONDAY                  // enum constant
String.class                // class literal
```

# 4.1.23 Изменяемость (`Mutability`) и неизменяемость (`Immutability`)
`Mutability` определяет, может ли значение изменяться после создания.

|Тип|Пример|Изменяемость|
|---|---|---|
|Примитивы|`int`, `double`|неизменяемые|
|String|`"abc"`|неизменяемый|
|Массивы|`int[]`|изменяемые|
|Пользовательские классы|`Point(x,y)`|по умолчанию изменяемы|

## Mutability
```java
final class ImmutablePoint {
    final int x, y;
    ImmutablePoint(int x, int y) { this.x = x; this.y = y; }
}
```

# 4.1.24 Compile-Time vs Runtime Representation

|Уровень|Обозначение|Использование|
|---|---|---|
|**Compile-Time**|Типы generics, `List<String>`|Проверка типов|
|**Runtime**|Стирание типов, `List`|Исполнение байткода|

## Compile-Time vs Runtime
```java
List<String> list = new ArrayList<>();
System.out.println(list.getClass()); // class java.util.ArrayList
```

# 4.1.25 Итоговая таблица типов и значений

|Категория типа|Подвид|Значения|Runtime-поведение|
|---|---|---|---|
|Primitive|boolean, char, byte, short, int, long, float, double|непосредственные|всегда известны|
|Reference|class, interface, array|ссылки на объекты|динамический тип|
|Special|enum, annotation, type variable, null, void|разные|специфика JVM|

# 4.1.26. Типовые переменные (Type Variables)  
_Типовая переменная_ (`type variable`) — это именованный параметр типа, который используется при объявлении обобщённых (`generic`) классов, интерфейсов, методов или конструкторов. Типовая переменная является **формальным типом**, который получает **конкретный тип (аргумент типа)** в момент использования (`instantiation`).

Типовые переменные являются **полноценными ссылочными типами уровня** `compile-time`, но **не существуют во время выполнения** (`runtime`): их информация стирается (`type erasure`).

## Свойства типовых переменных

| Свойство                      | Описание                                               |
| ----------------------------- | ------------------------------------------------------ |
| Тип                           | Ссылочный тип                                          |
| Множество допустимых значений | Определяется ограничениями (bounds)                    |
| Время существования           | Только compile-time                                    |
| Runtime-поведение             | Заменяется верхней границей (upper bound) или `Object` |

## Пример корректного объявления типовой переменной
```java
class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}
```

Здесь `T` — типовая переменная.

## Пример с ограничением (Upper Bound)
```java
class NumberBox<T extends Number> {
    T value;
}
```

Переменная `T` ограничена: допустимы типы `Integer`, `Double`, `Long`, но не `String`.

## Нарушение границы типа
```java
NumberBox<String> box = new NumberBox<>(); // Ошибка: String не является подтипом Number
```

Компилятор предотвращает нарушение типобезопасности.

## Подводные камни
```java
class Box<T> {
    T[] array = new T[10]; // Ошибка: generic array creation
}
```

> Типовые переменные **не имеют реального типа во время выполнения**, поэтому нельзя создавать массивы `generic`-типа.

## Практическое значение
- Типовые переменные позволяют реализовывать обобщённые, типобезопасные алгоритмы и структуры данных.
- Они лежат в основе коллекций Java (`List<T>`, `Map<K, V>`).
- Непонимание природы типовых переменных приводит к runtime ошибкам, если использовать raw types или unchecked casts.

# 4.1.27. Array Types (Типы массивов)  
_Массив (array)_ в Java — это ссылочный тип, представляющий **упорядоченную последовательность элементов одного типа**, доступ к которым осуществляется по индексу. Массивы являются объектами в Java, даже если содержат примитивные значения.

Каждый массив имеет **тип**, определяемый типом его элементов и количеством измерений.

## Свойства массивов

|Свойство|Описание|
|---|---|
|Nature|Ссылочный тип|
|Runtime type|Сохраняется полностью (arrays are reifiable types)|
|Covariant|`String[]` является подтипом `Object[]`|
|Length|неизменяемое поле `length` доступно во время выполнения|

## Пример корректного массива примитивов
```java
int[] numbers = new int[3];
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
```

## Пример массива объектов
```java
String[] names = { "Alice", "Bob" };
Object[] arr = names;    // допустимо (ковариантность)
System.out.println(arr[0]); // "Alice"
```

## Ошибка при нарушении типобезопасности
```java
Object[] arr = new String[1];
arr[0] = 100; // ArrayStoreException at runtime
```

> Несмотря на ковариантность, массивы проверяются JVM во время исполнения.

## Массивы и generics несовместимы
```java
List<String>[] array = new List<String>[10]; // Ошибка компиляции
```

> Массивы — _reifiable_, generics — _non-reifiable_ → их комбинация недопустима.

## Практическое значение
- Массивы используются, когда нужен **фиксированный размер и высокая производительность**.
- Коллекции предпочтительнее, когда нужен **динамический размер и безопасность типов**.
- Понимание ковариантности массивов важно для избежания runtime-исключений.

# 4.1.28. Class Types (Классовые типы)  
_Классовый тип (class type)_ — это ссылочный тип, определяемый объявлением `class` или полученный как вложенный, локальный, анонимный или параметризованный тип на основе класса. Классовый тип может описывать как конкретные объекты, так и абстрактные сущности (abstract classes).

Класс определяется:
- именем,
- набором членов (поля, методы, вложенные типы),
- модификаторами (`public`, `final`, `abstract`, `sealed`),
- списком базовых классов и/или интерфейсов.

## Пример объявлении классовых типов
```java
public class Person {
    String name;
    int age;
}

abstract class Shape {
    abstract double area();
}
```

## Особые формы классов

| Тип класса            | Описание                         | Пример                                                  |
| --------------------- | -------------------------------- | ------------------------------------------------------- |
| Вложенный класс       | объявлен внутри другого класса   | `class Outer { class Inner {} }`                        |
| Статический вложенный | вложенный с модификатором static | `static class Helper {}`                                |
| Локальный класс       | объявлен в блоке кода            | `void m(){ class Local{} }`                             |
| Анонимный класс       | без имени, объявляется на месте  | `Runnable r = new Runnable() { public void run() {} };` |
| Parameterized class   | класс с параметрами типа         | `class Box<T> {}`                                       |

## Ошибка наследования (однонаследование)

```java
class A {}
class B {}
class C extends A, B {} // Ошибка: множественное наследование классов запрещено
```

Подводный камень: final класс
```java
final class Constants {}
class MyClass extends Constants {} // Ошибка: нельзя наследоваться от final класса
```

## Практическое значение
- Классовые типы — основа объектной модели Java.
- Они определяют структуру объектов, механизм наследования и полиморфизма.
- Понимание классовых типов критично для понимания ссылочных типов, JVM-памяти и модели исполнения.

# 4.1.29. Interface Types (Интерфейсные типы)  
_Интерфейс_ — это ссылочный тип, который задаёт **контракт поведения**, но **не содержит состояния** (за исключением `static` и `default`-методов с полями `static final`). Интерфейсы могут быть функциональными (одно абстрактное метод) или `marker`-типами (не содержат методов).

## Пример интерфейса
```java
interface Movable {
    void move();
}
```

## Функциональный интерфейс (используется в лямбдах)
```java
@FunctionalInterface
interface Calculator {
    int calc(int x, int y);
}
```

## Ошибка: множественное наследование с конфликтом
```java
interface A { default void m(){ System.out.println("A"); } }
interface B { default void m(){ System.out.println("B"); } }

class C implements A, B {} // Ошибка: конфликт default-методов
```

## Корректное разрешение конфликта
```java
class C implements A, B {
    public void m(){
        A.super.m(); // Явное указание, какое поведение использовать
    }
}
```

Подводные камни
- Интерфейсы **не определяют конструктора**.
- Интерфейсы могут содержать **private-static методы** (начиная с Java 9).
- Интерфейсы участвуют в **множественном наследовании типов (мультинаследование контрактов)**.

## Практическое значение
- Интерфейсы лежат в основе **полиморфизма и программирования через абстракции**.
- Они обязательны для понимания **дизайна API, функционального программирования и DI (dependency injection)**.

# 4.1.30. Bounds (Ограничения типов: Upper и Lower Bounds)
_Ограничение типов (`bounds`)_ — это механизм, определяющий допустимые значения типовых переменных или `wildcard`-типов. Ограничения задают **верхнюю** (`extends`) или **нижнюю** (`super`) границу.

## Upper Bound (extends) — значение должно быть подтипом
```java
class Box<T extends Number> {
    T value; // T может быть Integer, Double, Long, но не String
}
```

## Lower Bound (super) — значение должно быть надтипом
```java
List<? super Integer> list = new ArrayList<Number>(); // допустимо
list.add(10); // допустимо
// list.add(3.14); // ошибка: Double не является Integer
```

## Intersection Bounds
```java
<T extends Number & Comparable<T>> // T должен быть одновременно Number и Comparable
```

> JLS требует, чтобы класс был только один, а интерфейсов могло быть несколько.

## Ошибочный пример
```java
<T extends Comparable<T> & Number> // Ошибка: класс должен быть первым
```

## Практическое значение
- Ограничения позволяют использовать API с типобезопасностью.
- Это фундамент Generics и обеспечивающий корректную работу методов (например, Collections.sort).

# 4.1.31. Wildcards (`?`, `? extends`, `? super`)
`_Wildcard`-типы_ — это форма параметризованных типов `generics`, позволяющая описывать множество допустимых аргументов типа. Обозначаются символом `?` и используются для обобщения, когда конкретный тип-параметр неизвестен или не важен.

`Wildcard` — это **не типовая переменная**, а **placeholder** для диапазона возможных типов.

## Формы wildcard

|Wildcard|Определение|Разрешённые типы|Типичная роль|
|---|---|---|---|
|`?`|Неизвестный тип|Любой ссылочный тип|Общий доступ только на чтение|
|`? extends T`|Ограничение сверху|`T` и его подтипы|Producer (производит данные)|
|`? super T`|Ограничение снизу|`T` и его надтипы|Consumer (поглощает данные)|

> Правило PECS
> - **Producer Extends** – если источник данных.
> - **Consumer Super** – если получатель данных.

Примеры использования
```java
List<?> listAny = List.of("A", 1, true); // только чтение
Object o = listAny.get(0);               // OK
// listAny.add("x"); // ошибка: неизвестно, какой тип допустим

List<? extends Number> numbers = List.of(1, 2, 3);
// numbers.add(10); // ошибка: нельзя добавлять

List<? super Integer> sink = new ArrayList<Number>();
sink.add(100); // OK — Integer является допустимым типом
Object v = sink.get(0); // возвращаемое значение типа Object
```

Ошибки
```java
List<? extends Number> a = new ArrayList<Integer>();
a.add(5); // compile-time error

List<?> b = new ArrayList<String>();
b.add("text"); // compile-time error
```

## Назначение wildcard
- Обеспечение инвариантных по умолчанию `generics` гибкостью.
- Устранение необходимости создавать избыточные перегрузки методов.
- Используются в коллекциях, API стандартной библиотеки, Stream API.

# 4.1.32. Type Soundness (Типовая безопасность)
_`Type soundness`_ — гарантия того, что любая программа, успешно скомпилированная по правилам Java, **не вызовет ошибок типов во время выполнения** (за исключением случаев намеренного использования небезопасных операций: `raw types`, `reflection`, `unsafe`).

## Основной принцип
> Код, прошедший этап проверки типов (`type checking`), **не может нарушить целостность памяти или JVM**.

## Исключения (нарушения `type safety`)
- использование `raw types`
- явные приведения (`(Type)`)
- JNI и `sun.misc.Unsafe`
- рефлексия

## Пример нарушения soundness
```java
List rawList = new ArrayList<String>();
rawList.add(10); // допустимо в raw type

List<String> list = rawList;
String s = list.get(0); // ClassCastException
```

> `raw types` отключают `generics` и нарушают типобезопасность.

# 4.1.33. Intersection Types (Пересечённые типы)  
_Пересечённый тип (`intersection type`)_ – это ссылочный тип, который описывает сущность, соответствующую одновременно нескольким типам. Значение пересечённого типа должно удовлетворять всем указанным ограничениям (`bounds`).

Используется в `generics`, особенно для ограничения типовых параметров.

Формат
```
T extends A & B & C
```

Где
- `A` должен быть классом (и только один),
- `B`, `C` и т.д. — интерфейсы.

Пример
```java
<T extends Serializable & Comparable<T>> T max(T a, T b) {
    return a.compareTo(b) >= 0 ? a : b;
}
```

Здесь `T` должен быть **одновременно** `Serializable` и `Comparable`.

Ошибочный пример
```java
<T extends Comparable<T> & Number> // Ошибка: класс должен быть указан первым
```

## Практическое применение
- Позволяет накладывать _множественные ограничения_ на типовые переменные.
- Используется для описания сложных API.

# 4.1.34. Wildcards и их роль в системе типов (расширение)
Этот подраздел расширяет понимание `wildcard`-типов в контексте **типобезопасности**, **подстановочных отношений** и **вариантности** `generics`.

## Инвариантность generics
По умолчанию обобщённые типы **инвариантны**
```java
List<Object> a = new ArrayList<String>(); // ❌ ошибка
```

Чтобы разрешить совместимость типов, применяются wildcard.

## Вариантность generics

|Аспект|Описание|Пример|Добавление|Чтение|Тип назначения|
|---|---|---|---|---|---|
|Инвариантность|Только точное совпадение|`List<String>`|✓|✓|`List<String>`|
|Ковариантность|Подтипы допускаются (extends)|`List<? extends Number>`|❌|✓|List of unknown subtype|
|Контравариантность|Надтипы допускаются (super)|`List<? super Integer>`|✓|Возвращает `Object`|List of unknown supertype|

## Корректное API через wildcard
```java
void print(List<? extends Number> list) {
    for (Number n : list) System.out.println(n);
}

void addDefault(List<? super Integer> list) {
    list.add(0); // гарантированно Integer и его надтипы принимают это значение
}
```

Подводные камни
- `? extends` — безопасно **только для чтения** (`read-only`).
- `? super` — безопасно **только для записи** (`write-only`).
- Нельзя использовать `wildcard` в объявлении типа параметра:

```java
class Box<? extends Number> {} // ❌ ошибка: wildcard только в использовании
```
`Wildcards` являются механизмом **типобезопасности и гибкости generics**, а не заменой параметров типа. Они позволяют описывать диапазоны совместимости при соблюдении строгих ограничений.

# 4.1.35. Типовая безопасность и нарушения (Type Safety & Unsafety)
**Type** `Safety` — это гарантия того, что операции с типами не приводят к непредсказуемому поведению на этапе выполнения.

Java обеспечивает `sound type system` _при условии_, что:
- не используются raw types,
- не используется reflection без проверок,
- generics используются корректно.

## Safe Example
```java
List<String> list = new ArrayList<>();
list.add("Java");
String value = list.get(0); // безопасно
```

## Небезопасный пример (raw types)
```java
List raw = new ArrayList<String>();
raw.add(10); // добавляем Integer

List<String> list = raw;
String s = list.get(0); // ClassCastException
```

> `Raw types` отключают `compile-time` безопасность.

## Unchecked cast (предупреждение компилятора)
```java
List<String> list = (List<String>) (List<?>) new ArrayList<Integer>(); // unchecked cast warning
```

> Type safety — это **не абсолютное свойство языка**, а **контракт между программистом, компилятором и JVM**, который можно нарушить при неправильном использовании generics и raw types.

# 4.1.38. Sealed Types (запечатанные типы)
_`Sealed` типы_ — классы и интерфейсы, помеченные `sealed`, которые **ограничивают множество допустимых подтипов** через директиву `permits`. Допустимые подтипы должны быть `final`, `sealed` или `non-sealed`.

Пример (класс)
```java
public sealed class Shape permits Circle, Rectangle {}

public final class Circle extends Shape {}
public non-sealed class Rectangle extends Shape {}
```

Пример (интерфейс)
```java
public sealed interface Expr permits Const, Add {}
record Const(int value) implements Expr {}
public final class Add implements Expr {
    public final Expr left, right;
    public Add(Expr l, Expr r) { this.left = l; this.right = r; }
}
```

Ошибка
```java
public final class Triangle extends Shape {} // Ошибка: Triangle не указан в permits Shape
```

Подводные камни
- Все **прямые наследники** должны быть перечислены в `permits`.
- Подкласс обязан иметь модификатор среди `final|sealed|non-sealed`.
- `Sealed`-иерархии упрощают `exhaustive switch` (см. `pattern matching`) и повышают безопасность моделирования домена.

# 4.1.39. Record Types (записные классы)  
_`Records`_ — это **классы-носители данных** с компактным синтаксисом, иммутабельными компонентами и автоматически сгенерированными `equals/hashCode/toString`. Являются **классовыми типами**.

Пример
```java
public record Point(int x, int y) {
    public int manhattan() { return Math.abs(x) + Math.abs(y); }
}
```

### Свойства
- Иммутабельность компонент, финальные поля.
- Автоматическая реализация методов, основанная на компонентах.
- Можно валидировать инварианты в компактном конструкторе.

Ошибка
```java
public record Bad(int x) {
    public void setX(int nx) { /*...*/ } // Ошибка: нельзя мутабельно менять компоненту
}
```

Подводные камни
- `Record` — **не** `data class` «как в Kotlin»: мутабельности нет; для инкапсуляции сложных инвариантов используйте валидацию в конструкторе.

# 4.1.40. Аннотации на типах (Type Annotations, JSR 308)  
_Аннотации могут применяться к типам_, а не только к объявлениям. Это позволяет статическим анализаторам (`SpotBugs`, `Checker Framework`) и инструментам верифицировать свойства вроде `nullability`.

Примеры
```java
List<@NonNull String> names;           // аннотация на аргументе типа
@Readonly List<String> view;           // аннотация на самом типе
Map<@KeyType UUID, @ValueType String> m;
```

Ошибка (семантическая)
```java
List<@NonNull String> xs = List.of("a", null); // в рантайме скомпилируется, но анализаторы пожалуются
```

Подводные камни
- Типовые аннотации — `compile-time/analysis-time` контракт, JVM их не применяет автоматически.
- Требуют поддержки инструментами (IDE, аннотационные процессоры).

# 4.1.41. Reifiable Types: уточнение и строгая классификация
_Восстанавливаемый тип (`reifiable type`)_ — это тип, информация о котором **полностью доступна JVM во время выполнения**. Такой тип сохраняет всю необходимую информацию о своей структуре в байткоде и не подвергается стиранию.

## Ключевой критерий  
_Если тип можно проверить с помощью оператора `instanceof` или создать массив этого типа без ошибок компиляции и предупреждений — он является `reifiable`._

## Типы, являющиеся reifiable

| Категория                                        | Примеры                          | Пояснение                                                               |
| ------------------------------------------------ | -------------------------------- | ----------------------------------------------------------------------- |
| Примитивные типы                                 | `int`, `double`, `boolean`       | Полностью известны во время выполнения                                  |
| Непараметризованные ссылочные типы               | `String`, `Object`, `Number`     | Не содержат generics, не стираются                                      |
| Raw types                                        | `List`, `Map`                    | Используются для обратной совместимости, generics игнорируются          |
| Параметризованные типы с неограниченным wildcard | `List<?>`, `Map<?,?>`            | Единственный случай параметризованного типа, который является reifiable |
| Тип `null`                                       | `null`                           | Единственное значение, совместимое со всеми ссылочными типами           |
| Массивы с reifiable компонентным типом           | `String[]`, `int[]`, `List<?>[]` | Тип элементов полностью известен                                        |

## Типы, не являющиеся reifiable

| Категория                                        | Пример                                            | Причина                                                  |
| ------------------------------------------------ | ------------------------------------------------- | -------------------------------------------------------- |
| Параметризованные типы с конкретными аргументами | `List<String>`, `Map<Integer, String>`            | Типовые аргументы стираются до `Object`                  |
| Wildcard с ограничением (bounded wildcard        | `List<? extends Number>`, `List<? super Integer>` | Информация о границе стирается                           |
| Типовые переменные                               | `T`, `E`, `K`                                     | Стираются до верхней границы (`Object` или другой bound) |
| Параметризованные массивы                        | `new List<String>[10]`                            | Нельзя создать, т.к. тип не reifiable                    |

## Примеры допустимых и недопустимых операций
```java
// ✅ Разрешено — тип reifiable
if (obj instanceof List<?>) {
    System.out.println("obj — это List<?>");
}

// ❌ Ошибка компиляции — тип не reifiable
if (obj instanceof List<String>) { } // Компилятор: illegal generic type for instanceof

// ✅ Создание массива с reifiable типом
List<?>[] array = new List<?>[10];

// ❌ Ошибка: generic array creation
List<String>[] array2 = new List<String>[10]; // compile-time error
```

Вывод
- `List<?>` — `reifiable` тип (это важно!).
- Любой `generic`-тип с конкретными типовыми аргументами (`List<String>`) — не `reifiable`.
- `Reifiable`-типы безопасны для `runtime`-проверок (`instanceof`, `array creation`).
- `Non-reifiable`-типы доступны только на этапе компиляции; JVM не знает их конкретную структуру.

> Этот пункт устраняет распространённые заблуждения и формирует фундамент понимания поведения `generics` на уровне JVM.

# 4.1.42. Heap Pollution и @SafeVarargs
`_Heap pollution_` — ситуация, когда переменная с параметризованным типом указывает на объект, чей фактический тип нарушает заявленные аргументы типа (обычно из-за смешения `generics` и массивов/варрагов).

## Пример (heap pollution)
```java
static void unsafe(List<String>... lists) {
    Object[] arr = lists;         // массив стирает аргументы типа
    arr[0] = List.of(1);          // подсовываем List<Integer>
    String s = lists[0].get(0);   // ClassCastException
}
```

Как смягчать
- Избегать `varargs` с параметризованными типами.
- Помечать доверенные `varargs`-методы аннотацией `@SafeVarargs`.

```java
@SafeVarargs
static <T> List<T> concat(List<T>... parts) {
    List<T> r = new ArrayList<>();
    for (List<T> p : parts) r.addAll(p);
    return r;
}
```

Подводные камни
- `@SafeVarargs` **не проверяет** безопасность — вы как автор **гарантируете** её.
- Разрешена только на `static`, `final`, или `private` методах.

# 4.1.43. Raw Types и @SuppressWarnings
`Raw types` — использование имени обобщённого типа без аргументов (`List` вместо `List<T>`).  
Доступно для обратной совместимости, но **снимает compile-time гарантии**.

Пример
```java
List raw = new ArrayList<String>();
raw.add(42); // ОК
List<String> strings = raw;
String s = strings.get(0); // ClassCastException
```

`@SuppressWarnings("unchecked")` — подавляет предупреждения для известных безопасных приведения/операций, но **используйте точечно** и документируйте причину.

# 4.1.44. `var` и переменные шаблонов (pattern variables): примечание
- `var` — **не тип**, а **синтаксис вывода локального типа** (compile-time). Правило: правая часть должна однозначно определять тип.
- Переменные шаблонов (`instanceof Type t`) — **переменные**, зависящие от потока управления; **это не типы**, а механизм **связывания имени** со значением при успешном сопоставлении.

Пример (`var`)
```java
var list = new ArrayList<String>(); // тип list — ArrayList<String>
list = new ArrayList<Integer>();    // ❌ Ошибка: несовместимо с выведенным типом
```

Пример (pattern variable)
```java
Object o = "hi";
if (o instanceof String s) {
    System.out.println(s.length()); // переменная s видима внутри блока if
}
```

# 4.1.45. Строковый пул, литералы класса и массивов: тонкости

> Этот раздел выделяет **три фундаментальных вида ссылочных типов**, которые обладают особыми свойствами в системе типов и памяти JVM.

## 4.1.45.1. Тип String и строковый пул
### Строка как особый ссылочный тип
`String` — это финальный неизменяемый ссылочный тип. Значения строк хранятся в специальной области памяти JVM — `String Pool`, обеспечивающей уникальность литералов и оптимизацию памяти.

```java
String a = "Java";
String b = "Java";
System.out.println(a == b); // true — обе ссылки указывают на один объект из пула
```

```java
String c = new String("Java");
System.out.println(a == c); // false — создан новый объект вне пула
System.out.println(a.equals(c)); // true — логически равны
```

### Свойства String

|Свойство|Значение|
|---|---|
|Тип|ссылочный, final|
|Изменяемость|неизменяемый|
|Хранение|литералы интернируются|
|Роль в типовой системе|String — подтип Object, поддерживает интерфейсы `CharSequence`, `Serializable`, `Comparable<String>`|

## 4.1.45.2. Литералы класса (`Class Literals`) и метаданные типов
Каждый тип в Java (включая примитивы и массивы) имеет ссылку на объект типа `java.lang.Class`, представляющий метаданные этого типа.

```java
Class<String> c1 = String.class;  // литерал ссылочного типа
Class<int[]> c2 = int[].class;    // литерал массивного типа
Class<Void> c3 = void.class;      // литерал псевдотипа void
```

Свойства

|Особенность|Описание|
|---|---|
|Единственность|Для каждого типа JVM создаёт только один объект `Class`|
|Инвариантность|`Class<T>` инвариантен — `Class<String>` не подтип `Class<Object>`|
|Использование|рефлексия, загрузка классов, метаданные|

## 4.1.45.3. Типы массивов
_Массивы — полноценные ссылочные типы, которые:_
- являются **covariant** (ковариантными),
- **сохраняют структуру типа во время выполнения** (`reifiable`),
- всегда наследуют `Object` и реализуют интерфейс `Cloneable` и `Serializable`.

```java
int[] a = {1, 2, 3};
Object o = a;             // допустимо
System.out.println(o.getClass()); // class [I — массив int
```

### Ковариантность массивов
```java
String[] strings = new String[1];
Object[] objects = strings; // допустимо (ковариантность)
objects[0] = 123; // ArrayStoreException во время выполнения
```

### Свойства массивов

|Характеристика|Значение|
|---|---|
|Тип|ссылочный|
|Память|объект в куче|
|Runtime knowledge|компонентный тип известен (reifiable)|
|Наследование|подтип Object, реализует Cloneable, Serializable|

# 4.1.46. Хорошая практика
- Не используйте **raw types**; сохраняйте аргументы типа.
- Избегайте **массивов параметризованных типов** и varargs без `@SafeVarargs`.
- Не делайте предположений о **runtime-типе** при наличии стирания.
- Для сравнения объектов — **`.equals`**, для ссылок — `==`.
- Для API с «производителем» — `? extends T`; с «потребителем» — `? super T` (**PECS**).
- В иерархиях используйте `sealed` для явных границ домена.
- Для простых DTO — рассматривайте `record`.
- Используйте **type annotations** для nullability и контрактов, если команда это поддерживает.

# 4.1.47. Номинальная типизация Java (Nominal vs Structural)
Java — **номинально типизированный** язык: совместимость определяется **именем иерархии типов** (декларациями `extends`/`implements`), а не только «формой» (набором членов).

## Пример - номинальная типизация
```java
class A { void m() {} }
class B { void m() {} }

void f(A a) {}
f(new B()); // ❌ Ошибка: B не объявлен подтипом A, несмотря на одинаковый «интерфейс»
```

## Следствия
- Совместимость — через явные отношения наследования/реализации.
- Отсутствуют «структурные» соответствия как в `TypeScript/Go`.
- **Интерфейсы** — основной способ моделировать «по форме», но они всё равно номинальны.

**Подводный камень:** попытки «подменить тип по форме» требуют адаптеров/мапперов.

# 4.1.48. Класс-литералы и обобщения: что допустимо

Правила
- Нельзя получать класс-литерал для параметризованного типа:
```java
// ❌ Нельзя:
Class<List<String>> c = List<String>.class; // ошибка синтаксиса
```

- Используйте необобщённый `Class` или `wildcard`:
```java
Class<List> c1 = List.class;           // OK (raw)
Class<? extends List> c2 = List.class; // OK
```

- Для массивов допустимы литералы компонентных типов:
```java
Class<int[]> a1 = int[].class;     // OK
Class<List<?>[]> a2 = List<?>[].class; // OK (элемент reifiable)
```

Подводные камни
- `Class<T>` **инвариантен** → в API чаще принимайте `Class<? extends T>`.

# 4.1.49. Автоупаковка/распаковка (Boxing/Unboxing): тонкости  
_Упаковка_ — преобразование примитива в оболочку (`int → Integer`), _распаковка_ — наоборот.

### Примеры и ловушки
```java
Integer a = 128, b = 128;
System.out.println(a == b); // false (вне кеша)
Integer x = null;
int y = x;                  // ❌ NullPointerException (unboxing null)
```

```java
Map<Integer, String> m = new HashMap<>();
m.put(1, "one");
m.put(1, "uno"); // автопакет создаёт ключи последовательно, равенство по .equals()
```

Советы:
- Избегайте `==` для оболочек — используйте `.equals`.
- Берегитесь распаковки `null`.
- В горячем коде — профилируйте: автоупаковка создаёт объекты и давит на GC.

# 4.1.50. Захват типа (Capture Conversion) и wildcard
Захват типа (`_capture conversion_`) — процесс, при котором компилятор для выражения с `wildcard` временно выводит **скрытую типовую переменную**, чтобы гарантировать типобезопасность.

Это позволяет использовать `wildcard`-типы в контексте методов, ожидающих конкретную типовую переменную.

## Пример захвата типа
```java
static void process(List<?> list) {
    capture(list);
}

private static <T> void capture(List<T> list) {
    T elem = list.get(0);
    System.out.println(elem);
}
```

> При вызове `process(List<Integer>)` компилятор **захватывает** `?` и выводит `T = Integer`.

## Ошибка без захвата
```java
static void invalid(List<?> list) {
    list.add(list.get(0)); // ошибка: ? неизвестен
}
```

Компилятор не может подтвердить, что добавление безопасно, поскольку тип `?` не фиксирован.

## Корректное решение с capture method
```java
static <T> void copy(List<? super T> dest, List<? extends T> src) {
    for (T t : src) dest.add(t);
}
```

## Назначение capture conversion
- Обеспечивает **безопасное использование wildcard-типов**.
- Позволяет компилятору вывести фактический тип.
- Является фундаментом для корректной работы `Collections.copy`, Stream API и других generics-утилит.

Итог

|Свойство|Wildcard без capture|Capture Conversion|
|---|---|---|
|Тип точно известен|Нет|Да|
|Можно добавлять значения|Нет (для `?` и `? extends`)|Да (для `? super`)|
|Типобезопасность проверяется компилятором|Ограниченно|Гарантировано|

# 4.1.51. Мостовые методы (Bridge Methods) и стирание типов  
При стирании `generics` компилятор может сгенерировать **bridge-методы**, чтобы сохранить переопределение и полиморфизм на уровне стираних сигнатур.

Пример
```java
class Box<T> { T get() { ... } }
class StringBox extends Box<String> {
    @Override String get() { ... }
}
```

После стирания у базового класса сигнатура — `Object get()`. Компилятор вставит невидимый
```java
Object get() { return get(); } // bridge
```

чтобы вызовы через базовую ссылку работали.

Подводные камни
- `Bridge`-методы видны в рефлексии; учитывайте при генерации прокси/логгировании.
- Ошибки «method not found» иногда связаны с некорректной обработкой `bridge` в сторонних инструментах.

# 4.1.52. Pattern Matching: `instanceof` и `switch` (обзор связки с типами)

### Pattern-переменные
```java
Object o = "java";
if (o instanceof String s && s.length() > 2) {
    System.out.println(s.toUpperCase());
}
```

- Переменная `s` видима в **безопасных** ветках (`flow-sensitive typing`).

### Exhaustive switch с sealed-иерархиями:
```java
sealed interface Expr permits Const, Add {}
record Const(int v) implements Expr {}
record Add(Expr l, Expr r) implements Expr {}

static int eval(Expr e) {
    return switch (e) {
        case Const c -> c.v();
        case Add a   -> eval(a.l()) + eval(a.r());
    }; // исчерпывающе: все прямые подтипы покрыты
}
```

Подводные камни
- Доминирование/достижимость паттернов: более общий шаблон может «затенить» частные.
- В 4.1 мы фиксируем **типовую основу**; полные правила — в главах про выражения и `switch`.

# 4.1.53. Об отсутствии union-типов и тип-безопасные альтернативы

**Факт:** Java **не имеет** встроенных `union`-типов (`A|B`).  
Альтернативы
- Иерархии с `sealed` + `switch` с исчерпывающей обработкой.
- `Optional<T>` вместо `T|null` (когда уместно).
- Альгебраические типы через records:
```java
sealed interface Result<T> permits Ok, Err {}
record Ok<T>(T value) implements Result<T> {}
record Err<T>(String msg) implements Result<T> {}
```

Подводные камни: не сводите всё к `Object` + кастам — потеряете типобезопасность.

# 4.1.54. Контракты `equals`/`hashCode` и типы (короткий чек)
Контракты `equals()` и `hashCode()` являются **неотъемлемой частью системы типов Java**, так как они определяют **семантику идентичности и логического равенства объектов**. Нарушение этих контрактов приводит к **непредсказуемому поведению коллекций**, ошибок ORM и нарушению принципов ООП.

## 4.1.54.1. Контракт `equals()`
Метод должен реализовывать следующие свойства:

|Свойство|Описание|
|---|---|
|Рефлексивность|`x.equals(x)` → `true`|
|Симметричность|`x.equals(y)` == `y.equals(x)`|
|Транзитивность|если `x.equals(y)` и `y.equals(z)` → `x.equals(z)`|
|Консистентность|повторные вызовы дают один результат|
|Сравнение с `null`|`x.equals(null)` → `false`|

## 4.1.54.2. Контракт `hashCode()`

Если два объекта равны по `equals()`, они **обязаны иметь одинаковый** `hashCode`.  
Обратное не обязательно (разные объекты могут иметь одинаковый `hashCode` — коллизия).

Пример правильной реализации
```java
class Point {
    final int x, y;

    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Point)) return false;
        Point p = (Point) o;
        return x == p.x && y == p.y;
    }

    public int hashCode() {
        return 31 * x + y;
    }
}
```

Ошибка: equals переопределён, hashCode — нет
```java
class Bad {
    int x;
    public boolean equals(Object o) {
        return o instanceof Bad && ((Bad) o).x == this.x;
    }
}
```

Последствия:
- При добавлении объекта в `HashSet`, он не будет найден позже
- ORM (Hibernate) некорректно управляет сущностями
- HashMap создаёт дубликаты вместо перезаписи

## 4.1.54.3. Ошибки при наследовании и полиморфизме
### Ошибка нарушения Liskov Substitution Principle
```java
class A {
    int id;
    public boolean equals(Object o) {
        return o instanceof A && ((A) o).id == id;
    }
}

class B extends A {
    String tag;
    public boolean equals(Object o) {
        if (!(o instanceof B)) return false;
        B b = (B) o;
        return super.equals(b) && tag.equals(b.tag);
    }
}
```

Если сравнивать `A` и `B`, транзитивность нарушается.

**Решение:** использовать `getClass()` вместо `instanceof`, если класс не предназначен для наследования.
```java
public boolean equals(Object o) {
    if (o == null || getClass() != o.getClass()) return false;
    ...
}
```

## 4.1.54.4. Иммутабельность и equals
Для `immutable`-типа (например, `String`, `Integer`, `record`) контракт `equals/hashCode` гарантирован и безопасен.

Рекомендуется использовать `record`, если объект:
- имеет `value`-семантику,
- не предполагает наследования,
- должен быть `immutable`.

```java
record Point(int x, int y) {}
```

## 4.1.54.5. Практический чек-лист

|Ситуация|Что использовать|Почему|
|---|---|---|
|Сравнение ссылок|`==`|быстро и точно|
|Сравнение содержимого|`equals()`|логическое равенство|
|Ключи в HashMap|переопределить `equals()` и `hashCode()`|гарантия поиска|
|Value-объекты|используйте `record`|контракт генерируется автоматически|
|Наследование|используйте `getClass()` в equals|предотвращение нарушения транзитивности|

Контракты `equals()` и `hashCode()` — не просто «методы класса», а **часть типовой системы Java** и основа корректного поведения ссылочных типов в коллекциях и при полиморфизме. Их правильная реализация критична для любой промышленной системы.

