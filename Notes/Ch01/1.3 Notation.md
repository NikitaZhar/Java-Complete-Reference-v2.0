2025-10-01 15:26
Tags: #Notation

Эта часть отвечает на вопрос: как читать спецификацию.
## 1.3.1 Терминология и типографика
- Нетерминалы грамматики выделяются курсивом: _`Expression`_, `_Type_`, `_Statement_`.
- Терминалы (литералы, ключевые слова, символы) записываются моноширинным шрифтом: `if`, `switch`, `'{'`, `'}'`.
- Имена классов из модуля `java.base` могут писаться без полного имени; если приводится простое имя `String`, имеется в виду `java.lang.String`, если контекст не говорит обратного.

## 1.3.2 Лексическая vs синтаксическая грамматика
- **Лексическая грамматика** (Ch. 3): определяет **токены** (идентификаторы, ключевые слова, литералы, операторы, разделители). В неё включены шаги «перевода» входного потока символов (Unicode escapes, line terminators).
- **Синтаксическая грамматика** (Ch. 2, Ch. 14–15): строит программы из токенов посредством продукции вида  
`IfThenStatement: if ( Expression ) Statement`.
- Разделение важно: **невозможные по лексике последовательности** даже не дойдут до синтаксического анализатора.

## 1.3.3 Продукции и альтернативы
- Правило задаётся как **продукция**:  
`Statement: Block | IfThenStatement | WhileStatement | ...`
- Вертикальная черта `|` означает **альтернативы**. Квадратные скобки — опциональность (в JLS чаще используется отдельная продукция для опции: `opt`).
- Многоточие `…` в тексте спецификации в примерах означает сокращение, **а не часть грамматики**.

Пример чтения правила
```java
MethodDeclaration:
    MethodHeader MethodBody
MethodHeader:
    {MethodModifier} Result MethodDeclarator [Throws]
```

Что это означает?
- Ноль или более модификаторов, затем тип результата, затем декларатор, опционально `throws`-раздел.
- Декларатор определяет имя и список параметров; именно здесь задаются varargs и аннотации параметров.

Типичная ошибка чтения
- Путать «опциональность» (`opt`) с «наличием по умолчанию». Если часть синтаксиса опциональна, это **не означает**, что она подразумевается при отсутствии: семантика отсутствующей части указана отдельно (напр., тело абстрактного метода отсутствует, и это не «пустое тело»).

## 1.3.4 «Дефинитное присваивание», вывод типов и разрешение перегрузки
JLS использует формальные разделы для небанальных проверок компилятора:
- `Definite Assignment` (`DA/DU`) — переменная должна быть «определённо присвоена» до чтения; для `final` — особые правила.
- `Type Inference` — вывод параметров дженериков при вызове методов.
- `Overload Resolution` — как выбирается перегруженный метод.

Пример (DA)
```java
int x;
if (Math.random() > 0.5) x = 1;
System.out.println(x); // ошибка DA: x может быть не присвоен
```

Правильный вариант
```java
int x;
if (Math.random() > 0.5) x = 1; else x = 0;
System.out.println(x); // ok
```

## 1.3.5 Unicode и лексические преобразования
- Исходный текст _логически_ рассматривается как последовательность **Unicode-кодовых точек**.
- Unicode-эскейпы (`\uXXXX`) преобразуются **до** лексического анализа, что может изменять видимые токены.

Подводный камень
```java
// На вид: \u0069f (буква i + f)
int \u0069f = 0; // это 'if' после обработки эскейпа → синтаксическая катастрофа
```

## 1.3.6 Unicode Translation Step
JLS (§3.2) подчёркивает, что перед лексическим анализом исходный текст проходит **Unicode-преобразование**.
- Все последовательности `\uXXXX` разворачиваются в соответствующие Unicode-символы.
- Преобразование происходит до токенизации, что может неожиданно изменить код.

Пример
```java
// На вид это комментарий
// \u000a System.out.println("executed");
```

> До лексического анализа `\u000a` становится переводом строки, и следующая часть превращается в исполняемый код.

Подводный камень
```java
int i\u0066 = 0; // после обработки становится "int if = 0;" → ошибка
```

## 1.3.7 Правильный порядок чтения правил
При разборе спецификации важно соблюдать логику:
1. Сначала ищите **синтаксическую продукцию** в Ch. 2, 14–15.
2. Затем проверяйте **сопутствующие семантические условия** в соответствующих главах (например, definite assignment в Ch. 16).
3. Если синтаксическая форма разрешена, но возникает ошибка компиляции, ищите причину в семантических ограничениях.

> JLS нередко ссылается на более детальные под-правила. Следует всегда переходить по ссылкам.

## 1.3.8 Частые ловушки при чтении грамматики
- Квадратные скобки `[...]` в спецификации обозначают **необязательный элемент** грамматики, а не литерал языка.
- Суффикс `opt` после нетерминала означает, что этот элемент может отсутствовать.  
  Пример:
  ```
  IfThenStatement:
      if ( Expression ) Statement [else Statement]
  ```
  → `else` не обязателен.

- Разделители `|` обозначают **альтернативы**, а не битовые операции.

## 1.3.9 Compile-Time Constants и runtime-выражения
Частая ошибка при чтении спецификации — смешение **констант времени компиляции** и выражений, вычисляемых во время выполнения.
- `Compile-time constant expressions` (§15.28) вычисляются на этапе компиляции и могут использоваться, например, в `case`-метках `switch`.
- Выражения, зависящие от переменных, считаются **runtime-выражениями**.

Пример
```java
final int A = 10;
int B = 10;

switch (x) {
    case A: ... // ok
    case B: ... // ошибка: B не compile-time constant
}
```

> Константы времени компиляции формируются из литералов, `final`-переменных примитивных типов и выражений, которые могут быть вычислены на этапе компиляции.
