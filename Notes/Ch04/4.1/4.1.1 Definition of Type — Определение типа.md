2025-10-27 13:37
Tags: #Types #toFormat 


Этот раздел формализует понятие _типа_ в языке Java — как концепции, лежащей в основе всех значений, переменных, выражений и деклараций.  
Рассматриваются роль типа на этапе компиляции и выполнения, его функции в системе совместимости и гарантиях корректности программы.

---

## 4.1.1.1 Формальное определение

Тип в Java — это формальная характеристика данных, которая определяет:

1. **Множество допустимых значений**, которые может принимать выражение или переменная.
    
2. **Набор разрешённых операций**, которые могут быть применены к этим значениям.
    
3. **Правила совместимости** с другими типами (можно ли использовать значение данного типа в контексте другого типа).
    
4. **Контракт времени компиляции и выполнения**, определяющий корректность программы и поведение при её исполнении.
    

Тип задаёт _абстракцию_ данных: он не является значением сам по себе, а описывает свойства значений.

> Тип можно рассматривать как математическое множество, а значение — как конкретный элемент этого множества.

---

## 4.1.1.2 Роль типа в системе языка

Типы выполняют в Java две ключевые роли.

### 1. Роль на этапе компиляции

- Компилятор использует типы для:
    
    - проверки корректности выражений;
        
    - проверки совместимости при присваивании и передаче аргументов;
        
    - выбора перегруженных методов;
        
    - выявления ошибок ещё до выполнения программы.
        
- Тип выражения всегда известен на этапе компиляции.
    

### 2. Роль во время выполнения

- Для ссылочных типов (`reference types`) существует **исполняемый тип** — фактический тип объекта в памяти JVM.
    
- JVM использует тип во время выполнения для:
    
    - динамической диспетчеризации методов (полиморфизм),
        
    - проверки приведения типов,
        
    - обработки исключений (`ClassCastException` при ошибочном приведении).
        

> Для примитивных типов статический тип полностью соответствует `runtime`-представлению.  
> Для ссылочных — статический и исполняемый тип могут различаться.

---

## 4.1.1.3 Тип как средство ограничения и гарантии корректности

Тип **ограничивает**, какие операции допустимы:

- Невозможно вызвать метод, не определённый типом.
    
- Нельзя выполнить арифметическую операцию над типом, который её не поддерживает.
    
- Нельзя присвоить значение одного типа переменной несовместимого типа.
    

```java
int x = 10;
String s = x; // Ошибка компиляции: несоответствие типов
```

Типы также гарантируют **типобезопасность** программы: корректная программа, прошедшая проверку типов, не нарушает модель памяти и не приводит к недопустимым операциям с данными.

> Java стремится к свойству _type soundness_:  
> если программа успешно скомпилирована, типовые ошибки во время выполнения невозможны,  
> за исключением явно небезопасных преобразований (`unchecked casts`) и обхода системы типов через отражение или `Unsafe`.

Все ссылочные типы в Java неявно восходят к `java.lang.Object`, который является общим надтипом для всех объектов.  
Это гарантирует наличие базовых операций (`equals`, `hashCode`, `toString`) и обеспечивает единый корень иерархии типов.

---

## 4.1.1.4 Тип как часть контракта программы

Тип определяет, _как именно_ поведение объекта или значения будет трактоваться:

- тип `int` означает целое число фиксированного диапазона;
    
- тип `String` означает объект, представляющий последовательность символов;
    
- тип `List<T>` означает структуру данных, содержащую элементы некоторого типа `T`;
    
- тип `void` определяет отсутствие возвращаемого значения (см. [[4.3.0 Reference Types — Overview]]).
    

Тип также определяет **идентичность на уровне JVM**: два типа считаются различными, даже если имеют одинаковую структуру, если они загружены разными загрузчиками классов.

**Ограничение:**  
`void` — это специальное обозначение отсутствия возвращаемого значения в сигнатуре метода и не является типом значений.  
`java.lang.Void` — ссылочный тип-маркер, применяемый в обобщениях.  
См. [[Reference Types and Values → Special Reference Forms]].

---

## 4.1.1.5 Идентичность и эквивалентность типов

Два типа могут быть:

- **Идентичными (identical)** — если они имеют одинаковое определение и были загружены одним и тем же загрузчиком классов (`ClassLoader`).
    
- **Эквивалентными (equivalent)** — если обладают одинаковой структурой и поведением, но принадлежат к разным контекстам загрузки (например, при динамической загрузке модулей или в разных слоях JPMS).
    

> Идентичность типа определяется не только его именем, но и контекстом загрузки.  
> Это свойство обеспечивает изоляцию модулей и безопасность исполнения в многомодульной JVM.

---

## 4.1.1.6 Тип как элемент системы совместимости (Subtyping)

Типы образуют **иерархию**:

- Один тип может быть _подтипом_ другого.
    
- Значение подтипа может использоваться там, где ожидается надтип.
    
- Тип определяет _контекст допустимого использования_ значения.
    

```java
Number n = Integer.valueOf(10); // Integer является подтипом Number
```

> В системе обобщений Java подтипирование не всегда сохраняется при параметризации:  
> `List<Integer>` не является подтипом `List<Number>`.  
> Такое поведение связано с _инвариантностью_ параметрических типов;  
> ковариантность и контравариантность реализуются с помощью wildcard-типов (`? extends`, `? super`).

Помимо обычного подтипирования, Java допускает _пересечение типов_ (`intersection types`) — тип, объединяющий несколько ограничений одновременно:

```java
<T extends Number & Comparable<T>> void process(T value) { ... }
```

Пересечения используются в дженериках и обеспечивают множественное наследование контрактов при сохранении типовой безопасности.

Подтипирование подробно рассматривается в разделе [[4.1.6 Subtypes and Supertypes]].

---

## 4.1.1.7 Типы на этапе компиляции и во время выполнения

Java различает два представления типа:

|Вид типа|Описание|Роль|
|---|---|---|
|**Compile-time type**|Статический тип, известный компилятору|Проверка корректности кода|
|**Runtime type**|Фактический тип объекта в куче|Определяет поведение и реализацию методов|

```java
Number n = Double.valueOf(3.14);
// Статический тип: Number
// Исполняемый тип: Double
```

> Разделение между compile-time и runtime типами является основой для реализации полиморфизма, позднего связывания и системы приведения типов в JVM.

На уровне байткода различие между примитивными и ссылочными типами отражается в инструкциях JVM  
(`iload`, `aload`, `invokevirtual`, `invokestatic` и др.).  
Это фундаментальное разделение определяет представление данных, область хранения и способ вызова методов.

---

## 4.1.1.8 Выведение и контекстная типизация

Современная Java поддерживает **контекстное выведение типа** (`type inference`) — определение типа выражения на основе его окружения.  
Это происходит на этапе компиляции и не влияет на типы времени выполнения.

Примеры:

```java
var list = List.of("A", "B", "C"); // тип выведен как List<String>
var n = 10;                         // тип выведен как int
```

Механизм выведения используется в следующих контекстах:

- локальные переменные с `var`;
    
- дженерики при вызове методов (`List.of(…)`, `Map.of(…)`);
    
- лямбда-выражения и функциональные интерфейсы;
    
- выражения `switch` и шаблоны (`patterns`).
    

> Выведение типов не создаёт новых типов;  
> оно лишь позволяет компилятору подставить корректный **compile-time type**,  
> соблюдая все правила совместимости и типобезопасности.

---

## 4.1.1.9 Итог

- Тип — центральная абстракция языка Java, описывающая свойства и поведение значений.
    
- На этапе компиляции тип обеспечивает проверку совместимости и корректность выражений.
    
- Во время выполнения тип управляет диспетчеризацией, безопасностью и реальной семантикой объектов.
    
- Различие между **compile-time type** и **runtime type** определяет модель наследования, работу обобщений и подтипирование.
    
- Контекстное выведение типов упрощает код, не ослабляя строгую типовую систему Java.
    

В современных версиях Java развивается поддержка **аннотаций nullability** (`@NonNull`, `@Nullable`)  
и статического анализа на основе аннотаций (JEP 466). Эти расширения повышают выразительность типовой системы,  
сохраняя её совместимость с существующей моделью.

> Далее см. [[4.2 Primitive Types and Values]] и [[4.3 Reference Types and Values]]  
> для рассмотрения конкретных категорий типов и их представления в памяти JVM.

---

Хочешь, чтобы я оформил следующий раздел **4.2 Primitive Types and Values** в том же академическом формате — с системной таблицей типов, диапазонами, поведением при конверсиях и ссылкой на §4.2 JLS SE 25?