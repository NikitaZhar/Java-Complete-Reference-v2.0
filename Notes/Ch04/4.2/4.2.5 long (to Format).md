2025-11-24 15:25
Tags: #long #toFormat 

## **4.2.5.1 Определение и диапазон**

Тип `long` — это **64-битный знаковый целочисленный примитивный тип** Java, использующий формат **signed two’s complement**.

|Характеристика|Значение|
|---|---|
|Размер|64 бита|
|Диапазон|−2⁶³ … 2⁶³−1|
|Формат|signed two’s complement|
|Значение по умолчанию|0L|

Диапазон:

```java
Long.MIN_VALUE = -9_223_372_036_854_775_808
Long.MAX_VALUE =  9_223_372_036_854_775_807
```

`long` используется, когда диапазона `int` недостаточно — для времени, ID, больших счётчиков, потоков данных, финансовых API и т.д.

---

## **4.2.5.2 Основные сценарии использования long**

### **1. Работа со временем**

- миллисекунды (`System.currentTimeMillis()`)
    
- наносекунды (`System.nanoTime()`)
    
- timestamp UNIX 64-bit
    

```java
long now = System.currentTimeMillis();
```

### **2. ID и большие счетчики**

`long` — стандарт для больших систем, баз данных, распределённых идентификаторов.

### **3. Количество данных > 2^31**

- обработка больших файлов
    
- размер потоков
    
- позиционирование в NIO (`FileChannel.position()` → long)
    

### **4. Операции с большими диапазонами**

Хеширование, генераторы случайных чисел, битовые маски на 64 бита.

---

## **4.2.5.3 Арифметика и переполнение**

Как и `int`, тип `long` **не защищён от переполнения**.

### Поведение overflow:

```java
long x = Long.MAX_VALUE;
long y = x + 1;

System.out.println(y); // -9223372036854775808
```

Переполнение происходит по модулю **2⁶³**.

### Безопасные операции:

```java
Math.addExact(a, b);
Math.subtractExact(a, b);
Math.multiplyExact(a, b);
```

### Пример ошибки:

```java
long count = 9_000_000_000_000_000_000L;
count++; // silent overflow при достижении Long.MAX_VALUE
```

---

## **4.2.5.4 Работа с “большими значениями” и unsigned API**

Java не имеет unsigned long, но предоставляет логику для интерпретации значений как **unsigned 64-bit**.

### Операции Java 8+:

```java
Long.divideUnsigned(a, b);
Long.remainderUnsigned(a, b);
Long.compareUnsigned(a, b);
```

### Конвертация в BigInteger:

```java
BigInteger big = BigInteger.valueOf(value);
```

**Для криптографии, шифрования, хешей SHA, UUID и бинарных протоколов — всегда используйте long/BigInteger.**

---

## **4.2.5.5 Best Practices**

### ✔ Использовать `long` для всех временных значений

Millisecond/nanosecond timestamps → **только long**.

### ✔ Избегать приведения int → long без явной необходимости

Может скрыть переполнение int.

### ✔ Использовать `long` для больших файлов и потоков

```java
long size = file.length();
```

### ✔ Контролировать переполнение через Exact-методы

Особенно в финансовых и аналитических задачах.

### ✔ Использовать 64-битные битовые маски для флагов

```java
long flags = 1L << 42;
```

---

## **4.2.5.6 Anti-patterns**

|Антипаттерн|Пояснение|Последствия|
|---|---|---|
|`long` для timestamp без проверки overflow|переполнение через ~292 млн лет|некорректная логика времени|
|неправильно сравнивать `Long` через `==`|кэширование значений не работает для long|ошибки сравнения|
|использование `long` в циклах без необходимости|медленнее int на большинстве JVM|потери скорости|
|использование long для array indices|массивы → int, приведёт к касту|потеря смысла и безопасности|
|попытка хранить unsigned 64-bit значения напрямую|нет unsigned long в Java|неправильные операции|

---

## **4.2.5.7 Примеры**

### **Счётчики большого диапазона**

```java
for (long i = 0; i < 10_000_000_000L; i++) { ... }
```

### **Наносекундное измерение**

```java
long start = System.nanoTime();
...
long elapsed = System.nanoTime() - start;
```

### **Работа с большими файлами**

```java
long pos = channel.position();
long size = channel.size();
```

### **Безопасная арифметика**

```java
long safe = Math.addExact(a, b);
```

### **64-битная битовая маска**

```java
long mask = 1L << 63;
```

---

# **4.2.5.8 Advanced Topics**

---

## **A. Взаимодействие long с 64-битной архитектурой**

Хотя тип `long` совпадает по размеру с регистром x86_64:

- большинство операций со значениями long требуют **двух 32-битных ALU-инструкций**,
    
- JIT оптимизирует это, но `long` всё равно работает чуть медленнее, чем `int`.
    

---

## **B. Escape Analysis и scalar replacement**

Объекты класса, полностью состоящие из `long`:

```java
class PointL { long x, y; }
```

часто оптимизируются JVM:

- JIT может устранить создание объекта,
    
- заменить поля на два регистра,
    
- выполнить весь метод без аллокаций.
    

---

## **C. Взаимодействие long ↔ double**

Важно для научных расчётов:

```java
long x = 9_223_372_036_854_775_000L;
double d = x;
System.out.println(d == x); // false — потеря точности
```

double имеет лишь ~53 бита точности.

---

## **D. Неатомарность long на некоторых архитектурах**

На старых 32-битных JVM (до Java 8):

- чтение/запись long **не были атомарны**,
    
- требовались volatile/AtomicLong.
    

На современных HotSpot JVM все операции чтения/записи long → атомарны.

Но `long++` остаётся **неатомарным**:

```java
counter++; // не атомарно
```

Правильно:

```java
AtomicLong counter = new AtomicLong();
counter.incrementAndGet();
```

---

## **E. Unsigned 64-bit и сериализация**

Для бинарных протоколов (TCP, UDP, file formats) Java имитирует unsigned long:

- сравнение, деление, остаток — через unsigned API,
    
- преобразование в BigInteger.
    

---

# **4.2.5.9 Выводы**

Тип `long`:

- представлен 64-битным signed two’s complement,
    
- предназначен для больших диапазонов, где int недостаточен,
    
- используется для времени, ID, больших данных и битовых операций,
    
- требует контроля переполнения,
    
- имеет продвинутые unsigned-наборы операций,
    
- взаимодействует с JIT и архитектурой CPU иначе, чем int,
    
- требует аккуратности в многопоточности и при работе с double.
    

`long` — ключевой тип Java для больших чисел, больших данных и системного программирования.
