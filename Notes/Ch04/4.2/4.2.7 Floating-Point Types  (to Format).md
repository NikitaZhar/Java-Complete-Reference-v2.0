2025-11-25 14:46
Tags: #FloatingPointTypes #toFormat 

Floating-point типы Java (`float` и `double`) реализуют **IEEE 754 (binary32/binary64)**.  
Они представляют **аппроксимации действительных чисел**, подчиняются строгой математической модели и обладают значительным числом особенностей, необходимых для правильного промышленного использования.

---

## **4.2.7.1 Официальное определение (JLS)**

Floating-point типы Java:

- **`float`** — 32-битный формат IEEE 754 _binary32_.
    
- **`double`** — 64-битный формат IEEE 754 _binary64_.
    

Свойства:

- конечное дискретное множество значений;
    
- поддержка **NaN**, **Infinity**, **signed zero**, **subnormal values**;
    
- арифметика подчиняется IEEE 754;
    
- режим округления — **round-to-nearest, ties-to-even**.
    

---

## **4.2.7.2 Формат IEEE 754: общая структура**

### **4.2.7.2.1 Нормализованная форма**

```
value = (-1)^sign × 2^(exponent - bias) × (1.fraction)
```

### **4.2.7.2.2 Subnormal форма**

```
value = (-1)^sign × 2^(1 - bias) × (0.fraction)
```

Subnormal позволяет избежать «прыжка» между минимальным нормализованным числом и нулём.

---

## **4.2.7.3 Специальные значения IEEE 754**

### **4.2.7.3.1 Infinity**

```java
double x = 1e308 * 1e308; // Infinity
```

### **4.2.7.3.2 NaN**

```java
double n = 0.0 / 0.0; // NaN
```

Семантика:

- `NaN != NaN`
    
- любое сравнение с NaN → false
    
- проверка: `Double.isNaN(n)`
    

### **4.2.7.3.3 Subnormal**

- возникают при underflow;
    
- имеют низкую точность;
    
- могут вычисляться медленно.
    

---

## **4.2.7.4 Signed Zero**

Java различает:

```
+0.0
-0.0
```

Они равны (`==`), но ведут себя по-разному:

```java
1.0 / +0.0 → +Infinity
1.0 / -0.0 → -Infinity
```

---

## **4.2.7.5 Округление и ULP**

### **4.2.7.5.1 Rounding**

Режим: **round-to-nearest-even**.

### **4.2.7.5.2 ULP**

ULP — разница между соседними представимыми значениями.

```java
double u = Math.ulp(1.0); // 2^-52
```

---

## **4.2.7.6 Catastrophic Cancellation**

```java
double a = 1e16;
double b = a + 1;
double diff = b - a; // 0 — потеря младших битов
```

---

## **4.2.7.7 Семантика сравнений**

### **4.2.7.7.1 NaN**

```java
Double.NaN == Double.NaN; // false
```

### **4.2.7.7.2 Двоичные дроби**

```java
0.1 + 0.2 == 0.3 // false
```

---

## **4.2.7.8 Корректные примеры**

```java
Math.sqrt(-1);                      // NaN
1.0 / 0.0;                          // Infinity
0.0 * Double.POSITIVE_INFINITY;     // NaN
```

---

## **4.2.7.9 Ошибочные примеры**

```java
if (x == Double.NaN) {} // всегда false
```

---

## **4.2.7.10 Практические рекомендации**

- Не сравнивать float/double по `==`.
    
- Использовать epsilon:
    

```java
Math.abs(a - b) < 1e-9
```

- Избегать вычитания близких чисел.
    
- Для финансов использовать `BigDecimal`.
    
- Проверять NaN/Infinity явно.
    
- Следить за overflow/underflow.
    

---

## **4.2.7.11 Subnormal, FTZ, DAZ**

Subnormal:

- уменьшают точность;
    
- медленны на многих CPU;
    
- FTZ/DAZ режимы превращают их в ноль.
    

JIT может учитывать аппаратные особенности процессора.

---

## **4.2.7.12 Накопление ошибок**

Промежуточные операции округляются:

```java
float r = a * b * c * d; // каждое действие -> отдельное округление
```

---

## **4.2.7.13 strictfp**

Гарантирует строгое следование IEEE 754 и запрет расширенной точности FPU.

Используется в:

- криптографии,
    
- научных вычислениях,
    
- переносимых тестах.
    

---

## **4.2.7.14 Неассоциативность и Reassociation (JIT)**

JIT может менять порядок вычислений, что допустимо без `strictfp`:

```
(a + b) + c → a + (b + c)
```

### **Пример:**

```java
double a = 1e16, b = -1e16, c = 1;

double r1 = (a + b) + c; // 1
double r2 = a + (b + c); // 0
```

---

## **4.2.7.15 FMA (Fused Multiply-Add)**

```java
double r = Math.fma(a, b, c);
```

Делает `a*b + c` одной операцией → меньше ошибок округления.

---

## **4.2.7.16 Отсутствие исключений**

IEEE 754 _не генерирует исключений_:

- деление на ноль → Infinity
    
- sqrt(-1) → NaN
    
- overflow → Infinity
    
- underflow → subnormal или 0
    

---

## **4.2.7.17 equals(), compareTo(), hashCode()**

- `-0.0 == +0.0` → true
    
- `Double.compare(-0.0, +0.0)` → < 0
    
- все NaN имеют одинаковый hashCode
    
- но **raw-биты** разных NaN могут отличаться
    

---

## **4.2.7.18 Comparator/Comparable**

Правила:

- NaN считается _больше_ всех чисел
    
- -0.0 < +0.0
    
- используется в TreeSet, TreeMap, Arrays.sort()
    

---

## **4.2.7.19 Math vs StrictMath**

- **Math** — максимально быстрая реализация (может использовать аппаратные оптимизации).
    
- **StrictMath** — полностью переносимая, гарантированная в соответствии с FDlibm.
    

---

## **4.2.7.20 Ошибки decimal ↔ binary ↔ decimal**

Большинство десятичных дробей невозможно представить точно:

```java
System.out.println(0.1f); // 0.10000001
```

JVM 9+ использует Grisu3/Dragon4 для корректного форматирования double.

---

## **4.2.7.21 Детерминизм floating-point вычислений в JVM**

Результаты могут различаться:

- между CPU (Intel/AMD/ARM),
    
- между версиями HotSpot,
    
- между HotSpot и GraalVM,
    
- при включении FMA,
    
- при reassociation-оптимизациях.
    

Для детерминированного поведения:

- применять `strictfp`;
    
- фиксировать порядок операций;
    
- избегать JIT-зависимых оптимизаций;
    
- отключать FMA при необходимости точного соответствия.
    

---

## **4.2.7.22 Canonical NaN и raw NaN payload**

IEEE 754 допускает множество NaN с разными payload.

Java:

- `floatToIntBits()` и `doubleToLongBits()` → **нормализуют NaN к canonical форме**
    
- `floatToRawIntBits()` и `doubleToRawLongBits()` → сохраняют payload
    

### Пример:

```java
float n1 = Float.intBitsToFloat(0x7FC00001); // quiet NaN
float n2 = Float.intBitsToFloat(0x7FFFFFFF); // другой NaN

Float.floatToIntBits(n1) == Float.floatToIntBits(n2); // true (canonical)
Float.floatToRawIntBits(n1) == Float.floatToRawIntBits(n2); // false
```

Это важно для:

- сериализации,
    
- бинарных протоколов,
    
- бит-точной репликации вычислений.
    
