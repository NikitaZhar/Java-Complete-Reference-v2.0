2025-09-15 13:05
Tags: #CompilationUnit #Shebang
- Порядок элементов (`package` → `import` → `type declarations`)
- Только один `package` на файл
- Только один `public` класс/интерфейс/enum/record на файл

`Compilation Unit` — это минимальная единица кода, которую принимает компилятор Java (`javac`). Каждый файл `.java` соответствует одному `compilation unit`.
## Структура Compilation Unit
Согласно спецификации (`JLS §7.3`), структура файла определяется следующим образом:

CompilationUnit:
```java
{Annotation} [PackageDeclaration] {ImportDeclaration} {TypeDeclaration} 
```
### Основные элементы
1. **Package declaration** _(необязательный)_
```java
package com.example.myapp;
```
- Должен быть первым элементом в файле (после комментариев и `whitespace`).
- Определяет, в каком пакете будет находиться объявленный тип.
- Допускается _только одно объявление пакета на файл_.
- При отсутствии — используется `unnamed package` (не рекомендуется для крупных проектов).
2. **Import declarations** _(необязательные, может быть несколько)_
```java
import java.util.List;
import static java.lang.Math.PI;
```
Разрешают ссылаться на типы и члены без указания полного имени.

3. **Type declarations** _(основная часть файла)_

В файл можно поместить одно или несколько объявлений:
- `class`
- `interface`
- `enum`
- `record`
- `annotation type`

Кроме классов, интерфейсов, перечислений и `record`-типов, компиляционная единица может содержать и `annotation type` (объявление аннотации):
```java
public @interface Marker {}
```
Аннотация — это особый вид интерфейса, используемый для хранения метаданных.
### Правила
- Может быть только один `public` тип.
- Имя `public` типа должно совпадать с именем файла.
- Если нет `public` типов, имя файла может быть любым.
- Все остальные типы будут иметь **package-private доступ**.
- Допускается несколько `top-level` типов в одном файле (если они не `public`).
Допускается модификатор `strictfp` для верхнеуровневых классов и интерфейсов. Он заставляет все вычисления с плавающей точкой внутри данного типа соответствовать строгим правилам `IEEE 754`, независимо от платформы:
```java
public strictfp class Calculator { ... }
```
Использование `strictfp` обеспечивает одинаковые результаты вычислений на разных архитектурах.

4. **Module declaration (Java 9+)** _(альтернатива)_

Если файл называется `module-info.java`, он содержит объявление модуля:
```java
module com.example.myapp {
	requires java.sql;
	exports com.example.myapp.api;
}
```
Такой файл не может содержать обычные объявления классов.
Компиляционная единица может содержать либо объявление `module`, либо стандартные `package`, `import` и объявления типов. Одновременное использование обоих вариантов в одном исходном файле не допускается.

5. **Empty compilation unit**
- Файл `.java` может содержать только комментарии и пробелы.
- Такой файл считается корректной `compilation unit`.
- Используется как заглушка или для тестирования.

### Compilation Unit Annotations
Компиляционная единица может быть аннотирована на верхнем уровне.  
Такие аннотации располагаются перед объявлением `package` или `module` и применяются ко всему исходному файлу.

Пример
```java
@SuppressWarnings("all")
package com.example.legacy;
```
Особенности
- Аннотации действуют на весь файл, а не на отдельные типы.
- Допустимы только перед `package` или `module`.
- Распространяются на все элементы файла, если их область применения (`@Target`) это допускает.
### Дополнительные замечания
- Аннотации компиляционной единицы разрешены только в начале файла, перед `package` или `module` объявлением. Перед ними могут находиться только комментарии и пробельные символы.  
- Если в файле отсутствует `package` и `module`, аннотации всё равно можно разместить, и они будут применяться к `compilation unit` целиком.  
- Наиболее часто используемые аннотации в этой позиции — `@SuppressWarnings` (для подавления диагностик) и `@Deprecated` (пометка файла устаревшим).  
- В `JLS (§7.3)` прямо указано, что такие аннотации действуют на весь исходный файл, но фактический эффект зависит от `@Target` конкретной аннотации: не все аннотации допустимы на уровне `compilation unit`.

**Важно**. В соответствии с `JLS (§7.3)`, на уровне `compilation unit` разрешены только те аннотации, которые имеют `@Target(PACKAGE)` или `@Target(MODULE)`. Аннотации без этих целей не могут применяться ко всему исходному файлу.
## Особенности и ограничения
- **Кодировка и Unicode:**
    - Компилятор ожидает `Unicode`-совместимую кодировку (`UTF-8`).
    - Символы `\uXXXX` интерпретируются до разбиения на токены.
    - Поэтому запись `// \u000A` создаст фактический перевод строки внутри комментария.
- **Line terminators:**
    - Допустимы LF (`\n`), CRLF (`\r\n`), CR (`\r`).
    - Все варианты считаются одинаковыми для компилятора.
- **Public class rule:**
    - Если нарушить правило совпадения имени файла и `public` типа, компилятор выдаст ошибку.

Например
```java
// Файл MyClass.java
public class AnotherClass {} // Ошибка
```
### Примеры ошибок
```java
// Файл MyClass.java
public class AnotherClass {} // Ошибка: имя файла не совпадает с именем public-класса

// Файл Bad.java
public class First {}
public class Second {} // Ошибка: более одного public-класса в файле
```
### Forward declarations не требуются:
- В Java порядок объявлений верхнего уровня не имеет значения.
- Все типы доступны независимо от их положения в файле.
### Пустой `compilation unit`
- `.java` может содержать только комментарии и `whitespace`.
- Это допустимо и корректно компилируется.
## Пример полного `compilation unit`
```java
// Файл: MyProgram.java
package com.acme.tools;

import java.util.List;
import static java.lang.Math.PI;

public class MyProgram {
    public static void main(String[] args) {
        List<String> list = List.of("A", "B", "C");
        System.out.println("Items: " + list);
        System.out.println("PI = " + PI);
    }
}

class Helper {}        // package-private
record Data(int id) {} // record (Java 16+)
```

