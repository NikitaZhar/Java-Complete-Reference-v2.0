2025-10-27 13:47
Tags: #toFormat

Подтипирование определяет, когда значение одного типа может безопасно использоваться в контексте другого типа без нарушения типобезопасности.

---

## **4.1.6.1 Основное понятие**

**Подтип** — это тип, значения которого могут использоваться в любом контексте, где ожидается значение другого типа (надтипа), **без нарушения типобезопасности**.

Если `B` — подтип `A`, то справедливо:

```
B <: A    (B is a subtype of A)
A :> B    (A is a supertype of B)
```

> Принцип: **всякий объект подтипа может рассматриваться как объект надтипа**,  
> даже если его конкретная реализация отличается.

---

## **4.1.6.2 Роль подтипирования**

Подтипирование лежит в основе:

- наследования классов;
    
- реализации интерфейсов;
    
- полиморфизма;
    
- совместимости при присваивании;
    
- передачи аргументов и возврата результатов методов.
    

---

## **4.1.6.2a Номинальное подтипирование**

Java использует **номинальную систему типов** (_nominal type system_).  
Отношение подтипирования определяется **именем типа** и явными декларациями `extends` / `implements`.

- Совместимость не выводится из структуры типов (в отличие от структурной типизации).
    
- Два класса с одинаковыми полями и методами не считаются совместимыми без наследования или реализации интерфейса.
    

```java
class Point { int x, y; }
class Pixel { int x, y; } // не является подтипом Point
```

---

## **4.1.6.3 Формальные источники подтипов**

### 1. Наследование классов

Если класс `B` объявлен как `extends A`, то `B <: A`.

```java
class A {}
class B extends A {} // B <: A
```

### 2. Реализация интерфейсов

Если класс или интерфейс объявлен как `implements I`, он является подтипом `I`.

```java
interface I {}
class C implements I {} // C <: I
```

### 3. Массивы (ковариантность)

Массивы в Java ковариантны:

```
Если T <: S, то T[] <: S[]
```

Однако это может привести к ошибкам в runtime (см. [[4.3.3 Array Types]]).

```java
String[] arr = new String[1];
Object[] objArr = arr; // допустимо: String[] <: Object[]
```

### 4. Специальные типы

- `Object` — надтип всех ссылочных типов;
    
- `null` (Null Type) — подтип всех ссылочных типов (см. [[4.3.1 Null Type]]).
    

---

## **4.1.6.4 Пример корректного подтипирования**

```java
Number n = Integer.valueOf(5); // Integer <: Number  
Object o = n;                  // Number <: Object
```

---

## **4.1.6.5 Присваивание и контекст совместимости**

Если `B <: A`, то значение `B` может быть присвоено переменной `A`.

```java
A a = new B(); // полиморфное присваивание
```

---

## **4.1.6.6 Полиморфизм (runtime dispatch)**

Подтип может переопределять методы надтипа.  
При вызове методов определяется фактический (runtime) тип объекта.

```java
class A { void m() { System.out.println("A"); } }
class B extends A { void m() { System.out.println("B"); } }

A obj = new B();
obj.m(); // "B"
```

---

## **4.1.6.7 Приведение типов и подтипирование**

Если объект имеет подтип `B`, его можно присвоить надтипу `A` без приведения:

```java
B b = new B();
A a = b; // неявное приведение
```

Обратное приведение требует проверки во время выполнения:

```java
A a = new B();
B b = (B) a; // допустимо
```

Если фактический тип не соответствует приведению:

```java
A a = new A();
B b = (B) a; // ClassCastException
```

---

## **4.1.6.8 Подтипирование и тип `Object`**

- `Object` — корень иерархии ссылочных типов;
    
- все классы и массивы являются подтипами `Object`;
    
- примитивные типы не являются подтипами `Object`.
    

```java
Object o1 = "text";     // String <: Object  
Object o2 = new int[5]; // int[] <: Object
```

> **Примечание о value-типах (Project Valhalla):**  
> В новой категории _value classes_ объекты могут не наследовать `Object` непосредственно,  
> но иметь совместимый интерфейсный вид (_interface view_),  
> обеспечивающий подтипирование на уровне байткода без дополнительных объектных обёрток.

---

## **4.1.6.9 Особый случай: тип `null`**

- Значение `null` совместимо с любой ссылочной переменной;
    
- Считается подтипом всех ссылочных типов.
    

```java
String s = null;
Object o = null;
Runnable r = null;
```

Подробнее — [[4.3.1 Null Type]].

---

## **4.1.6.10 Подтипирование и безопасность типов**

Подтипирование служит фундаментом типобезопасности:

- гарантирует, что поведение объекта соответствует контракту надтипа;
    
- предотвращает нарушение модели памяти.
    

Нарушения возможны только при использовании небезопасных механизмов (`raw types`, рефлексия и т.п.),  
что приводит к ошибкам в runtime.

---

## **4.1.6.10a Подтипирование и обобщённые типы**

Для обобщённых типов (`generics`) Java применяет **инвариантное** подтипирование:  
`List<String>` и `List<Object>` не состоят в отношении подтипа, несмотря на `String <: Object`.

```java
List<String> ls = new ArrayList<>();
// List<Object> lo = ls; // ошибка компиляции
```

Это гарантирует типобезопасность при изменяемых контейнерах.  
Для гибкости используются **wildcards**:

- `? extends T` — ковариантное использование (чтение);
    
- `? super T` — контравариантное использование (запись).
    

Подробнее: [[4.5.4 Wildcards and Variance]].

---

## **4.1.6.11 Вывод**

- Подтипирование определяет совместимость типов и возможность подстановки.
    
- Java использует **номинальную** систему типов — совместимость основана на декларациях, а не на структуре.
    
- Подтипирование является фундаментом наследования, интерфейсов, полиморфизма и generics.
    

> **Формула:**  
> Если `B <: A`, то любое значение `B` может быть использовано там, где ожидается `A`,  
> но не наоборот — без явного приведения.

---

## **Cross-References**

- **[[4.1.5 Static vs Runtime Type]]** — влияние подтипирования на полиморфизм.
    
- **[[4.3.1 Null Type]]** — `null` как подтип всех ссылочных типов.
    
- **[[4.3.3 Array Types]]** — ковариантность массивов.
    
- **[[4.5.0 Generics — Overview]]** — инвариантность обобщённых типов.
    
- **[[4.9 ClassLoader and Type Identity]]** — идентичность типов на уровне JVM.
    

---

Хочешь, чтобы я в таком же структурном и академическом формате подготовил следующий раздел **4.1.7 JVM Memory Model — Модель памяти JVM** (с описанием размещения примитивов и объектов, heap vs stack, final fields и happens-before)?