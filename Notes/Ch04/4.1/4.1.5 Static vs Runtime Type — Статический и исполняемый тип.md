2025-10-27 13:45
Tags: #toFormat

## 4.1.5.0 Введение

После рассмотрения различий между _типом_ и _значением_, данный раздел описывает, как система типов Java разделяет представление типа на два уровня — **статический** (compile-time) и **исполняемый** (runtime), определяющих поведение программы на разных этапах её жизни.

---

## 4.1.5.1 Основное различие

В Java каждый объект или выражение имеет **два уровня типизации**:

|Вид типа|Когда определяется|Кем используется|Роль|
|---|---|---|---|
|**Статический тип (compile-time type)**|На этапе компиляции|Компилятором|Определяет корректность кода и допустимость операций|
|**Исполняемый тип (runtime type)**|Во время выполнения программы|JVM|Определяет фактическое поведение и реализацию методов|

> Статический тип — это _обещание_, данное компилятору.  
> Исполняемый тип — это _фактическая природа объекта_ во время выполнения.

---

## 4.1.5.2 Статический тип (compile-time type)

- Является частью исходного кода.
    
- Определяется объявлением переменной, параметра метода или выражения.
    
- Используется компилятором для:
    
    - проверки наличия методов и полей,
        
    - выбора перегруженного метода,
        
    - контроля совместимости типов.
        

```java
Number n = Integer.valueOf(5);
// Статический тип переменной n: Number
```

Компилятор рассматривает `n` как переменную типа `Number`, разрешая вызов только тех методов, которые определены в этом типе.

---

## 4.1.5.3 Исполняемый тип (runtime type)

- Это реальный тип объекта в памяти JVM.
    
- Может быть подтипом статического типа (полиморфизм).
    
- Определяет, какой метод будет вызван при динамической диспетчеризации.
    

```java
Number n = Integer.valueOf(5);
System.out.println(n.getClass()); // Выведет: class java.lang.Integer
```

Хотя переменная объявлена как `Number`, фактический объект имеет тип `Integer`.

---

## 4.1.5.4 Полиморфизм: взаимодействие типов

```java
Number x = Double.valueOf(3.14);
System.out.println(x); // будет вызван метод toString() класса Double
```

- **Статический тип:** `Number`
    
- **Исполняемый тип:** `Double`
    

Метод `toString()` вызывается из `Double`, поскольку JVM использует _runtime-type_ для динамической диспетчеризации.

---

## 4.1.5.5 Приведение типов (casting)

Статический тип определяет, _можно ли записать приведение_,  
а исполняемый тип — _можно ли его выполнить_.

```java
// ClassCastException: статически допустимо, но фактический тип — Double
Number n = Double.valueOf(3.14);
Integer i = (Integer) n; // ClassCastException
```

```java
// ArrayStoreException: ковариантность массивов + проверка компонентного типа в runtime
Object[] arr = new String[1];
arr[0] = 42; // ArrayStoreException
```

Корректность приведения на уровне компиляции не гарантирует его успешность во время выполнения.  
Для массивов компонентный тип проверяется JVM в runtime (см. [[4.3.3 Array Types]]).

---

## 4.1.5.5a Run-Time Type Information (RTTI)

JVM хранит сведения о фактическом типе каждого объекта. Эта информация используется при операциях:

```java
if (obj instanceof String s) {     // pattern matching
    System.out.println(s.toUpperCase());
}

Class<?> c = obj.getClass();       // получение runtime-типа
String casted = String.class.cast(obj); // безопасное приведение
```

RTTI ( Run-Time Type Information ) обеспечивает проверку типов в runtime и служит основой для рефлексии и pattern matching (см. JEP 394).

---

## 4.1.5.6 Примитивные типы: совпадение compile-time и runtime типов

Для примитивных значений различия между статическим и исполняемым типом не существует:

```java
int x = 10;
// Статический тип: int
// Исполняемый тип: также int (примитивы не имеют подтипов)
```

> **Примечание о value-типах (Project Valhalla).**  
> В будущих версиях JVM появится категория _value objects_ — объекты без идентичности.  
> Для них статический и runtime-типы совпадают, но представление в памяти может быть плоским (inline), без ссылки.  
> Это создаёт промежуточную форму между примитивами и ссылочными объектами.

---

## 4.1.5.7 Влияние на generics и type erasure

Параметры типов generics существуют **только на этапе компиляции**:

```java
List<String> list = new ArrayList<>();
System.out.println(list.getClass()); // class java.util.ArrayList
```

- **Статический тип:** `List<String>`
    
- **Исполняемый тип:** `ArrayList` (без информации о типе элементов)
    

Это поведение обусловлено механизмом стирания типов (см. [[4.5.8 Type Erasure and Bridge Methods]]).

---

## 4.1.5.8 Случаи совпадения и различия

|Ситуация|Статический тип|Runtime тип|Комментарий|
|---|---|---|---|
|Примитив|`int`|`int`|Совпадает|
|Объект|`Number n`|`Integer`|Различается|
|Массив|`Object[] arr = new String[1]`|`String[]`|Различается, возможна ошибка runtime|
|Обобщение (generics)|`List<String>`|`ArrayList`|Тип параметра стирается|

---

## 4.1.5.9 Вывод

- Статический тип обеспечивает **типобезопасность и проверку корректности кода**.
    
- Исполняемый тип определяет **фактическую реализацию поведения** и поддерживает **полиморфизм**.
    
- Понимание различия между ними необходимо для корректной работы с наследованием, generics, приведениями типов и исключениями времени выполнения.
    

> **Формула:**  
> Статический тип определяет _что разрешено_,  
> runtime-тип определяет _что действительно происходит_.

---

## Cross-References

- **[[4.1.4 Type vs Value]]** — понятия типа и значения.
    
- **[[4.1.6 Subtypes and Supertypes]]** — отношения подтипирования.
    
- **[[4.3.3 Array Types]]** — ковариантность массивов.
    
- **[[4.5.8 Type Erasure and Bridge Methods]]** — стирание типов и потеря информации о generics.
    
- **[[4.9 ClassLoader and Type Identity]]** — определение идентичности типа на уровне JVM.
    

---

Хочешь, чтобы я подготовил в таком же формате следующий раздел **4.1.6 Subtypes and Supertypes** — с формальными определениями, примерами ковариантности, инвариантности и полиморфизма, как в JLS § 4.10?