2025-10-29 19:22
Tags: #

`Jackson` — это модульная экосистема для работы с `JSON` (и не только `JSON`) в Java. На момент Java SE 25 `Jackson` является _де-факто стандартом_ промышленного сериализатора/десериализатора, используемого в `Spring Boot`, `Micronaut`, `Quarkus`, `Apache Kafka`, `Elasticsearch`, `Logstash`, `Hadoop` и тысячах систем.

## Цель раздела
Понять внутреннюю структуру `Jackson`, разграничить уровни API, осознать, как архитектура влияет на работу `ObjectMapper`, и почему `Jackson` одновременно:

- чрезвычайно быстрый (`streaming API`)
- гибкий (`tree model`)
- удобный и безопасный (`data binding`)

## 58.3.1.1 Общая архитектура
`Jackson` состоит из трёх отдельных уровней:

| Уровень              | Модуль                              | Назначение                                                                       | Уровень абстракции                  |
| -------------------- | ----------------------------------- | -------------------------------------------------------------------------------- | ----------------------------------- |
| Core / Streaming API | `jackson-core`                      | Низкоуровневая работа с `JSON` как с потоком данных: токены, парсинг по символам | Минимальный, высокопроизводительный |
| Tree Model           | `jackson-databind` (`JsonNode`)     | Представление JSON как изменяемого дерева узлов                                  | Средний                             |
| Data Binding         | `jackson-databind` (`ObjectMapper`) | Полная автоматическая сериализация Java ↔ JSON                                   | Высокий, пользовательский           |

## 58.3.1.2 Streaming API (Core)
Это фундамент `Jackson`. Потоковый парсер читает `JSON` посимвольно и выдает токены:
- `JsonToken.START_OBJECT` (`{`)
- `JsonToken.FIELD_NAME` (`"name"`)
- `JsonToken.VALUE_STRING` (`"John"`)

### Преимущества:
- Низкое потребление памяти
- Высокая скорость
- Возможность работать с `JSON`, который не помещается в память

### Недостатки:
- Ручное управление структурой
- Высокая вероятность логических ошибок

### Пример
```java
JsonFactory factory = new JsonFactory();
try (JsonParser parser = factory.createParser(jsonString)) {
    JsonToken t;
    while ((t = parser.nextToken()) != null) {
        if (t == JsonToken.FIELD_NAME && "name".equals(parser.getCurrentName())) {
            parser.nextToken();
            System.out.println("Name: " + parser.getText());
        }
    }
}
```

Код использует `Jackson JSON Parser` для потокового чтения `JSON`. `JSON` обрабатывается как поток токенов — без создания объекта в памяти. Вот как он работает:

1. Создание парсера
`JsonFactory` создаёт `JsonParser`, который читает `JSON` строку токен за токеном (не загружая всё в память сразу).

2. Цикл обработки токенов
`while ((t = parser.nextToken()) != null)` — перебирает все токены в `JSON` (ключи, значения, скобки и т.д.) до конца документа.

3. Поиск нужного поля
Когда встречается токен `FIELD_NAME` (имя поля) со значением `"name"`, код:
- Вызывает `parser.nextToken()` чтобы перейти к значению этого поля
- Извлекает текст значения через `parser.getText()`
- Выводит его в консоль

Для JSON `{"id": 1, "name": "John", "age": 30}` код найдёт поле "name" и выведет:
```java
Name: John
```
Этот подход эффективен для больших `JSON`-файлов, так как не требует загрузки всей структуры в память.

## 58.3.1.3 Tree Model (JsonNode)
`Tree Model` представляет `JSON` как изменяемую структуру наподобие `DOM`. Используется, если:
- структура `JSON` неизвестна заранее
- нужно динамически изменять `JSON`
- нужно извлечь только часть данных

### Пример
```java
ObjectMapper mapper = new ObjectMapper();
JsonNode root = mapper.readTree(jsonString);
String name = root.get("user").get("name").asText();
((ObjectNode) root.get("user")).put("active", true);
```

### Как это работает
1. Создание `ObjectMapper`:
```java
ObjectMapper mapper = new ObjectMapper();
```

Создается экземпляр `ObjectMapper` из библиотеки `Jackson`, который используется для работы с `JSON`.

2. Парсинг JSON-строки:
```java
JsonNode root = mapper.readTree(jsonString);
```

Метод `readTree()` парсит `JSON`-строку и возвращает древовидную структуру `JsonNode`, которая представляет весь `JSON`-документ.

3. Извлечение значения:
```java
String name = root.get("user").get("name").asText();
```

Навигация по дереву `JSON`: получаем объект `"user"`, затем из него извлекаем поле `"name"` и конвертируем его в строку с помощью `asText()`.

4. Модификация JSON:
```java
((ObjectNode) root.get("user")).put("active", true);
```

Приводим узел `"user"` к типу `ObjectNode` (мутабельный тип), чтобы добавить новое поле `"active"` со значением `true`.

### Результат
Предположим, исходный `JSON` выглядел так:
```json
{
  "user": {
    "name": "Nikita",
    "age": 25
  }
}
```

После выполнения кода:
- Переменная `name` будет содержать строку `"Nikita"`
- JSON-структура `root` будет изменена и теперь содержит новое поле:

```json
{
  "user": {
    "name": "Nikita",
    "age": 25,
    "active": true
  }
}
```

Таким образом, код демонстрирует как чтение данных из `JSON`, так и его модификацию на лету.

**Преимущество**: гибкость.
**Недостаток**: дерево занимает память, поэтому не подходит для больших файлов.

## 58.3.1.4 Data Binding (ObjectMapper)
`Data Binding` — это наиболее используемый слой `Jackson`. Он автоматически сопоставляет данные `JSON` с Java-классами `(POJO)` и обратно.

```java
ObjectMapper mapper = new ObjectMapper();
User user = mapper.readValue(jsonString, User.class);
String jsonOut = mapper.writeValueAsString(user);
```

Этот код демонстрирует работу с библиотекой Jackson для сериализации и десериализации JSON в Java.

### Создание ObjectMapper
```java
ObjectMapper mapper = new ObjectMapper();
```
Создается экземпляр `ObjectMapper` — основного класса Jackson для работы с JSON.

### Десериализация JSON в объект
```java
User user = mapper.readValue(jsonString, User.class);
```
Метод `readValue()` преобразует JSON-строку (`jsonString`) в объект класса `User`. Jackson автоматически сопоставляет поля JSON с полями класса.

### Сериализация объекта в JSON
```java
String jsonOut = mapper.writeValueAsString(user);
```
Метод `writeValueAsString()` преобразует объект `user` обратно в JSON-строку.

### Результат
В результате выполнения кода:

- Переменная `user` содержит объект класса `User` с данными из исходной JSON-строки
- Переменная `jsonOut` содержит JSON-строку, представляющую объект `user`
- Если исходный JSON был корректным, `jsonOut` будет содержать те же данные (возможно, с другим форматированием)

Пример:
```java
// Входной JSON
String jsonString = "{\"name\":\"Иван\",\"age\":30}";

// После выполнения кода
// user.getName() вернет "Иван"
// user.getAge() вернет 30
// jsonOut будет содержать: "{\"name\":\"Иван\",\"age\":30}"
```

_Jackson использует рефлексию, аннотации, кеширование и анализ типов времени выполнения._

## 58.3.1.5 Как взаимодействуют уровни
- `ObjectMapper` внутренне использует Streaming API (через `JsonParser` и `JsonGenerator`).
- Tree Model (`JsonNode`) строится на основе потокового чтения.
- Data Binding использует Tree Model _или_ Streaming API — в зависимости от типа данных.

### Упрощённая диаграмма
```
JSON Input
   ↓
Streaming Parser (jackson-core)
   ↓
Tree Model (JsonNode) ← optional
   ↓
Data Binding (ObjectMapper)
   ↓
Java Object
```

### Что под капотом `ObjectMapper`

`ObjectMapper` держит:

- **кеш сериализаторов/десериализаторов** по типу (ускоряет повторные операции),
    
- **анализ аннотаций и стратегий видимости** (формирует модель свойств),
    
- **ссылку на `JsonFactory`**, из которой создаёт `JsonParser`/`JsonGenerator`,
    
- **реестр модулей** (поддержка доп. типов/форматов, перехватчики).  
    Это объясняет, почему `ObjectMapper` должен быть **singleton**: кэш дорого строить заново.

---

## **58.3.1.6 Выбор подхода**

|API|Когда использовать|Производительность|Сложность|
|---|---|---|---|
|**Streaming**|Большие данные, ограниченная память|Максимальная|Высокая|
|**Tree Model**|Динамическое изменение JSON|Средняя|Средняя|
|**Data Binding**|Классические DTO, REST API|Высокая|Низкая|

**Типичные домены:**  
Streaming → ETL, лог-агрегация, IoT, импорты «больших» файлов.  
Tree → гибкие адаптеры API, преобразование частично известных схем.  
Data Binding → REST DTO, события, конфигурации.
---

## **58.3.1.7 Типичные ошибки**

### ❌ Ошибка: использовать Data Binding для огромного JSON (500 МБ)

- Приведёт к `OutOfMemoryError`
    

✅ Решение: использовать Streaming API

### ❌ Ошибка: модифицировать JSON через String-операции

- Потеря экранирования, некорректный синтаксис
    

✅ Использовать `ObjectNode` и `JsonNode`

### ❌ Ошибка: сохранять `ObjectMapper` как локальную переменную

- Большая стоимость создания
    
- Потеря кешей
    
- Потеря производительности
    

✅ `ObjectMapper` должен быть `singleton` и потокобезопасен.


- ❌ **Дубликаты ключей**: по умолчанию тихо перезаписываются. Для строгого режима см. 58.3.8 → JsonParser.Feature.STRICT_DUPLICATE_DETECTION` / `FAIL_ON_READING_DUP_TREE_KEY`.

---

## **58.3.1.8 Заключение**

Архитектура Jackson уникальна тем, что:

- Позволяет использовать разные уровни абстракции в зависимости от задачи.
    
- Является расширяемой модульной системой.
    
- Обеспечивает баланс между производительностью, гибкостью и удобством разработки.
    