2025-11-17 11:42
Tags: #JVM

## 3.10.8.1 Константный пул и хранение литералов
Согласно `Java Virtual Machine Specification` (§4.4), все литералы и ссылки на значения сохраняются в `constant pool` `.class`-файла.  
Каждая запись имеет тип (`tag`) и индекс, который используется инструкциями байткода.

|Тип литерала|Константа в Constant Pool|Формат (байт)|Комментарий|
|:--|:--|:--|:--|
|`int`, `float`|`CONSTANT_Integer`, `CONSTANT_Float`|4 байта|один слот|
|`long`, `double`|`CONSTANT_Long`, `CONSTANT_Double`|8 байт|занимает **два слота**|
|`String`|`CONSTANT_String` → `CONSTANT_Utf8`|UTF-8|ссылка на `Utf8` запись|
|`null`|не хранится|используется `aconst_null`||
|`Dynamic`|`CONSTANT_Dynamic`|—|динамическая константа (Java 11+)|
|`MethodHandle` / `InvokeDynamic`|—|—|метод, лямбда, text blocks|

> JVM использует constant pool при загрузке классов, инициализации и разрешении ссылок. Все операции с литералами выполняются через обращения к этому пулу.

### Пример исходного кода
```java
String s = "Hi";
int x = 42;
Object n = null;
```

Байт-код (Javap)
```text
ldc #2        // String "Hi"
bipush 42
aconst_null
```

Constant Pool (.class)
```text
#2  = String  #16     // "Hi"
#3  = Integer 42
#16 = Utf8    "Hi"
```

> В `constant pool` строки всегда представлены через пару `String → Utf8`.

## 3.10.8.2 Инструкции загрузки литералов (§6.5)

|Инструкция|Назначение|Пример|Комментарий|
|:--|:--|:--|:--|
|`ldc`|Загружает значение (`int`, `float`, `String`, `Class`, `MethodHandle`)|`ldc #2`|используется для 4-байтных и ссылочных констант|
|`ldc2_w`|Загружает `long` или `double`|`ldc2_w #3`|для 8-байтных значений|
|`bipush`, `sipush`|Загружает малые int-значения|`bipush 42`|−128…32767|
|`aconst_null`|Кладёт `null` в стек|—|представление `null`|
|`invokedynamic`|Вызывает bootstrap-метод для динамической константы|—|используется для лямбд и `StringConcatFactory`|

## 3.10.8.3 Особенности строковых констант
Строки в `constant pool` хранятся **в двух записях**
```text
#2 = String #16
#16 = Utf8  "Hi"
```
- `CONSTANT_String` содержит ссылку на индекс `Utf8`;
- `Utf8` хранит байты UTF-8;
- при выполнении `ldc` создаётся (или извлекается) объект из String Pool.

> JVM интернирует все строковые литералы, поэтому одинаковые строки в коде ссылаются на один объект `java.lang.String`.

## 3.10.8.4 IEEE 754-литералы (`NaN`, `±Infinity`, `±0.0`)
```java
double a = Double.NaN;
double b = Double.POSITIVE_INFINITY;
float  c = -0.0f;
```
- Хранятся в `CONSTANT_Double` / `CONSTANT_Float` как **битовые значения IEEE 754**.
- JVM не использует отдельные теги — сохраняет “сырые” биты числа.
- При `ldc2_w` или `ldc` загружается то же представление, что при арифметике.

### Пример полной структуры Constant Pool
```text
Constant pool:
 #1 = Methodref  #6.#15     // java/lang/Object."<init>":()V
 #2 = String      #16       // "Hi"
 #3 = Integer     42
 #4 = Double      3.1415
 #5 = Class       #17       // java/lang/String
 #6 = Class       #18       // Example
 #7 = Dynamic     #20:#21   // динамическая константа
 #8 = MethodHandle 6:#22    // lambda/metafactory
 #16 = Utf8       "Hi"
 #17 = Utf8       "java/lang/String"
 #18 = Utf8       "Example"
 #20 = NameAndType #23:#24  // bootstrap descriptor
```

> В Java 11+ появились `CONSTANT_Dynamic` и `CONSTANT_InvokeDynamic`, которые позволяют JVM создавать константы и лямбды во время загрузки класса.

### Пример вывода `javap -v`
```bash
$ javap -v Example.class | grep -A3 "Constant pool"
Constant pool:
   #2 = String             #16            // "Hi"
   #3 = Integer            42
   #16 = Utf8              "Hi"
```

> Команда `javap -v` показывает индексы и типы констант, что позволяет увидеть, какие литералы были сохранены компилятором.

## 3.10.8.5 `null` и инструкция `aconst_null`
`null` не имеет записи в `constant pool`.  
JVM использует специальную инструкцию `aconst_null`, которая помещает `null` на вершину операндного стека:
```text
aconst_null
astore_1   // сохранить в локальной переменной
```

## 3.10.8.6 Связь JLS ↔ JVMS
- _JLS §3.10_ определяет **лексическую форму и синтаксис** литералов в исходном коде.
- _JVMS §4.4_ и _§6.5_ определяют **их внутреннее представление** и **инструкции**, которые загружают эти значения в стек при выполнении.

> Таким образом, JLS описывает, _как_ литерал записывается в исходнике, а JVMS — _как_ он хранится и обрабатывается JVM.

### Мини-схема загрузки литералов

```mermaid
flowchart LR
    A["Исходный код"] --> B["javac (компиляция)"]
    B --> C["Constant Pool (.class)"]
    C --> D["Инструкции: ldc / ldc2_w / bipush / aconst_null / invokedynamic"]
    D --> E["Операндный стек JVM"]
    E --> F["Использование в байткоде (store, invoke, arithmetic)"]
```

## Резюме
- Все литералы компилируются в записи **constant pool** `.class`-файла (JVMS §4.4).
- `long` и `double` занимают **два слота**.
- `ldc`, `ldc2_w`, `bipush`, `aconst_null` и `invokedynamic` загружают значения в стек.
- `String` хранится через пару `CONSTANT_String` → `Utf8`.
- IEEE 754 значения (`NaN`, `±Infinity`, `-0.0`) сохраняются напрямую как биты.
- `null` не имеет записи и представляется инструкцией `aconst_null`.
- В Java 11+ добавлены `CONSTANT_Dynamic` и `MethodHandle` для лямбд и bootstrap-методов.
- JLS описывает синтаксис литералов, JVMS — их представление и поведение при выполнении.
