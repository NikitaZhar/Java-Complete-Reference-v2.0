2025-11-24 14:37
Tags: #int #toFormat 


## **4.2.4.1 Определение и диапазон**

Тип `int` — это **32-битный знаковый примитивный целочисленный тип** Java, использующий формат **two’s complement**.

|Характеристика|Значение|
|---|---|
|Размер|32 бита|
|Диапазон|−2³¹ … 2³¹−1|
|Формат|signed two’s complement|
|Значение по умолчанию|0|

Диапазон определён спецификацией и **не зависит от архитектуры CPU**:

```java
Integer.MIN_VALUE = -2_147_483_648
Integer.MAX_VALUE =  2_147_483_647
```

`int` — один из фундаментальных типов Java и стандартный тип для целочисленных операций.

---

## **4.2.4.2 int как основной числовой тип в Java**

Тип `int` является **типом по умолчанию** в Java для целых чисел, потому что:

### **1. Оптимизирован под JVM и JIT**

- большинство арифметических операций JIT оптимизирует именно под `int`;
    
- операции над `int` быстро компилируются в инструкции ALU;
    
- многие оптимизации JVM (escape analysis, scalar replacement) лучше работают с 32-битными примитивами.
    

### **2. Целочисленные литералы → по умолчанию int**

```java
42      // int
1_000_000 // int
```

Чтобы получить `long`, требуется суффикс `L`:

```java
42L  // long
```

### **3. Основной тип для индексов, размеров и счетчиков**

- индексы массивов — всегда `int`;
    
- методы коллекций (`size()`, `indexOf()`) возвращают `int`;
    
- большинство алгоритмов используют `int` как «единицу счёта».
    

### **4. Передача и совместимость API**

Стандартные библиотеки и API Java используют `int` как единый тип для измерений, размеров и индексации.

---

## **4.2.4.3 Использование в циклах, индексах и коллекциях**

`int` — основной рабочий тип во всех структурах данных Java.

### Применение:

- индексация массивов и списков,
    
- счётчики циклов,
    
- управление длиной коллекций,
    
- вычисления offsets, hash-кодов, смещений в буферах,
    
- операции над байтовыми потоками.
    

Примеры:

```java
for (int i = 0; i < n; i++) { ... }
```

```java
int index = hash & (array.length - 1);
```

```java
int size = list.size();
```

Использование `byte` или `short` в циклах — ошибка (см. Anti-patterns), т.к. они продвигаются в `int`.

---

## **4.2.4.4 Переполнение и методы `Math.addExact()`**

### **Переполнение int (overflow)**

Java **не генерирует исключение** при переполнении.  
Результат вычисляется по модулю 2³² ("оборачивается"):

```java
int x = Integer.MAX_VALUE;
int y = x + 1;

System.out.println(y); // -2147483648
```

Такое поведение **строго определено JLS**, в отличие от C/C++, где это undefined behavior.

### **Это silent bug**

Тихие ошибки возникают, если код ожидает, что переполнение приведёт к исключению:

```java
int x = 2_000_000_000;
int y = x + x; // отрицательное число без предупреждений
```

### **Безопасная арифметика**

Для контроля переполнения:

```java
Math.addExact(a, b);
Math.subtractExact(a, b);
Math.multiplyExact(a, b);
```

Они выбрасывают `ArithmeticException` при overflow.

---

## **4.2.4.5 Best Practices**

### ✔ Использовать `int` как целочисленный тип по умолчанию

Для большинства задач диапазона int достаточно.

### ✔ Использовать `long` для:

- ID,
    
- timestamp,
    
- счётчиков больших массивов,
    
- чисел, превышающих диапазон int,
    
- работы с временем (наносекунды, миллисекунды).
    

### ✔ Использовать `Integer.compare()` вместо `a - b`

```java
list.sort(Integer::compare);
```

### ✔ Контролировать переполнение

```java
Math.addExact()
```

### ✔ В высокопроизводительных алгоритмах использовать битовые операции

`int` — оптимальный тип для hashing, encoding, битовых флагов.

---

## **4.2.4.6 Anti-patterns**

|Антипаттерн|Пояснение|Последствия|
|---|---|---|
|Использовать `int` для timestamp|диапазон недостаточен|проблема 2038 года|
|Использовать `int` для ID|int слишком мал для больших систем|коллизии и переполнения|
|Использовать `int` в потокобезопасных счётчиках|`++` неатомарная операция|race conditions|
|Использовать `byte`/`short` в циклах|всегда продвигаются в int|ошибки переполнения|
|Использовать `==` для `Integer`|сравнение ссылок, а не значений|нелогичное поведение|
|Использовать `int` при работе с файлами/сетями|файлы >2GB, пакеты >2GB|ошибки I/O|

Пример проблемы 2038:

```java
int timestamp = (int)(System.currentTimeMillis() / 1000);
// переполнение наступит в 2038 году
```

---

## **4.2.4.7 Примеры использования**

### **Безопасная арифметика**

```java
int c = Math.addExact(a, b);
```

### **Хеширование и битовые операции**

```java
int mix = (x << 13) ^ (x >>> 7);
```

### **Работа с индексами**

```java
int index = hash & (array.length - 1);
```

### **Problems with promotion**

```java
byte a = 10;
byte b = 20;

int c = a + b; // promotion → int
```

---

# **4.2.4.8 Advanced Topics**

Ниже — профессиональные аспекты, не очевидные для начинающих разработчиков.

---

## **A. Signed wraparound — строго определённое поведение**

Java → всегда wraparound (mod 2³²).  
C/C++ → undefined behavior.

Это делает Java-системы более предсказуемыми при overflow.

---

## **B. int и производительность JVM**

- `int` хранится в регистрах и стеке,
    
- не создаёт объектов,
    
- не участвует в GC,
    
- отлично оптимизируется escape analysis.
    

Например, JIT может полностью устранить временные объекты, если их поля — `int`.

---

## **C. Взаимодействие с 64-битной архитектурой**

На x86_64:

- операции над `int` выполняются в 32-битной части регистра,
    
- но запись результата в память происходит как 64-битное значение,
    
- что даёт быстрые инструкции и предсказуемое поведение.
    

---

## **D. Ошибки при работе с float/double**

```java
int x = 16_777_217;
float f = x;

System.out.println(f == x); // false
```

Это из-за 24-битной мантиссы float.

---

## **E. Неатомарность int++ в многопоточности**

```java
count++; // не атомарно
```

Правильно:

```java
AtomicInteger counter = new AtomicInteger();
counter.incrementAndGet();
```

---

## **F. Signed vs. unsigned операции**

Java 8+ добавляет поддержку unsigned:

```java
Integer.toUnsignedLong(x)
Integer.divideUnsigned(a, b)
Integer.compareUnsigned(a, b)
```

Для бинарных протоколов — обязательный инструмент.

---

# **4.2.4.9 Выводы**

Тип `int` является:

- основным целочисленным типом языка,
    
- оптимизированным для работы JVM и JIT,
    
- ключевым для индексирования, коллекций, массивов,
    
- эффективным для битовых операций и хеширования,
    
- предсказуемым по поведению переполнения,
    
- требующим аккуратности при работе с временем, ID и потоками.
    
