2025-10-27 13:50
Tags: #toFormat

4.1.8 Common Pitfalls — Типичные ошибки в понимании типов и значений

## **4.1.8.1 Назначение раздела**

Этот раздел обобщает частые концептуальные ошибки, возникающие при неправильном понимании природы типов, значений, ссылок и памяти. Каждая ошибка указана кратко и снабжена ссылкой на раздел, где приведено подробное объяснение и примеры.

> Данный список служит не для объяснения, а для ориентации: _каждый пункт — это указатель на последующий тематический узел спецификации_.

---

## **4.1.8.2 Ошибки, связанные с различием между типом и значением**

|Ошибка|Суть проблемы|См. раздел|
|---|---|---|
|Смешение типа и значения|Попытка использовать значение без учета его типа или делать вывод о типе на основании значения|[[4.1.4 Type vs Value]]|
|Непонимание зависимости операций от типа|Операция допустима только в рамках типа, а не для конкретного значения|[[4.1.1 Definition of Type]]|

---

## **4.1.8.3 Ошибки, связанные с `null` и ссылками**

| Ошибка                                                                  | Причина                                                                     | См. раздел                         |
| ----------------------------------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------- |
| Сравнение ссылок вместо значений (`==` вместо `.equals()`)              | `==` сравнивает ссылки, а не содержимое                                     | [[4.3.2 Identity and Equality]]    |
| Попытка использовать `null` как объект                                  | Значение `null` не ссылается на объект и не поддерживает вызов методов      | [[4.3.1 Null Type]]                |
| Неверное предположение, что `null` является значением примитивного типа | Примитивы не допускают `null`                                               | [[4.2 Primitive Types and Values — Примитивные типы и их значения]] |
| Использование `==` для строк                                            | Интернирование может дать “случайный” `true`, сравнивайте через `.equals()` | [[Identity and Equality]]          |

---

## **4.1.8.4 Ошибки, связанные с подтипированием и полиморфизмом**

|Ошибка|Причина|См. раздел|
|---|---|---|
|Предположение, что статический тип определяет поведение|Поведение определяется runtime-типом объекта|[[4.1.5 Static vs Runtime Type]]|
|Неправильное приведение типов|Приведение разрешено статически, но может быть невозможно во время выполнения|[[4.1.6 Subtypes and Supertypes]]|

---

## **4.1.8.5 Ошибки, связанные с памятью и моделью значений**

|Ошибка|Причина|См. раздел|
|---|---|---|
|Ожидание, что переменная "содержит объект"|Переменная ссылочного типа содержит только ссылку|[[4.1.7 JVM Memory Model]]|
|Непонимание передачи аргументов|Передача по значению (в том числе копии ссылки)|[[4.1.7 JVM Memory Model]]|

---

## **4.1.8.6 Специфические ошибки, связанные с массивами и обёртками**

| Ошибка                                          | Причина                                                     | См. раздел                            |
| ----------------------------------------------- | ----------------------------------------------------------- | ------------------------------------- |
| Ошибочное использование ковариантности массивов | Массивы ковариантны, но проверяются JVM во время выполнения | [[4.3.3 Array Types]]                 |
| Использование `==` с обёртками примитивов       | Кеширование и автоупаковка приводят к ошибкам сравнения     | [[4.2.x Boxing and Wrapper Types]]    |
| Unboxing `null`                                 | Распаковка `null` вызывает `NullPointerException`           | [[Boxing/Unboxing and Wrapper Types]] |

---

## **4.1.8.7 Ошибки, связанные с generics (обобщениями)**

|Ошибка|Причина|См. раздел|
|---|---|---|
|Предположение, что `List<String>` является подтипом `List<Object>`|Обобщённые типы инвариантны|[[4.5.4 Wildcards (PECS)]]|
|Путаница между compile-time и runtime типами в generics|Стирание типов (`type erasure`)|[[4.5.8 Type Erasure and Bridge Methods]]|
|Создание массива параметризованного типа|Generic types are not reifiable|[[4.5.9 Reifiable vs Non-Reifiable]]|

---

## **4.1.8.8 Вывод**

- Все перечисленные ошибки имеют **одну общую причину**: непонимание фундаментального различия между _типом_ и _значением_, а также между _статикой_ и _исполнением_.
    
- Раздел 4.1 создаёт базу, позволяющую избежать этих ошибок.
    
- Каждый из последующих разделов главы 4 углубляет конкретную тему и устраняет соответствующее заблуждение.
    

---

## **Cross-References**

Для более глубокого изучения см. следующие разделы:

- **[[4.1.4 Type vs Value]]**
    
- **[[4.1.5 Static vs Runtime Type]]**
    
- **[[4.1.6 Subtypes and Supertypes]]**
    
- **[[4.3.1 Null Type]]**
    
- **[[4.3.2 Identity and Equality]]**
    
- **[[4.3.3 Array Types]]**
    
- **[[4.2 Primitive Types and Values — Примитивные типы и их значения]]**
    
- **[[4.5 Generics and Type Variables]]**
    
