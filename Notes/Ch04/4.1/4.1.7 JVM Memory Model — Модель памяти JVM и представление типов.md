2025-10-27 13:48
Tags: #toFormat

Модель памяти JVM (Java Memory Model, JMM) описывает, **как значения создаются, хранятся и становятся доступными во время выполнения программы**.  
Она включает два уровня:

1. **Физическую модель размещения данных** — стек, куча, метапространство и внутренние структуры JVM;
    
2. **Логическую модель видимости и упорядоченности** — определяет, как изменения переменных становятся видимыми между потоками.
    

> В данном разделе рассматривается физический уровень модели памяти.  
> Логическая модель видимости описана в разделе [[4.9.3 Java Memory Model (Concurrency)]].

---

## **4.1.7.1 Назначение модели памяти**

Модель памяти в JVM определяет:

- **где и как** хранятся значения примитивных и ссылочных типов;
    
- **как выполняется доступ** к этим значениям;
    
- **какие типы данных** могут находиться в стеке или куче;
    
- **как тип влияет** на форму хранения значения.
    

> Тип данных определяет не только поведение, но и форму хранения значения во время выполнения.

---

## **4.1.7.2 Основные области памяти JVM**

|Область|Назначение|Какие значения хранятся|
|---|---|---|
|**Stack (стек)**|Временные данные вызовов методов|примитивные значения, ссылки на объекты|
|**Heap (куча)**|Долговременное хранение объектов|объекты классов, массивы, строки, record-типы, enum|
|**Metaspace (метапространство)**|Метаданные классов и статические данные|описания классов, таблицы методов, static-поля|

> **Metaspace** хранит структуру типов и их константные пулы.  
> Сами объекты `static`-полей размещаются в куче.

---

## **4.1.7.3 Представление примитивных и ссылочных значений**

|Тип|Где хранится значение|Комментарий|
|---|---|---|
|Примитив (`int`, `double`)|в стеке (или внутри объекта в куче)|значение записывается напрямую|
|Ссылка (`String`, `List`)|в стеке (или в поле объекта)|содержит адрес объекта в куче|
|Объект|в куче|доступен только через ссылку|
|`null`|в том же месте, где ссылка|обозначает отсутствие объекта|

> **Упрощённая схема JVM-памяти:**
> 
> ```
> [Thread Stack] ──► [Reference] ──► [Object in Heap]
>                                   └──► [Class Metadata in Metaspace]
> ```

---

## **4.1.7.4 Пример хранения значений**

```java
int x = 10;         // x в стеке, значение 10 — примитив
String s = "Java";  // s в стеке, хранит ссылку на объект в куче
```

- Примитив `10` хранится непосредственно.
    
- Переменная `s` содержит ссылку, указывающую на строковый объект в куче.
    

---

## **4.1.7.5 Объекты и ссылки**

- Все ссылочные значения **указывают на объекты**, созданные через `new` или литералы.
    
- Объекты всегда размещаются **в куче**, независимо от места объявления переменной.
    
- Несколько ссылок могут указывать на один объект.
    

```java
String a = new String("ABC");
String b = a; // обе ссылки указывают на один объект
```

---

## **4.1.7.6 Передача значений в методы**

Java всегда использует **передачу по значению** (_pass-by-value_):

- Для примитивов передаётся **само значение**;
    
- Для ссылочных — **копия ссылки**, а не сам объект.
    

```java
void modify(String s) {
    s = "World"; // изменяет копию ссылки, оригинал не затронут
}

String str = "Hello";
modify(str);
System.out.println(str); // "Hello"
```

Изменение содержимого объекта внутри метода влияет на исходный объект,  
но переназначение ссылки — нет.

---

## **4.1.7.6a Final-поля и неизменяемость**

Поля, объявленные как `final`, обладают особым статусом в модели памяти:

- их значения становятся видимыми всем потокам **после завершения конструктора**;
    
- JVM может применять оптимизации, предполагая неизменность.
    

```java
final class Point {
    final int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
```

> `final` гарантирует _safe publication_ — корректную видимость данных без синхронизации,  
> если объект не изменяется после создания.

---

## **4.1.7.7 Значение `null` и отсутствие объекта**

- `null` — допустимое значение любой переменной ссылочного типа;
    
- обозначает отсутствие связи с объектом;
    
- попытка обращения к полю или методу вызывает `NullPointerException`.
    

```java
String s = null;
System.out.println(s.length()); // NullPointerException
```

Подробнее: [[4.3.1 Null Type]].

---

## **4.1.7.8 Тип и размещение в памяти**

|Категория типа|Пример|Представление в памяти|
|---|---|---|
|Примитивный тип|`int x = 5;`|значение `5` хранится прямо|
|Классовый тип|`Point p;`|ссылка в стеке, объект в куче|
|Массив|`int[] a;`|ссылка в стеке, массив в куче|
|Enum|`Color.RED`|ссылка на статически созданный объект enum|
|Record|`Point(int x, int y)`|объект в куче, поля неизменяемы|

---

## **Примечание о value-типах (Project Valhalla)**

В новых версиях JVM (начиная с Java 25+) вводятся **value classes** — объекты без идентичности,  
которые могут храниться непосредственно в стеке или внутри массива, без выделения в куче.

> Value-типы занимают промежуточное положение между примитивами и ссылочными типами:  
> обеспечивают эффективность хранения примитивов при сохранении объектного интерфейса.

---

## **4.1.7.9 Вывод**

- Тип определяет не только допустимые значения, но и **форму хранения** в памяти JVM.
    
- Примитивы — непосредственные значения.
    
- Ссылочные типы — адреса объектов в куче.
    
- `static`-поля и метаданные хранятся в **Metaspace**.
    
- `final`-поля обеспечивают безопасную публикацию.
    
- Все аргументы передаются по значению.
    
- Понимание модели памяти необходимо для корректной работы с многопоточностью и оптимизацией производительности.
    

> **Формула:**  
> Примитив — _значение_,  
> объект — _сущность в куче_,  
> ссылка — _путь к этой сущности_.

---

## **Cross-References**

- **[[4.1.3 High-Level Classification of Types]]** — разделение на примитивные и ссылочные типы.
    
- **[[4.1.5 Static vs Runtime Type]]** — влияние типа на поведение во время выполнения.
    
- **[[4.1.6 Subtypes and Supertypes]]** — совместимость ссылочных типов.
    
- **[[4.2 Primitive Types and Values]]** — специфика и диапазоны примитивных типов.
    
- **[[4.3 Reference Types and Values]]** — структуры ссылочных объектов.
    
- **[[4.9.3 Java Memory Model (Concurrency)]]** — видимость и синхронизация между потоками.
    

---

Хочешь, чтобы я аналогично подготовил **4.2 Primitive Types and Values** — с таблицами представления, диапазонами, битовыми форматами, автоприведением и отличием `char` от `int` (в твоём стиле — строгом и академически выверенном)?
