2025-10-07 17:51
Tags: #

Семантические ограничения — это **правила корректности программы**, которые нельзя описать одной лишь КС-грамматикой.

Основные классы ограничений:

- система типов и совместимость (включая generics),
    
- разрешение имён и области видимости,
    
- definite assignment и использование `final`,
    
- проверка достижимости операторов,
    
- обработка исключений и требования к checked-исключениям,
    
- корректность sealed-иерархий, record и enum,
    
- правила перегрузки и переопределения методов,
    
- модификаторы доступа и ограничения доступности членов,
    
- примеры частых ошибок компиляции и чек-листы для разработчиков.
    

## 1. Понятие семантических ограничений

**Семантические ограничения** — это правила, которые не могут быть выражены одной лишь контекстно-свободной грамматикой, но обязательны для корректной программы Java.  
Компилятор применяет их **после успешного синтаксического разбора**.

> Синтаксис описывает _форму_ программы,  
> семантические ограничения проверяют _смысл_ — типы, области видимости, доступность, инициализацию, исключения и др.

---

## 2. Фазы проверки в компиляторе

1. **Лексический и синтаксический анализ** — проверка структуры по грамматикам (§2.1 и §2.2).
    
2. **Построение дерева AST** — структура программы.
    
3. **Семантический анализ**:
    
    - связывание имён с объявлениями,
        
    - проверка типов,
        
    - контроль областей видимости и модификаторов,
        
    - definite assignment/unassignment,
        
    - достижимость операторов,
        
    - обработка исключений,
        
    - правила перегрузки и переопределения.
        

> Только после прохождения всех семантических проверок генерируется байткод.

---

## 3. Основные категории семантических ограничений

### 3.1 Система типов и совместимость

- Проверка типов выражений при присваивании, передаче аргументов, возврате значений.
    
- Совместимость с обобщениями (generics), wildcard-подстановками.
    
- Преобразования (casting, boxing/unboxing).
    

**Пример ошибки:**

```java
List<Integer> a = new ArrayList<>();
List<Number> b = a;   // ERROR: инвариантность generics
```

---

### 3.2 Имена и области видимости

- Каждое имя (идентификатор) должно быть разрешено в своей области видимости.
    
- Запрещены ссылки на переменные до их объявления.
    
- Важны правила сокрытия и теневания (shadowing/hiding).
    

**Пример ошибки:**

```java
void m() {
    System.out.println(x); // ERROR: x ещё не определена
    int x = 10;
}
```

---

### 3.3 Определённость присваивания (Definite Assignment, DA)

- Локальная переменная должна быть определённо инициализирована до первого чтения.
    
- `final` переменная должна быть определённо неинициализирована до первого присваивания.
    

**Пример ошибки DA:**

```java
int x;
if (cond) x = 1;
System.out.println(x); // ERROR: x может не получить значение
```

---

### 3.4 Область видимости pattern-переменных

- Переменные, введённые в `instanceof` или `switch`, доступны только там, где гарантировано истинное соответствие шаблону.
    

**Пример ошибки:**

```java
if (obj instanceof String s && s.length() > 0) {
    System.out.println(s);
}
System.out.println(s); // ERROR: s вне области видимости
```

---

### 3.5 Достижимость операторов (Reachability)

- Некоторые инструкции должны быть достижимыми.
    
- Код после оператора `return` или `throw` недостижим — ошибка компиляции.
    

**Пример ошибки:**

```java
return;
System.out.println("Never executed"); // ERROR: недостижимый код
```

---

### 3.6 Исключения

- Методы должны объявлять или обрабатывать checked-исключения.
    
- Нарушение этого правила — ошибка компиляции.
    

**Пример ошибки:**

```java
void m() {
    throw new IOException(); // ERROR: должно быть объявлено или обработано
}
```

---

### 3.7 Перегрузка и переопределение

- При перегрузке методы различаются по сигнатуре.
    
- При переопределении метод в подклассе должен быть совместим по возвращаемому типу и исключениям, и иметь совместимую область видимости.
    

**Пример ошибки:**

```java
class A { Number f() { return 1; } }
class B extends A {
    @Override
    Integer f() throws Exception { return 1; } // ERROR: недопустимое исключение
}
```

---

### 3.8 Модификаторы доступа

- `private`, `protected`, `public`, package-private.
    
- Нарушение правил доступа — ошибка компиляции.
    

---

### 3.9 Ограничения sealed-иерархий

- Подклассы sealed-класса должны быть явно разрешены через `permits` и удовлетворять требованиям (быть final, sealed или non-sealed).
    

**Пример ошибки:**

```java
sealed class Base permits Sub {}
class Other extends Base {} // ERROR: не разрешено
```

---

## 4. Примеры часто встречающихся ошибок

### Ошибка использования this

Ссылка на `this` до инициализации полей `final` в конструкторе запрещена.

```java
class A {
    final int x;
    A() {
        useThis(this); // ERROR: объект не полностью инициализирован
        x = 5;
    }
    void useThis(A a) { }
}
```

---

### Ошибка с generics

```java
List<String> list = new ArrayList<>();
List<Object> lo = list; // ERROR: несовместимость типов
```

---

### Ошибка из-за unreachable-кода

```java
while (true) {
    break;
    System.out.println("never"); // ERROR: недостижимый код
}
```

---

## 5. Чек-лист для программистов

- Убедитесь, что все переменные инициализированы до использования.
    
- Следите за областями видимости pattern-переменных.
    
- Обрабатывайте или объявляйте checked-исключения.
    
- Проверяйте доступность типов и членов по модификаторам доступа.
    
- Избегайте мёртвого кода.
    
- В иерархиях sealed-классов проверяйте разрешённые подклассы.
    

---

## 6. Схема процесса компиляции с семантическими проверками

```
Исходный код
   ↓ Лексический анализ
Токены
   ↓ Синтаксический анализ
AST
   ↓ Семантический анализ:
       - разрешение имён
       - проверка типов
       - definite assignment
       - обработка исключений
       - проверка доступности и правил sealed/record/enum
   ↓ Генерация байткода
```

---

## 7. Практические рекомендации

- Всегда используйте средства IDE и статического анализа для раннего обнаружения семантических ошибок.
    
- При изменениях в иерархии типов проверяйте совместимость методов и сигнатур.
    
- Не полагайтесь на автоматическое приведение типов без анализа — особенно при работе с generics.
    
- Следите за изменениями стандартов Java: новые версии могут вводить дополнительные ограничения.
    

---

## 8. Ссылки на первоисточники

- [JLS §2.3 — The Semantic Constraints](https://docs.oracle.com/javase/specs/jls/se23/html/jls-2.html)
    
- [JLS §4 — Types, Values, and Variables](https://docs.oracle.com/javase/specs/jls/se23/html/jls-4.html)
    
- [JLS §6 — Names and Scopes](https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html)
    
- [JLS §11 — Exceptions](https://docs.oracle.com/javase/specs/jls/se23/html/jls-11.html)
    
- [JLS §16 — Definite Assignment](https://docs.oracle.com/javase/specs/jls/se23/html/jls-16.html)
    

---

Хотите, чтобы я сохранил этот раздел в отдельный файл **`2.3. The Semantic Constraints.md`** для загрузки?
