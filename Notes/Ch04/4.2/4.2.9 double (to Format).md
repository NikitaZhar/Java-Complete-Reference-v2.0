2025-11-25 17:12
Tags: #double #toFormat 


`double` — примитивный 64-битный тип Java, реализующий формат **IEEE 754 binary64**.  
Он является **основным числовым типом с плавающей точкой** в Java благодаря высокой точности (≈15–16 значимых цифр), устойчивости вычислений и оптимальной производительности на большинстве CPU.

---

## **4.2.9.1 Формат binary64**

```
┌ sign (1 bit) ┐ ┌ exponent (11 bits) ┐ ┌ fraction (52 bits) ┐
s                eeeeeeeeeee            ffffffffffffffffffffffffffffffffffffffffffffffffffff
```

Значение определяется формулами IEEE 754:

- нормализованная форма
    
- subnormal форма
    
- специальные значения: **NaN**, **±Infinity**, **±0.0**
    

---

## **4.2.9.2 Диапазоны значений**

|Параметр|Значение|
|---|---|
|Максимальное нормализованное|~1.7976931348623157×10³⁰⁸|
|Минимальное нормализованное|~2.2250738585072014×10⁻³⁰⁸|
|Минимальное subnormal|~4.9×10⁻³²⁴|
|Точность|~15–16 десятичных значащих цифр|

---

## **4.2.9.3 Корректные примеры**

```java
double d1 = 1.0;
double d2 = 3.141592653589793;
double d3 = 1e200;
double d4 = Double.POSITIVE_INFINITY;
double d5 = Double.NaN;
```

---

## **4.2.9.4 Ошибочные примеры**

```java
boolean b = (0.1 + 0.2) == 0.3; // false
double x = 1e308 * 1e308;       // Infinity (overflow)
double y = Math.sqrt(-1);       // NaN
```

---

## **4.2.9.5 Константы Double.MIN_VALUE и типичные ошибки**

Аналогично float, ключевая ловушка:

```
Double.MIN_VALUE > 0
```

`Double.MIN_VALUE` — это **минимальное положительное subnormal значение**, а не «самое маленькое отрицательное число».

|Константа|Значение|Семантика|
|---|---|---|
|`Double.MIN_VALUE`|~4.9×10⁻³²⁴|min positive _subnormal_|
|`Double.MAX_VALUE`|~1.79×10³⁰⁸|max normal|
|`-Double.MAX_VALUE`|~−1.79×10³⁰⁸|min negative normal|
|_нет константы_|—|min negative subnormal|

---

## **4.2.9.6 Canonical NaN и сохранение payload**

- `Double.doubleToLongBits()` → нормализует NaN к **canonical NaN**
    
- `Double.doubleToRawLongBits()` → сохраняет payload
    

Пример:

```java
double n1 = Double.longBitsToDouble(0x7FF8000000000001L);
double n2 = Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL);

Double.doubleToLongBits(n1) == Double.doubleToLongBits(n2);        // true
Double.doubleToRawLongBits(n1) == Double.doubleToRawLongBits(n2);  // false
```

Canonical NaN (binary64):

```
0x7ff8000000000000
```

Это критично для:

- сериализации,
    
- сетевых протоколов,
    
- бит-точного воспроизведения вычислений.
    

---

## **4.2.9.7 Overflow и underflow**

### Overflow → Infinity

```java
double a = 1e308;
double b = a * 1000; // +Infinity
```

### Underflow → subnormal или 0.0

```java
double c = 5e-324 * 0.5; // subnormal
double d = 5e-324 / 10;  // 0.0
```

---

## **4.2.9.8 Особенности сравнения double**

```java
-0.0 == 0.0                     // true
Double.compare(-0.0, 0.0) < 0   // учитывает sign bit

Double.compare(Double.NaN, 1.0) > 0 // NaN "больше всех" (IEEE total ordering)
```

---

## **4.2.9.9 Точность представления целых чисел**

`double` точно хранит **все целые числа** в диапазоне:

```
[-2^53, 2^53] ≈ ±9.007199254740992×10^15
```

Это одна из причин, почему double подходит лучше float для вычислений, связанных с целыми величинами.

Пример потери точности:

```java
double d = 9007199254740993.0; // 2^53 + 1
System.out.println(d);         // 9.007199254740992E15 — округлено
```

---

## **4.2.9.10 Приведения типов**

### float → double

Без потерь (расширение, все значения float точно представимы в double).

### long → double

Потери точности начинаются после 2⁵³.

```java
long x = 9007199254740993L; // 2^53 + 1
double d = x;               // округлено
```

### double → float

Может вызвать overflow, потерю значащих цифр:

```java
float f = (float) 1e200; // Infinity
```

### double → int

Отбрасывание дробной части, возможен overflow → undefined truncation:

```java
(int) 1e20; // поведение: platform-independent, но бессмысленное значение
```

---

## **4.2.9.11 Подводные камни double**

- `0.1`, `0.2`, `0.3` **не представимы точно**
    
- проблемы при сравнении близких величин
    
- cancellation при вычитании похожих чисел
    
- переполнение → Infinity
    
- недопустимые операции → NaN
    
- subnormal числа могут быть медленнее
    
- возможны небольшие различия между CPU / JIT / разными JVM
    

---

## **4.2.9.12 Практические рекомендации**

Использовать `double`, когда:

- нужна высокая точность,
    
- требуется численная устойчивость,
    
- расчёты общего назначения,
    
- научные и статистические вычисления,
    
- симуляции, моделирование, аналитика.
    

Не использовать:

- финансовые расчёты (использовать BigDecimal),
    
- криптография,
    
- ситуации, где требуется строгий детерминизм без ошибок округления.
    

---

## **4.2.9.13 Endianness и бинарная сериализация**

- `DataOutputStream` → big-endian
    
- `ByteBuffer` → настраиваемый порядок байт
    

```java
ByteBuffer buffer = ByteBuffer.allocate(8)
    .order(ByteOrder.LITTLE_ENDIAN)
    .putDouble(d);
```

---

## **4.2.9.14 double vs float**

### double:

- точность 15–16 цифр
    
- устойчивее к ошибкам
    
- меньше cancellation
    
- быстрее на большинстве CPU
    
- стандартный выбор во всех вычислениях
    

### float:

- экономия памяти
    
- эффективно на GPU/ML
    
- ниже точность (~7 digits)
    
- применяется там, где важна скорость и размер
    

---

## **4.2.9.15 Мини-схема**

```
double (binary64)
    ├─ формат: 1 + 11 + 52 бит
    ├─ точность: ~15–16 digits
    ├─ точные целые: до 2^53
    ├─ MIN_VALUE = min positive subnormal
    ├─ canonical NaN + raw payload
    ├─ overflow → Infinity
    ├─ underflow → subnormal / 0
    ├─ compare rules (-0.0 < +0.0, NaN last)
    ├─ numeric conversions (float, long, int)
    ├─ endianness & binary serialization
    └─ рекомендации по применению
```
