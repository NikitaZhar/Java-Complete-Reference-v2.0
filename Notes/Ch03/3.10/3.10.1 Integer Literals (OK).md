2025-11-16 15:16
Tags: #IntegerLiterals

Согласно спецификации `Java Language Specification` (§3.10.1), `IntegerLiteral` — это один из видов `Literal` в грамматике:

```java
Literal:
    IntegerLiteral
    FloatingPointLiteral
    BooleanLiteral
    CharacterLiteral
    StringLiteral
    NullLiteral
```

`Integer literal` — это последовательность цифр (возможно с префиксом и/или суффиксом), представляющая неизменяемое целое значение типа `int` или `long`.

`IntegerLiteral` может быть записан в десятичной, шестнадцатеричной, двоичной или (устаревшей) восьмеричной форме.  
Целочисленные литералы представляют значения типов `int` и `long`.  
Тип по умолчанию — `int`; суффикс `L` или `l` создаёт литерал типа `long`.
```java
int x = 42;
long y = 42L;
```

> Рекомендуется использовать **заглавную `L`**, а не строчную `l`, поскольку последняя визуально совпадает с цифрой `1`.

## Отрицательные литералы
Отрицательные значения формируются **оператором** `-`, применённым к положительному литералу
```java
long n = -9223372036854775808L; // корректно, хотя без минуса — ошибка
```

## Системы счисления и устаревшие форматы

| Система               | Префикс     | Пример                | Комментарий       |
| :-------------------- | :---------- | :-------------------- | :---------------- |
| Десятичная            | —           | `42`                  | стандартная форма |
| Шестнадцатеричная     | `0x` / `0X` | `0x2A`, `0xCAFE_BABE` | цифры 0–9, A–F    |
| Двоичная              | `0b` / `0B` | `0b101010`            | с Java 7          |
| Восьмеричная (устар.) | `0`         | `052`                 | до Java 7         |

> До Java 7 запись `010` означала восьмеричное число (8).  
> В современных версиях литералы с ведущими нулями (`0010`) трактуются как десятичные.

## Разделители и диапазоны
В Java 7 добавлена поддержка **символа подчёркивания** `_` в числовых литералах для повышения читаемости
```java
int million = 1_000_000;
long big = 9_223_372_036_854_775_807L;
```

Символ `_` разрешён **между цифрами**, но **не** в начале, конце или рядом с префиксом/суффиксом:

✅ `0xCAFE_BABE`, `1_000_000`  
❌ `_123`, `123_`, `0_x10`, `10_L`

|Тип|Минимум|Максимум|Размер|
|:--|--:|--:|:--|
|`int`|-2 147 483 648|2 147 483 647|32 бита|
|`long`|-9 223 372 036 854 775 808|9 223 372 036 854 775 807|64 бита|

## Narrowing conversions и Constant folding
```java
final int K = 10;
byte b = K; // допустимо
```

> Если константа помещается в диапазон меньшего типа, приведение выполняется автоматически.

Компилятор вычисляет выражения из литералов на этапе компиляции (`constant folding`):
```java
final int A = 2 * 3 * 7; // 42
final String S = "Java " + "17"; // "Java 17"
```

## Numeric promotion и знаковая арифметика
```java
System.out.println(1 / 2);   // 0
System.out.println(1 / 2.0); // 0.5
```

Арифметика между литералами следует правилу `binary numeric promotion` (§5.6.1).  
В Java 8 появились методы для **беззнаковой арифметики**:
```java
int x = -1;
System.out.println(Integer.toUnsignedString(x));   // 4294967295
System.out.println(Integer.divideUnsigned(-2, 2)); // 2147483647
```

А также оператор `>>>` (`zero-fill right shift`):
```java
int a = -8 >>> 1; // 2147483644
```

## Integer.decode и parseInt
Метод `Integer.decode()` интерпретирует строки с теми же префиксами, что и литералы:
```java
int a = Integer.decode("0x10"); // 16
int b = Integer.decode("010");  // 8
int c = Integer.decode("#20");  // 32
```

> Это API-аналог лексической семантики числовых литералов.

## Переполнение
Переполнение не вызывает исключений — результат берётся по модулю `2³²` или `2⁶⁴`
```java
int x = 2_000_000_000;
int y = x * 2; // отрицательное значение

System.out.println(y); // -294967296
System.out.println(Integer.toBinaryString(y));
// 11101111010111000010000000000000
```
Переполнение выполняется по модулю `2³²`. Старший бит становится знаковым, что приводит к отрицательному числу.

## Сводка правил

|Правило|Пример|Допустимо|
|:--|:--|:-:|
|Десятичная форма|`42`|✅|
|Шестнадцатеричная форма|`0x2A`|✅|
|Двоичная форма|`0b101010`|✅|
|Восьмеричная (устар.)|`052`|⚠️|
|Суффикс `L` для `long`|`42L`|✅|
|Подчёркивания между цифрами|`1_000_000`|✅|
|Подчёркивание в начале/конце|`_100`, `100_`|❌|

## Резюме
- Литералы `int` и `long` формируются до фазы лексического анализа и участвуют в `constant folding`.
- Суффикс `L` обязателен для значений, не помещающихся в `int`.
- Переполнение — определённое поведение (модульное), без исключений.
- Символ `_` повышает читаемость, но имеет строгие синтаксические ограничения.
