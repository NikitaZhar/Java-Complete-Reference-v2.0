2025-10-27 13:47
Tags: #toFormat

4.1.6 Subtypes and Supertypes — Подтипы и надтипы

## **4.1.6.1 Основное понятие**

**Подтип** — это тип, значения которого могут использоваться в любом контексте, где ожидается значение другого типа (надтипа), **без нарушения типобезопасности**.

Если тип `B` является подтипом типа `A`, то справедливо:

```
B <: A  (B is a subtype of A)
A :> B  (A is a supertype of B)
```

> Принцип: **всякий объект подтипа может рассматриваться как объект надтипа**, даже если его конкретная реализация отличается.

---

## **4.1.6.2 Роль подтипирования**

Подтипирование лежит в основе:

- **Наследования классов**
    
- **Реализации интерфейсов**
    
- **Полиморфизма**
    
- **Совместимости при присваивании**
    
- **Передачи аргументов и возврата результатов методов**
    

---

## **4.1.6.3 Формальные источники подтипов**

### **1. Наследование классов**

Если класс `B` объявлен как `extends A`, то `B` — подтип `A`.

```java
class A {}
class B extends A {} // B <: A
```

### **2. Реализация интерфейсов**

Если класс или интерфейс объявлен как `implements I`, он является подтипом интерфейса `I`.

```java
interface I {}
class C implements I {} // C <: I
```

### **3. Массивы (ковариантность)**

Массивы в Java ковариантны:

```
Если T <: S, то T[] <: S[]
```

Однако это может привести к ошибкам времени выполнения (см. [[4.3.3 Array Types]]).

```java
String[] arr = new String[1];
Object[] objArr = arr; // допустимо: String[] <: Object[]
```

### **4. Специальные типы**

- Тип `Object` является **надтипом всех ссылочных типов**.
    
- Тип `null` (Null Type) является **подтипом всех ссылочных типов** (см. [[4.3.1 Null Type]]).
    

---

## **4.1.6.4 Пример корректного подтипирования**

```java
Number n = Integer.valueOf(5); // Integer <: Number
Object o = n;                 // Number <: Object
```

---

## **4.1.6.5 Присваивание и контекст совместимости**

Если `B <: A`, то значение типа `B` может быть присвоено переменной типа `A`.

```java
A a = new B(); // полиморфное присваивание
```

---

## **4.1.6.6 Полиморфизм (runtime dispatch)**

Подтип может переопределять методы надтипа. При вызове методов определяется фактический (runtime) тип объекта.

```java
class A {
    void m() { System.out.println("A"); }
}
class B extends A {
    void m() { System.out.println("B"); }
}

A obj = new B();
obj.m(); // Выведет "B"
```

- Статический тип: `A`
    
- Исполняемый тип: `B`
    
- Вызывается реализация подтипа `B`.
    

---

## **4.1.6.7 Приведение типов (casting) и подтипирование**

Если объект имеет подтип `B`, его можно привести к надтипу `A` **без приведения**:

```java
B b = new B();
A a = b; // неявное приведение
```

Обратное приведение требует проверки во время выполнения:

```java
A a = new B();
B b = (B) a; // допустимо, фактический объект — B
```

Если фактический тип объекта не соответствует, будет исключение:

```java
A a = new A();
B b = (B) a; // ClassCastException
```

---

## **4.1.6.8 Подтипирование и тип `Object`**

- `Object` является **корнем всей иерархии ссылочных типов**.
    
- Все классы и массивы **являются подтипами `Object`**.
    
- Примитивные типы **не являются подтипами `Object`**.
    

```java
Object o1 = "text"; // String <: Object
Object o2 = new int[5]; // int[] <: Object
```

---

## **4.1.6.9 Особый случай: тип `null`**

- Значение `null` совместимо с любой ссылочной переменной.
    
- Считается подтипом всех ссылочных типов.
    

```java
String s = null;
Object o = null;
Runnable r = null;
```

Подробнее: [[4.3.1 Null Type]]

---

## **4.1.6.10 Подтипирование и безопасность типов**

Подтипирование служит фундаментом **типобезопасности**:

- гарантирует, что поведение объекта будет соответствовать ожиданиям контракта его надтипа;
    
- предотвращает нарушение модели памяти.
    

Нарушения возможны только при использовании небезопасных конструкций (`raw types`, рефлексия и пр.) и приводят к исключениям времени выполнения.

---

## **4.1.6.11 Вывод**

- Подтипирование определяет **совместимость типов** и **возможность подстановки** одного типа вместо другого.
    
- Java использует **номинальную** систему типов: совместимость основана **на объявлении**, а не на структуре.
    
- Это фундамент для наследования, интерфейсов, полиморфизма и generics.
    

> Если `B <: A`, то любое значение `B` может быть использовано там, где ожидается значение `A`.

---

## **Cross-References**

- См. также:
    
    - **[[4.1.5 Static vs Runtime Type]]** — влияние подтипирования на полиморфизм.
        
    - **[[4.3.1 Null Type]]** — `null` как подтип всех ссылочных типов.
        
    - **[[4.3.3 Array Types]]** — ковариантность массивов.
        
    - **[[4.5.0 Generics — Overview]]** — инвариантность обобщённых типов.
        
    - **[[4.9 ClassLoader and Type Identity]]** — идентичность типов на уровне JVM.
        
