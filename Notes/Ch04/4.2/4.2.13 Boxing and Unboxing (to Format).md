2025-11-25 18:57
Tags: #Boxing #Unboxing #toFormat 

Boxing и unboxing — автоматические преобразования между **примитивными типами** и их **wrapper-классами** (`Integer`, `Double`, `Boolean`, и др.).  
Они являются фундаментальной частью Java, играют ключевую роль в коллекциях, перегрузках методов, generics и работе с API.

---

# **4.2.13.1 Официальное определение (JLS §5.1.7, §5.1.8)**

## Boxing:

Автоматическое преобразование:

```
T_primitive  →  T_wrapper
```

например:

```
int → Integer
double → Double
boolean → Boolean
char → Character
```

## Unboxing:

Обратное преобразование:

```
T_wrapper  →  T_primitive
```

например:

```
Integer → int
Boolean → boolean
```

Эти преобразования могут происходить **неявно**, включая:

- присваивание
    
- возвращаемые значения
    
- вызовы методов
    
- арифметику
    
- сравнение
    
- конкатенацию строк
    

---

# **4.2.13.2 Таблица соответствия примитивов и wrapper-классов**

|Примитив|Wrapper|
|---|---|
|`byte`|`Byte`|
|`short`|`Short`|
|`int`|`Integer`|
|`long`|`Long`|
|`float`|`Float`|
|`double`|`Double`|
|`char`|`Character`|
|`boolean`|`Boolean`|

---

# **4.2.13.3 Примеры boxing**

```java
int a = 5;
Integer x = a; // boxing
```

```java
char c = 'A';
Character ch = c; // boxing
```

```java
Boolean b = true; // boxing неявно
```

---

# **4.2.13.4 Примеры unboxing**

```java
Integer n = 10;
int x = n; // unboxing
```

```java
Boolean flag = Boolean.TRUE;
boolean f = flag; // unboxing
```

---

# **4.2.13.5 Unboxing и NPE**

Unboxing значения `null` приводит к **NullPointerException**.

```java
Integer x = null;
int y = x;  // NPE
```

Даже в сложных выражениях:

```java
Integer x = null;
int z = x + 5; // NPE при unboxing
```

---

# **4.2.13.6 Boxing/Unboxing в арифметике и сравнениях**

```java
Integer x = 5;
Integer y = 5;

int z = x + y; // оба unbox → int 5 + 5 = 10
```

Сравнение:

```java
Integer a = 1000;
Integer b = 1000;

boolean r1 = (a == b);      // false — сравнение ссылок
boolean r2 = a.equals(b);   // true
```

---

# **4.2.13.7 Взаимодействие с кэшированием wrapper’ов**

Java кэширует:

- `Integer` в диапазоне **[-128; 127]**
    
- `Character` в диапазоне **[0; 127]**
    
- `Boolean` — два значения
    
- `Byte` — полностью
    
- `Short` — [-128; 127]
    
- `Long` — [-128; 127]
    

### Пример:

```java
Integer a = 127;
Integer b = 127;

a == b   // true (кэш)
```

Но:

```java
Integer a = 128;
Integer b = 128;

a == b   // false
```

---

# **4.2.13.8 Boxing + Widening и Unboxing + Widening (JLS §5.2, §5.3)**

Java разрешает следующие цепочки:

### ✔ **widening → boxing**

```java
int x = 5;
Number n = x; // int → Integer → Number
```

### ✔ **unboxing → widening**

```java
Integer x = 5;
double d = x; // Integer → int → double
```

### ❌ narrowing → boxing запрещено

```java
Byte b = (byte) 300; // разрешено
Byte b2 = 300;       // ошибка — narrowing+boxing запрещены
```

---

# **4.2.13.9 Boxing/Unboxing и overloading (одно из самых важных мест)**

Правило выбора:

```
widening > boxing > varargs
```

### Пример:

```java
void f(long x) {}
void f(Integer x) {}

f(5); // выбирается f(long) → widening лучше boxing
```

Другой пример:

```java
void f(int... x) {}
void f(Integer x) {}

f(5); // вызывает f(Integer) → boxing лучше varargs
```

---

# **4.2.13.10 Конкатенация строк и boxing**

При конкатенации:

```java
String s = "x=" + 5; // boxing НЕ происходит
```

Используется:

```
StringBuilder.append(int)
```

Unboxing/boxing выполняется только если требуется.

---

# **4.2.13.11 Сравнение boxed-типов: правила и ловушки**

### `==` сравнивает ссылки:

```java
Integer a = 1000;
Integer b = 1000;

a == b  // false
```

### `equals` сравнивает значение:

```java
a.equals(b) // true
```

### По IEEE 754:

```java
Double.NaN.equals(Double.NaN) // true
Double.NaN == Double.NaN      // false
```

### -0.0 и +0.0

```java
new Double(-0.0).equals(0.0) // false
```

---

# **4.2.13.12 Автоупаковка в коллекциях**

Generics требуют объекты, поэтому каждый примитив автоматически упаковуется:

```java
List<Integer> list = List.of(1, 2, 3);  // 3 boxing-операции
```

В циклах это может быть дорогим:

```java
for (int i : list) { ... } // unboxing при каждой итерации
```

---

# **4.2.13.13 Производительность: стоимость boxing/unboxing**

Boxing включает:

- выделение объекта в heap
    
- запись в TLAB
    
- увеличение давления на GC
    
- иногда escape analysis не может устранить объект
    

Unboxing:

- чтение из heap
    
- проверка на null
    
- потенциальный NPE
    

Поэтому:

- внутри tight loops → **избегать boxed**
    
- использовать `int` вместо `Integer` в hotpath
    
- использовать примитивные коллекции (fastutil, HPPC, Trove)
    

---

# **4.2.13.14 Типичные ошибки**

- сравнение через `==` вместо `.equals()`
    
- хранение `null` в boxed типе без проверки → NPE
    
- ненужный boxing в коллекциях
    
- путаница в перегрузках
    
- использование boxed-типов в качестве ключей без учёта разницы ±0.0, NaN
    
- работа с автогенерацией boxed в циклах
    

---

# **4.2.13.15 Практические рекомендации**

- Используйте примитивы, когда это возможно.
    
- Избегайте boxed-типов в горячих циклах и критических участках.
    
- Всегда учитывайте кэширование wrapper’ов.
    
- Для сравнения значений используйте `.equals()`.
    
- Никогда не доверяйте boxed-значениям быть non-null.
    
- В overloaded-методах учитывайте правило:  
    **widening > boxing > varargs**
    
- Используйте примитивные специализированные коллекции для высокопроизводительных задач.
    

---

# **4.2.13.16 Мини-схема**

```
4.2.13 Boxing and Unboxing
    ├─ определения (boxing / unboxing)
    ├─ соответствия primitive ↔ wrapper
    ├─ примеры
    ├─ NPE при unboxing
    ├─ кэширование wrapper'ов
    ├─ цепочки преобразований
    ├─ overloading: widening > boxing > varargs
    ├─ сравнение boxed-типов
    ├─ влияние на производительность
    ├─ ошибки
    └─ рекомендации
```

---

Раздел полностью готов.  
Могу подготовить следующий: **4.2.14 String Conversion**, **4.2.15 Assignment Context**, **4.3 Reference Types**, или любой другой из JLS.