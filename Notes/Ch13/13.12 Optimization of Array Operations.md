2025-11-04 13:11
Tags: #


### 13.12.1 Copy (arraycopy / copyOf / clone)

- Семантика, производительность, перекрытия и исключения.
    
- Примеры уже есть; оставь как основной материал.
    

### 13.12.2 Sort & Search _(дописать)_

- `Arrays.sort` (объектные: Timsort, стабильность; примитивные: Dual-Pivot Quicksort, нестабильность).
    
- `Arrays.parallelSort` — когда выгодно/когда нет (размеры, нагрузка).
    
- `Arrays.binarySearch` — предикаты корректности: отсортированность, контракт `Comparator`.
    
- Типичные ошибки: несогласованный `compareTo`/`Comparator`, сортировка частичного диапазона без учёта поиска.
    

### 13.12.3 Multidimensional & Layout

- Зубчатые массивы vs плоский буфер + ручная индексация; кэш-локальность.
    
- Пример индексирования `row*cols + col`.
    

### 13.12.4 Zero-length & Pooling

- `new T[0]` как sentinel; влияние на аллокации/GC; когда лучше `Collections.emptyXxx()`.
    
- Пулы буферов (осторожно с владением/утечками).
    

### 13.12.5 Micro-optimizations & JIT notes

- Bounds-check hoisting, unrolling (с оговорками), когда цикл быстрее `arraycopy` (редко), hot-spot измерения (JMH).

## 1. Копирование массивов

### 1.1 `System.arraycopy`

**Определение (JDK):**

> `public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`

- Выполняет **быстрое побитовое копирование** (на уровне JVM / native-кода).
    
- Типы `src` и `dest` должны быть **совместимыми массивами**.
    
- Если копирование областей перекрывается, результат определён только если `src == dest`.
    

#### Пример (корректный)

```java
int[] src = {1,2,3,4,5};
int[] dest = new int[5];
System.arraycopy(src, 0, dest, 0, src.length);
```

#### Ошибочные

```java
// Ошибка 1
int[] src = {1,2,3};
String[] dst = new String[3];
System.arraycopy(src,0,dst,0,3); // runtime: ArrayStoreException

// Ошибка 2
int[] data = {1,2,3};
System.arraycopy(data, 0, data, 2, 5); // runtime: IndexOutOfBoundsException
```

#### Подводные камни

- Нет автоматической проверки совпадения компонентного типа при compile-time.
    
- Возможен `ArrayStoreException` при несоответствии типов.
    
- Возможен `IndexOutOfBoundsException` при неверных индексах.
    

---

### 1.2 `Arrays.copyOf` и `Arrays.copyOfRange`

Используют `System.arraycopy` внутри, но безопаснее и возвращают новый массив требуемого типа.

```java
int[] extended = Arrays.copyOf(original, original.length * 2);
String[] sub = Arrays.copyOfRange(names, 1, 4);
```

---

### 1.3 `clone()` против `System.arraycopy`

|Метод|Поведение|Особенности|
|---|---|---|
|`clone()`|поверхностная копия|тип массива сохраняется|
|`System.arraycopy`|копия части массива|можно копировать диапазон, тип проверяется в runtime|
|`Arrays.copyOf`|новая копия заданной длины|безопасный generic-вариант|

---

## 2. Производительность

- `System.arraycopy` — native-метод JVM, на порядок быстрее ручных циклов.
    
- Для массивов примитивов — максимально быстрый способ.
    
- Для массивов объектов копируются только ссылки, не объекты.
    

### Пример (сравнение)

```java
int[] a = new int[1000000];
int[] b = new int[1000000];

// цикл
for(int i=0;i<a.length;i++) b[i]=a[i];

// оптимально
System.arraycopy(a,0,b,0,a.length);
```

---

## 3. Частичные копии и перестановки

```java
int[] src = {1,2,3,4,5,6,7};
int[] mid = Arrays.copyOfRange(src,2,5); // [3,4,5]

// ротация
System.arraycopy(src, 1, src, 0, src.length - 1);
src[src.length - 1] = -1;
```

---

## 4. Оптимизация многомерных массивов

- JVM хранит многомерные массивы как массивы массивов.
    
- При больших размерах эффективнее работать с линейным одномерным буфером и индексацией вручную:  
    `index = row * columns + col;`.
    

```java
double[] matrix = new double[rows * cols];
double value = matrix[row * cols + col];
```

---

## 5. Потокобезопасность массивов

### 5.1 Общая характеристика

Массивы не потокобезопасны. Доступ из нескольких потоков без синхронизации может вызвать data race.

### 5.2 Решения

|Ситуация|Рекомендация|
|---|---|
|Только чтение|безопасно без синхронизации|
|Параллельная запись|используйте `synchronized`, `ReentrantLock`, или атомарные структуры|
|Частое чтение/редкие изменения|копия-на-запись (`CopyOnWriteArrayList`)|

### 5.3 Примеры

```java
// Пример 1 — безопасное чтение
final int[] table = {1,2,3,4};
Runnable r = () -> System.out.println(table[1]); // безопасно, только чтение

// Пример 2 — небезопасное изменение
int[] shared = new int[2];
new Thread(() -> shared[0] = 42).start();
new Thread(() -> System.out.println(shared[0])).start(); // возможно гонка

// Пример 3 — безопасная замена
volatile int[] safe = new int[2];
safe = Arrays.copyOf(safe, 3); // atomic reference replacement
```

---

## 6. Память и GC-поведение

- Массив — единый объект, хранящий длину + компоненты подряд.
    
- После выделения фиксирован: `int[1_000_000]` ≈ 4 МБ.
    
- GC удаляет массив, когда нет активных ссылок.
    
- Для крупномасштабных систем важно избегать фрагментации: используйте пулы / рециклинг.
    

---

## 7. Типичные ошибки оптимизации

- Замена `System.arraycopy` ручным циклом – почти всегда медленнее.
    
- Перепутанные аргументы в `arraycopy` (srcPos и destPos).
    
- Отсутствие проверки перекрытия областей (особенно при копировании в тот же массив).
    
- Использование `clone()` для глубокого копирования ссылочных элементов.
    
- Несогласованное обновление массива несколькими потоками.
    

---

# Итог

|Категория|Массивы|Коллекции|
|---|---|---|
|Производительность|Выше|Ниже (абстракции)|
|Гибкость|Ниже|Выше|
|Типобезопасность|Частичная (ковариантность)|Полная (generics)|
|Потокобезопасность|Нет|Возможна|
|Изменяемость размера|Нет|Да|
|Применение|Низкоуровневые структуры, буферы, числовые данные|Бизнес-логика, высокоуровневые операции, API|

---

## Рекомендации профессионального уровня

- Используйте **массивы** в горячих участках кода, алгоритмах, числовых вычислениях, буферах и JNI.
    
- Используйте **коллекции** для бизнес-данных, переменных списков, где важна типобезопасность и гибкость.
    
- Для копирования больших объёмов данных используйте **`System.arraycopy`** или **`Arrays.copyOf`**.
    
- Для потокобезопасности — только **иммутабельные массивы** или **атомарная замена** ссылки целиком.
    
- Избегайте смешивания ковариантных массивов с generic-коллекциями — это источник ошибок.
    

---

> **Вывод:**  
> Массив — низкоуровневый инструмент для максимально эффективного хранения и доступа;  
> Коллекции — высокоуровневая абстракция для удобного управления динамическими структурами.  
> Профессионал выбирает осознанно, исходя из требований к памяти, скорости, безопасности и гибкости.
