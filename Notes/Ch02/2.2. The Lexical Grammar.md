2025-10-07 17:46
Tags: #

Лексическая грамматика описывает, как **поток Unicode-символов исходного файла** превращается в **токены**.

Основные вопросы подраздела:

- трёхступенчатая лексическая трансляция: Unicode-escape → нормализация переводов строк → выделение токенов,
    
- правило _longest match_ и его влияние на распознавание операторов,
    
- поддержка кодировок исходных файлов и практические последствия,
    
- классификация токенов: идентификаторы (включая Unicode и правила JavaIdentifierStart/Part), ключевые слова, restricted identifiers, литералы всех типов, операторы, разделители,
    
- примеры типичных ошибок с кодировками, escape-последовательностями и смежными символами `>` в обобщениях.
    

Для программиста этот материал важен при диагностике ошибок лексики, особенно связанных с кодировкой файлов и с неправильным использованием escape-последовательностей или разделителей.

## 1. Роль лексической грамматики

Лексическая грамматика описывает, как поток исходных символов Java превращается в **токены** — минимальные синтаксические единицы, используемые синтаксической грамматикой.

> **Целевой символ лексической грамматики — `Input`.**  
> Лексическая грамматика включает правила для:
> 
> - комментариев и пробелов,
>     
> - идентификаторов,
>     
> - ключевых слов,
>     
> - литералов,
>     
> - операторов и разделителей.
>     

---

## 2. Фазы лексической трансляции

### 2.1 Трёхступенчатый процесс

1. **Обработка Unicode-escape:**  
    Последовательности `\uXXXX` (где `XXXX` — 4 шестнадцатеричные цифры) преобразуются в соответствующие UTF-16 code units.  
    Допустимы повторяющиеся `u`:
    
    ```java
    char c = '\uuuuu0041'; // корректно, эквивалентно 'A'
    ```
    
2. **Нормализация строк:**  
    Разные окончания строк (CR, LF, CRLF) приводятся к стандартным _line terminators_.
    
3. **Разделение на входные элементы:**  
    Поток символов делится на пробелы, комментарии и токены.  
    Пробелы и комментарии отбрасываются; токены поступают в синтаксический анализ.
    

---

### 2.2 Важные замечания

- **Обработка Unicode-escape выполняется до токенизации.**  
    Поэтому даже внутри комментариев и строковых литералов `\uXXXX` может быть интерпретирован как символ.
    
- **Кодировка исходного файла:**  
    Исходник должен быть представлен в допустимой кодировке (по умолчанию UTF-8 или платформенной), либо указана явно:
    
    ```bash
    javac -encoding UTF-8 MyClass.java
    ```
    
- **Символы вне ASCII:**  
    Допускаются в идентификаторах, строках и комментариях, но ключевые слова, операторы и разделители должны быть ASCII-символами (или образованы их Unicode-эквивалентами).
    

---

## 3. Правило «longest match»

Лексический анализатор всегда выбирает **самый длинный допустимый токен**, начиная с текущей позиции.

### Пример:

```java
int a--b;  // токены: a, --, b
int a- -b; // токены: a, -, -b
```

> Без пробела `--` считается унарным декрементом.  
> Чтобы получить два минуса подряд, их нужно разделять пробелом.

---

## 4. Категории токенов

### 4.1 Идентификаторы

Идентификаторы формируются по правилам:

- Начинаются с `JavaIdentifierStart`,
    
- Последующие символы — `JavaIdentifierPart`.
    

Допустимы буквы других алфавитов, цифры (не на первой позиции), символ `_`, символы валют.

**Примеры:**

```java
int имя = 5;
double π = 3.14;
```

---

### 4.2 Ключевые слова

Фиксированный набор зарезервированных слов, которые нельзя использовать как идентификаторы.

Примеры (Java 23):

```
abstract, assert, boolean, break, case, class, ...
```

**Restricted identifiers** — ключевые только в определённом контексте, например:

```
yield, record, sealed, var
```

---

### 4.3 Литералы

Включают:

- **Целочисленные:** десятичные, шестнадцатеричные (`0x`), двоичные (`0b`), восьмеричные (префикс `0`), поддержка суффиксов `L`/`l` и разделителей `_`.
    
- **Вещественные:** десятичные и в научной нотации, суффиксы `f`, `d`.
    
- **Логические:** `true`, `false`.
    
- **Символьные:** `'A'`, с escape-последовательностями.
    
- **Строковые:** `"Hello"`, **Text Blocks** `""" ... """`.
    
- **null-литерал:** `null`.
    

**Примеры:**

```java
int bin = 0b1010;
long big = 1_000_000L;
String text = """
Multi-line
text block
""";
```

---

### 4.4 Операторы и разделители

Включают все стандартные операторы (`+`, `-`, `*`, `/`, `>>`, `>>>`, `&&`, `||`, `::` и др.) и разделители (`;`, `,`, `()`, `{}`, `[]`).

---

## 5. Типичные ошибки и подводные камни

### 5.1 Unicode-escape

```java
// Ошибка: неполный эскейп
char c = '\u004'; // ERROR
```

---

### 5.2 Правило longest match

```java
int x = a--b; // ERROR: нет подходящего разделителя
```

---

### 5.3 Ограничения идентификаторов

```java
int class = 5; // ERROR: 'class' зарезервировано
```

---

### 5.4 Кодировка исходного файла

Ошибки компиляции или искажённые символы при несоответствии кодировки файла и параметра компилятора `-encoding`.

---

## 6. Практика для программистов

- Всегда задавайте правильную кодировку при компиляции.
    
- Не полагайтесь на неявные преобразования Unicode-escape.
    
- Разделяйте потенциально конфликтующие токены пробелами.
    
- Проверяйте IDE и линтеры на предмет подсветки некорректных escape-последовательностей.
    

---

## 7. Схема обработки исходного файла

```
Исходный текст (Unicode)
   ↓ (1) Обработка \uXXXX
Поток символов
   ↓ (2) Нормализация переводов строк
Нормализованный поток
   ↓ (3) Лексический анализ (longest match)
Токены → передаются в синтаксический анализ
```

---

## 8. Ссылки на первоисточники

- [JLS §2.2 — The Lexical Grammar](https://docs.oracle.com/javase/specs/jls/se23/html/jls-2.html)
    
- [JLS §3 — Lexical Structure](https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html)
    
- [JLS §3.10 — Literals](https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-3.10)
    

---

Хотите, чтобы я сгенерировал файл **`2.2. The Lexical Grammar.md`** с этим содержанием для загрузки?
