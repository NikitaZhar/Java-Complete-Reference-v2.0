2025-10-29 19:25
Tags: #DataBinding #Jackson #ObjectMapper #ObjectReader #ObjectWriter #Generics #NullPointer #TypeReference #JsonParseException #JsonMappingException

## Что такое Data Binding
`Data Binding` — это механизм автоматического преобразования данных между `JSON` и Java объектами.
`Jackson` делает это с высокой производительностью и при минимальной конфигурации.

## Основная идея
- `JSON` → `Parsing` → `Mapping` → `Java Object`
- `Java Object` → `Serialization` → `JSON`

Вся эта логика управляется `ObjectMapper`, который по сути является "двигателем `Jackson`".
`ObjectMapper` оперирует на двух уровнях:
- на уровне `ObjectReader` (чтение и десериализация)
- на уровне `ObjectWriter` (запись и сериализация)

## 58.3.2.1. ObjectMapper — центральный класс Jackson
### Основные задачи
- Сериализация Java объекта в `JSON`
- Десериализация `JSON` в Java объект
- Работа с деревом `JsonNode`
- Настройка модулей, аннотаций, стратегий именования
- Обработка исключений и ошибок

```java
ObjectMapper mapper = new ObjectMapper();

// JSON → Java
User user = mapper.readValue(jsonString, User.class);

// Java → JSON
String jsonOutput = mapper.writeValueAsString(user);
```

### Важно
- `ObjectMapper` потокобезопасен, если после конфигурации не изменяется.
- Нельзя создавать новый `ObjectMapper` для каждого запроса – это антипаттерн.

### Рекомендуется

```java
public class JsonUtil {
    public static final ObjectMapper MAPPER = new ObjectMapper();
}
```

## 58.3.2.2. ObjectReader и ObjectWriter — оптимизированные версии
`ObjectMapper` создает читателей и писателей, позволяя:
- повторно использовать настройки
- избегать повторных вычислений
- улучшить производительность

### ObjectReader (десериализация)
```java
ObjectReader reader = mapper.readerFor(User.class);
User user = reader.readValue(jsonString);
```

`Reader immutable` и потокобезопасен.
### ObjectWriter (сериализация)
```java
ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter();
String json = writer.writeValueAsString(user);
```

`Writer` хранит преднастроенную конфигурацию для форматирования, включения/исключения полей и т.д.
- `ObjectReader`/`ObjectWriter` **иммутабельны и потокобезопасны**; создайте один раз и переиспользуйте.
- Для больших массивов используйте потоковое чтение (см. 58.3.7 `readValues`).

## 58.3.2.3. Виды Data Binding

| Тип             | Описание                                   | Пример                                           |
| --------------- | ------------------------------------------ | ------------------------------------------------ |
| Simple Binding  | Привязка к стандартным типам Java          | `String`, `List<Integer>`, `Map<String, Object>` |
| Full Binding    | Привязка к пользовательским классам (POJO) | `User.class`, `Order.class`                      |
| Generic Binding | Привязка к типам с обобщениями             | `new TypeReference<List<User>>() {}`             |

## 58.3.2.4. Основной рабочий цикл Data Binding
### JSON → Java (десериализация)
```java
String json = "{\"id\":1,\"name\":\"Alice\"}";
User user = mapper.readValue(json, User.class);
```

### Java → JSON (сериализация)
```java
String jsonOut = mapper.writeValueAsString(user);
```

## 58.3.2.5. Типичные сценарии и edge cases
### Пример: JSON содержит лишнее поле
```java
String json = "{\"id\":1, \"name\":\"Alice\", \"unknown\":true}";
```

По умолчанию: `UnrecognizedPropertyException`.

Решение
```java
mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
```

### Пример: Отсутствует обязательное поле → NullPointer
```java
class User {
    public String name;
    public int age;
}
String json = "{\"name\":\"Bob\"}";
User user = mapper.readValue(json, User.class); // age = 0
```

Для контроля
```java
mapper.enable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES);
```

### Обработка вложенных объектов и списков
```java
class Order {
    public int id;
    public List<Item> items;
}
Order order = mapper.readValue(json, Order.class);
```

Jackson автоматически рекурсивно связывает вложенные структуры.

## 58.3.2.6. Работа с Generics и TypeReference
```java
String json = "[{\"name\":\"Alice\"},{\"name\":\"Bob\"}]";

List<User> users = mapper.readValue(json, new TypeReference<List<User>>() {});
```

Нельзя использовать `List<User>.class` – из-за стирания типов.
### Сложные generics и карты коллекций
```java
TypeReference<Map<String, List<User>>> type =
    new TypeReference<>() {};
Map<String, List<User>> data = mapper.readValue(json, type);
```

Используйте `TypeReference` для любых вложенных коллекций/карт — стирание типов иначе помешает корректной десериализации.

## 58.3.2.7. Исключения и обработка ошибок

| Исключение                   | Значение                             |
| ---------------------------- | ------------------------------------ |
| `JsonParseException`         | Ошибка синтаксиса JSON               |
| `JsonMappingException`       | Ошибка при маппинге на Java класс    |
| `MismatchedInputException`   | Несоответствие типа данных           |
| `InvalidDefinitionException` | Класс не имеет конструктора/сеттеров |

Рекомендуется использовать try/catch с логированием:
```java
try {
    User user = mapper.readValue(json, User.class);
} catch (JsonProcessingException e) {
    // Лог, конкретное действие
}
```

### Расширенная иерархия ошибок
- `DatabindException` — базовый для `bind`-ошибок.
- `UnrecognizedPropertyException` — лишние поля (если включён строгий режим).    
- `ValueInstantiationException` — ошибка вызова конструктора/builder.  
    **Рецепт:** не гасите исключения; логируйте вход и путь к полю (`getPath()`).

## 58.3.2.8. Выводы и практические рекомендации
- `ObjectMapper` — основа `Jackson`: он направляет потоки JSON данных и управляет всем процессом.
- Используйте `ObjectReader/ObjectWriter`, если требуется повторная сериализация с одной конфигурацией.
- Не создавайте `ObjectMapper` каждый раз — используйте `Singleton/DI` контейнер.
- Корректно обрабатывайте ошибки, не подавляйте исключения `silent`-режимом.
- Понимание `data binding` — ключ к безопасной, предсказуемой сериализации.
