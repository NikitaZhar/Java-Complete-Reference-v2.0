2025-11-25 18:39
Tags: #promotion #conversion #toFormat 


Java определяет строгую систему преобразований примитивных типов.  
Эти правила гарантируют переносимость, предсказуемость и совместимость вычислений во всех JVM.

Преобразования применяются в выражениях, присваиваниях, вызовах методов, сравнении, тернарных операциях, арифметике и работе с boxed-типами.

---

# **4.2.12.1 Классификация преобразований (JLS §5.0)**

Java определяет следующие виды преобразований:

1. **Identity Conversion**
    
2. **Widening Primitive Conversion**
    
3. **Narrowing Primitive Conversion**
    
4. **Boxing Conversion**
    
5. **Unboxing Conversion**
    
6. **Widening + Boxing / Unboxing + Widening**
    
7. **String Conversion**
    
8. **Constant Conversion (compile-time)**
    

Reference conversions (widening/narrowing reference, capture, unchecked) не относятся к примитивам и здесь не рассматриваются.

---

# **4.2.12.2 Widening Primitive Conversion (JLS §5.1.2)**

Безопасные конверсии, которые **не требуют приведения** и (почти всегда) не теряют данных.

## Допустимые направления:

```
byte   → short → int → long → float → double
short  → int → long → float → double
char   → int → long → float → double
int    → long → float → double
long   → float → double
float  → double
```

## Пример:

```java
byte b = 10;
int x = b;       // OK
double d = x;    // OK
```

## Возможная потеря точности при widening:

```java
int v = 16777217;  // 2^24 + 1
float f = v;       // округление → 1.6777216E7
```

---

# **4.2.12.3 Narrowing Primitive Conversion (JLS §5.1.3)**

Требуют явного `cast` и могут терять данные.

## Основные направления:

```
double → float
float  → long → int → short → byte
long   → int → short → byte
int    → char
```

## Примеры:

```java
int x = 130;
byte b = (byte) x; // -126 — усечение битов
```

```java
double d = 1e40;
float f = (float) d; // Infinity
```

---

# **4.2.12.4 Narrowing with Compile-Time Constants**

Если значение — **compile-time constant** и **вписывается в диапазон**, narrowing разрешён без ошибок:

```java
final int x = 100;
byte b = x; // OK
```

Но:

```java
int y = 100;
byte b = y; // ошибка
```

**Constant folding** выполняется до проверки диапазона:

```java
int n = Integer.MAX_VALUE + 1;  // overflow при компиляции
// n = -2147483648
```

---

# **4.2.12.5 Numeric Contexts (JLS §5.4)**

_(формальное дополнение к Promotions)_

Java определяет **три** числовых контекста:

## **4.2.12.5.1 Unary Numeric Context**

Применяется к `+`, `-`, `~`:

- byte, short, char → **int**
    
- остальное без изменений
    

```java
byte b = 5;
int r = -b;
```

---

## **4.2.12.5.2 Binary Numeric Context**

Применяется в операциях: `+ - * / %`, сравнении, &, |, ^ (для чисел).

Результат:

1. double
    
2. float
    
3. long
    
4. int
    

```java
char c = 'A';
short s = 5;
int r = c + s; // int
```

---

## **4.2.12.5.3 Conditional (Ternary) Numeric Context**

Тип выражений `a ? b : c` определяется:

- бинарной numeric promotion
    
- либо общим супертипом (`int` vs `long`, `float` vs `double`)
    

```java
double x = true ? 1 : 1.0; // double
```

---

# **4.2.12.6 Boolean Conversions**

`boolean` **не участвует** ни в widening, ни в narrowing преобразованиях.

```java
(int) true;      // ошибка
(boolean) 1;     // ошибка
```

---

# **4.2.12.7 Boxing и Unboxing (JLS §5.1.7–5.1.8)**

## Boxing:

```
int → Integer
char → Character
boolean → Boolean
(и т.д.)
```

```java
Integer x = 5;
```

## Unboxing:

```java
Integer x = null;
int n = x; // NPE
```

---

# **4.2.12.8 Combined Conversions**

Java допускает:

- widening → boxing
    
- unboxing → widening
    

но не:

- narrowing → boxing
    
- boxing → narrowing
    

### Пример:

```java
int x = 5;
Double d = x; // int → double → Double
```

---

# **4.2.12.9 Conversions in Method Invocation (JLS §5.3)**

Иерархия выбора перегрузки:

1. **Identity**
    
2. **Widening primitive**
    
3. **Boxing**
    
4. **Varargs**
    

```java
void f(double d){}
void f(Integer i){}

f(5); // вызывает f(double), widening > boxing
```

---

# **4.2.12.10 Conversions in Assignment Context (JLS §5.2)**

Присваивание применяет:

- identity
    
- widening
    
- boxing / unboxing
    
- widening + boxing
    
- unboxing + widening
    

```java
Number n = 5; // int → Integer → Number
```

---

# **4.2.12.11 Conversions in Numeric Context (JLS §5.4)**

Применяются при:

- арифметике
    
- битовых операциях
    
- сравнении
    
- тернарном операторе
    

---

# **4.2.12.12 String Conversions**

Происходят при конкатенации:

```java
String s = "x=" + 5;  // 5 → "5"
```

Это применяется рекурсивно для boxed-типов, null → "null".

---

# **4.2.12.13 Поведение при исключениях**

- narrowing **не бросает** исключений
    
- IEEE 754 операции не бросают исключения
    
- unboxing null → NPE
    
- `(int) Double.NaN → 0`
    
- `(int) Infinity → Integer.MAX_VALUE`
    

---

# **4.2.12.14 Таблица допустимых widening-конверсий**

```
              byte short char  int  long float double
byte           ✔     ✔     ✘    ✔    ✔    ✔      ✔
short          ✘     ✔     ✘    ✔    ✔    ✔      ✔
char           ✘     ✘     ✔    ✔    ✔    ✔      ✔
int            ✘     ✘     ✘    ✔    ✔    ✔      ✔
long           ✘     ✘     ✘    ✘    ✔    ✔      ✔
float          ✘     ✘     ✘    ✘    ✘    ✔      ✔
double         ✘     ✘     ✘    ✘    ✘    ✘      ✔
```

✔ — допустимо  
✘ — требует cast (narrowing)

---

# **4.2.12.15 Типичные ошибки**

- ожидание, что narrowing выполняется безопасно
    
- сравнение float/double после promotions
    
- `char + short → int`
    
- использование boxed-типов в `==`
    
- потеря точности при unboxing+widening
    
- NPE при автоконверсии `Boolean → boolean`
    
- неверное понимание приоритетов перегрузки (widening > boxing > varargs)
    

---

# **4.2.12.16 Практические рекомендации**

- Избегать смешивания `int`/`long` с float/double без явного замысла.
    
- Избегать narrowing, особенно “тихого” после операций.
    
- В overloaded-методах помнить правило:  
    **widening > boxing > varargs**.
    
- Не полагаться на автоконверсии в safety-critical коде.
    
- Использовать `BigDecimal` для финансовых расчётов.
    
- Явно контролировать типы в тернарных выражениях.
    

---

# **4.2.12.17 Мини-схема**

```
4.2.12 Promotions and Conversions
    ├─ Widening Primitive
    ├─ Narrowing Primitive
    ├─ Constants-based narrowing
    ├─ Numeric Contexts:
    │     ├─ unary
    │     ├─ binary
    │     └─ ternary
    ├─ Boxing / Unboxing
    ├─ Combined conversions
    ├─ Assignment conversions
    ├─ Method invocation conversions
    ├─ String conversion
    ├─ Exception behavior
    ├─ Conversion table
    ├─ Pitfalls
    └─ Recommendations
```
