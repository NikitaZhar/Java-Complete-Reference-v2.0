2025-11-04 13:10
Tags: #


- Сохранить таблицу сравнения, критерии выбора, «когда массивы».
    
- Убрать повторы про фиксированный размер/ковариантность (они будут в 13.10).
    
- Оставить практичные куски про `Arrays.asList` (фиксированный размер).

- **Критерии**: размер/гибкость/память/скорость/типобезопасность/параллелизм.
    
- **Таблица** сравнения (оставь твою, без повторов про фиксированный размер/ковариантность — это уже в 13.10).
    
- **Когда выбирать массивы** (горячие циклы, JNI/NIO, фиксированные наборы, внутренние буферы).
    
- **Interop**: `Arrays.asList` = фиксированной длины; boxing/unboxing.


## 1. Общее определение и различия

**JLS §4.3.1:**

> Arrays are a kind of reference type. They are objects (§4.3.1), dynamically created, and may be assigned to variables of type Object.

**Java Collections Framework (JCF):**  
Набор интерфейсов и реализаций (`List`, `Set`, `Map`, `Queue` и др.) из пакета `java.util`, обеспечивающих динамически изменяемые структуры данных.

|Критерий|Массивы|Коллекции|
|---|---|---|
|Тип элемента|Однородный (`T` фиксируется при создании)|Однородный, но тип задаётся generic-параметром|
|Размер|Фиксированный при создании|Динамически изменяемый|
|Производительность|Максимально высокая (минимальные накладные расходы)|Дополнительные накладные расходы на управление структурой|
|Безопасность типов|Частично — ковариантность может привести к ArrayStoreException|Полная при использовании generics|
|Совместимость с JCF|Не реализует `Collection`, но совместим через `Arrays.asList`|Полноценная интеграция|
|Потокобезопасность|Не потокобезопасны (shared mutable state)|Зависит от реализации (`Collections.synchronizedList`, `CopyOnWriteArrayList`)|
|Отражение (`reflection`)|Простое создание через `Array.newInstance`|Сложнее, но гибче (через рефлексию generics или runtime-type tokens)|
|Cloneability / Serializable|Да, реализуют `Cloneable`, `Serializable`|Зависит от конкретной реализации|

---

## 2. Преимущества массивов

1. **Прямая адресация и скорость.**  
    Доступ к элементу осуществляется за O(1) через индекс.  
    Нет накладных расходов на boxing/unboxing и структуру узлов.
    
2. **Предсказуемость памяти.**  
    Массив хранится непрерывно в heap; это ускоряет кеширование CPU и снижает GC-нагрузку.
    
3. **Совместимость с низкоуровневым API.**  
    Нативные интерфейсы (JNI, NIO, I/O-потоки) ожидают именно массивы примитивов.
    
4. **Минимальные накладные расходы GC.**  
    Нет промежуточных объектов (как в LinkedList, HashMap).
    

---

## 3. Недостатки массивов

1. **Фиксированный размер.**  
    После создания длина неизменна — требуется выделение нового массива и копирование данных.
    
2. **Отсутствие типобезопасности при ковариантности.**  
    Пример:
    
    ```java
    Object[] arr = new String[3];
    arr[0] = 10; // runtime: ArrayStoreException
    ```
    
3. **Нет встроенных операций высокого уровня.**  
    Нет методов `add`, `remove`, `contains`, `iterator`. Всё реализуется вручную или через `Arrays` / `System`.
    
4. **Сложности с параллельной работой.**  
    Нет атомарных операций, синхронизацию приходится реализовывать вручную.
    

---

## 4. Когда выбирать массивы

- Работа с большими объёмами числовых данных, требующими максимальной производительности.
    
- Взаимодействие с JNI, NIO, байтовыми буферами.
    
- Хранение неизменяемого набора данных фиксированной длины.
    
- Внутренние буферы при реализации собственных коллекций.
    

### Примеры (корректные)

```java
// Пример 1: эффективный числовой буфер
double[] values = new double[1024];
for(int i=0; i<values.length; i++) values[i] = Math.random();

// Пример 2: использование с NIO
ByteBuffer buf = ByteBuffer.wrap(new byte[256]);

// Пример 3: статический lookup
private static final int[] TABLE = {1,1,2,3,5,8,13};
```

### Примеры (ошибочные)

```java
// Ошибка 1
List<int> nums = new ArrayList<>(); // compile-time: int is not a reference type

// Ошибка 2
int[] data = new int[5];
data = Arrays.copyOf(data, 10); // ок, но создался новый объект; старый не «расширился»
```

### Типичные ошибки

- Попытка использовать `List`-методы (`add`, `remove`) на массиве.
    
- Путаница между `clone()` (поверхностная копия) и `System.arraycopy` (контролируемое копирование).
    
- Непонимание, что `Arrays.asList(arr)` возвращает фиксированный по длине список, связанный с массивом.
    

---

## 5. Преимущества коллекций над массивами

1. **Динамическое изменение размера.**  
    `ArrayList` автоматически расширяет внутренний массив.
    
2. **Типобезопасность через Generics.**  
    `List<String>` предотвращает вставку элементов другого типа на этапе компиляции.
    
3. **Интерфейсы и полиморфизм.**  
    Код можно писать против интерфейса (`List`, `Set`), а не конкретной реализации.
    
4. **Расширенные алгоритмы.**  
    Методы сортировки, фильтрации, потоковые API (`stream()`) встроены в JCF.
    
