2025-09-15 14:05
Tags: #Module 
- `module-info.java`
- Директивы: `requires`, `exports`, `opens`, `uses`, `provides`
## Общие сведения
Модульная система (`Project Jigsaw`) введена в Java 9 добавляет поверх пакетов уровень модульной инкапсуляции. Модуль объединяет пакеты и ресурсы в логическую единицу с явными зависимостями и границами доступа. Основа объявления модуля — файл `module-info.java`, содержащий `module declaration`.

**Всегда доступный модуль:** любой модуль **неявно читает** `java.base`; добавлять `requires java.base;` не требуется.
## Синтаксис объявления модуля
Общая форма:
```java
[open] module ModuleName {
    {requires [static] [transitive] ModuleName;}
    {exports package.name [to ModuleA, ModuleB];}
    {opens package.name [to ModuleA, ModuleB];}
    {uses service.InterfaceName;}
    {provides service.InterfaceName with impl.ClassName[, impl2.ClassName];}
}
```
- `open` — объявляет модуль «открытым»: все пакеты доступны для глубокой рефлексии в рантайме (удобно при миграции со старых фреймворков; снижает инкапсуляцию).
- `module` — начало декларации.
- `ModuleName` — имя модуля; обычно соответствует пространству имён корневого пакета.
- Тело содержит **директивы**: `requires`, `exports`, `opens`, `uses`, `provides … with`.
## Имена модулей
- Имя — последовательность валидных Java-идентификаторов, разделённых точками (рекомендована конвенция обратного домена: `com.example.myapp`).
- Имя модуля не обязано совпадать с именем корневого пакета, но **одно и то же имя пакета не может находиться в разных модулях на** `module-path` (запрет `split package`).

Ошибки именования:

```java
module 123bad { }      // Ошибка: идентификатор не может начинаться с цифры
module com-example { } // Ошибка: недопустимый символ '-'
```

## Файл `module-info.java`
- На модуль приходится **ровно один** `module-info.java`.
- Файл располагается в корне исходников модуля; при компиляции создаётся `module-info.class`.

**Дескриптор модуля** (`module descriptor`): скомпилированный `module-info.class` является дескриптором модуля. В рантайме он доступен через API:
- `Class::getModule` → `java.lang.Module`
- `Module::getDescriptor` → `java.lang.module.ModuleDescriptor` (директивы, зависимости, экспорты и т.п.).

Пример структуры:

```
src/
 └─ com.example.myapp/
     ├─ module-info.java
     └─ com/example/myapp/Main.java
```
## Директивы модуля
### 1) `requires`
Объявляет зависимости модуля от других модулей.

```java
requires ModuleName;                // обязательна на compile- и runtime
requires transitive ModuleName;     // транзитивная читаемость для зависимых модулей
requires static ModuleName;         // нужна на compile-time, опциональна на runtime
```
Семантика читаемости (`read edges`):
- `requires B` добавляет ребро «A читает B».
- `requires transitive B` добавляет ребро «A читает B» **и** делает так, что любой модуль, читающий A, **тоже читает B** (имплицитно).
- Флаг `--add-reads A=B` при запуске может **временно** добавить ребро чтения даже без объявления в `module-info.java`.

**Ограничение комбинаций:** `static` и `transitive` **нельзя** комбинировать в одной директиве — `requires static transitive` недопустимо.
```java
module m {
    requires transitive n;     // OK
    requires static o;         // OK
    requires static transitive p; // compile error
}
```

Особенности:
- `requires static` полезен для зависимостей на аннотации или утилиты разработки. Такой модуль может отсутствовать в `runtime`.
- При `requires transitive` нужно учитывать **консистентность конфигурации**: если два транзитивных модуля экспортируют одинаковые пакеты, конфигурация будет признана некорректной, и приложение не запустится.

Пример:
```java
module com.example.service {
    requires java.sql;
    requires transitive com.example.api;
    requires static lombok;
}
```
Ошибка:
```java
module com.example.bad {
    requires nonexistent.module; // compile error: модуль не найден
}
```
### 2) `exports`

Делает **публичные** типы пакета доступными другим модулям.
```java
exports package.name;
exports package.name to ModuleA, ModuleB; // квалифицированный экспорт
```
- Без `to` пакет виден **всем** читающим модулям.
- С `to` — только перечисленным модулям.
- Можно указывать несколько получателей через запятую:
```java
exports com.example.internal to moduleA, moduleB;
```
- **Дубликаты** экспортов одного и того же пакета — ошибка.
### 3) `opens`
Открывает пакет для **глубокой рефлексии** (доступ к непубличным членам в `runtime`). Аналогично `exports`, существует форма с `to`.
```java
opens package.name;
opens package.name to ModuleA, ModuleB;
```
- Можно указать несколько получателей:
```java
opens com.example.model to frameworkA, frameworkB;
```
- Нужен фреймворкам (`Hibernate/Spring`), которые используют рефлексию.
- `opens` **не делает пакет доступным компилятору** — только `reflective access` в рантайме.
- В Java 9+ `AccessibleObject#setAccessible(true)` уважают модульные границы. **Без `opens`** попытка глубокой рефлексии приводит к `InaccessibleObjectException`.
### 4) `uses`
Объявляет, что модуль использует **сервис** (SPI) через `ServiceLoader`.
```java
uses com.example.spi.PaymentProcessor;
```
- При разрешении сервисов провайдер **должен находиться в конфигурации модулей**. Если модуль-провайдер не разрешён системой, сервис не будет найден.
### 5) `provides … with …`
Заявляет реализацию(ии) сервиса.
```java
provides com.example.spi.PaymentProcessor
    with com.example.impl.PayPalProcessor, com.example.impl.StripeProcessor;
```
- Допускается **несколько** провайдеров.
- Реализация должна находиться в модуле, который включён в конфигурацию.
## Unnamed и Automatic модули
- `Unnamed module` **(безымянный):** всё, что на `classpath`. Видит все модули, но сам невидим.
- `Automatic module`: JAR без `module-info.class` на `module-path`. Имя выводится из `JAR`.  
Рекомендуется указывать `Automatic-Module-Name` в манифесте, иначе имя зависит от JAR-файла и нестабильно.
- Если JAR без `module-info.java` лежит в `module-path`, он становится `automatic module`.
- Имя модуля вычисляется автоматически из имени JAR → нестабильность.
- Рекомендуется явно указывать `Automatic-Module-Name` в `MANIFEST.MF` или добавлять `module-info.java`.
## Модульный API и ModuleLayer
- `Module` и `ModuleDescriptor` дают доступ к информации о модуле.
- Методы `addReads`, `addExports`, `addOpens` позволяют временно ослабить инкапсуляцию (**weak encapsulation**).
- `ModuleLayer` поддерживает изоляцию наборов модулей. Это используется для плагин-систем и контейнеров (создание отдельных слоёв с независимыми зависимостями).
### Особенности JPMS во фреймворках
- Для работы с рефлексией (`Spring, Hibernate, Jackson`) пакеты нужно открывать:
```java
opens com.example.model to org.hibernate.orm.core;
```  
## Аннотации модулей
На модуле можно использовать аннотации (включая `@Deprecated`).
```java
@Deprecated
module old.module {
    exports old.api;
}
```
Компилятор будет предупреждать о зависимости от устаревшего модуля.
## Циклы и add-reads
- Явные циклы `requires` запрещены.    
- Даже если динамически создать цикл через `--add-reads`, это считается нарушением модели и может привести к runtime-ошибкам.
## Тестирование
- `JUnit` 5 использует рефлексию, поэтому часто нужно:
```bash
--add-opens app.module/com.app.internal=org.junit.platform.commons
```
## Модульность и безопасность
`JPMS` усиливает контроль доступа:
- `exports` ограничивает `compile/runtim`e доступ.
- `opens` ограничивает reflective доступ.

Это фактически замещает часть возможностей устаревшего **Security Manager**, обеспечивая контроль доступа на уровне JVM.
## Пакеты и модули (Java 9+)
Модульная система (JPMS):
```java
module com.example.myapp {
    exports com.example.myapp.service;
    requires java.sql;
}
```
## JPMS: qualified exports и opens (Java 9+)
- `exports p;` — экспорт пакета всем модулям.
- `exports p to m1,m2;` — экспорт только указанным модулям (**qualified exports**).
- `opens p;` — открывает пакет для рефлексии.
- `opens p to m;` — открывает пакет только указанному модулю (**qualified opens**).

Не путать с **sealed classes (Java 17)** — это другая возможность.

Пример для Spring/Hibernate:
```java
module com.example.app {
    requires spring.context;
    requires jakarta.persistence;

    exports com.example.app.api;
    opens com.example.app.model to org.hibernate.orm.core;
}
```
Начиная с Java 17, в исходном тексте использовался термин «запечатанные пакеты (sealed packages)» для ограничения использования пакетов другими модулями с помощью конструкций вида:
```java
module com.example.core {
    exports com.example.internal to com.example.app, com.example.tests;
}
```
Фактически это — **qualified exports** на уровне JPMS (Java 9+), а не `«sealed packages»`. Идея: пакет доступен только перечисленным модулям. Это повышает инкапсуляцию и безопасность публичного API модуля.
## Split packages
- Один и тот же пакет в нескольких модулях → **ошибка JPMS**.
- Нельзя иметь `com.example.util` одновременно в `core.jar` и `utils.jar`.
- Решения:
    - объединить код в один модуль,
    - переименовать пакеты.
