2025-11-25 17:33
Tags: #boolean #toFormat 


`boolean` — примитивный логический тип Java.  
Он представляет **булево значение истинности** и может принимать только два значения: `true` и `false`.  
Тип `boolean` **не является числовым**, не участвует в арифметических операциях и не имеет определения размера в JLS.

---

## **4.2.10.1 Официальное определение (JLS)**

Согласно JLS:

- `boolean` — примитивный тип, представляющий **истину/ложь**;
    
- допустимые значения: **только** `true` и `false`;
    
- `boolean` **не участвует** в числовых преобразованиях (widening/narrowing);
    
- единственный допустимый не-`boolean` тип, к которому он может быть приведён/от которого может быть получен — `java.lang.Boolean` (boxing/unboxing).
    

---

## **4.2.10.2 Литералы и область применения**

### Литералы

```java
boolean t = true;
boolean f = false;
```

Других литералов (типа `1`, `0`, `"true"`) для `boolean` **нет**.

### Основные области применения

- условия в `if`, `while`, `do-while`, `for`, `assert`;
    
- результат логических и сравнительных операторов (`<`, `==`, `&&` и т.д.);
    
- логические поля и флаги в моделях/DTO/конфиге;
    
- методы, отвечающие на вопрос типа _да/нет_ (`isEmpty()`, `hasNext()`, `isValid()`).
    

---

## **4.2.10.3 Представление и размер**

JLS **не определяет размер** `boolean`:

- с точки зрения языка — это логический тип, а не бит/байт/слово;
    
- реализация JVM обычно хранит:
    
    - элементы `boolean[]` как 1 байт на элемент,
        
    - локальные переменные/параметры — в слотах, совместимых с `int`.
        

Следствия:

- нельзя опираться на `boolean` как «1 бит» или «точно 1 байт» в переносимом коде;
    
- для компактных битовых структур используют `BitSet`, `int`/`long` с масками или специализированные структуры.
    

---

## **4.2.10.4 Операторы над `boolean`**

### **4.2.10.4.1 Логические операторы (short-circuit)**

- `&&` — логическое И с укороченной оценкой;
    
- `||` — логическое ИЛИ с укороченной оценкой;
    
- `!` — логическое НЕ.
    

```java
boolean a = true;
boolean b = false;

boolean r1 = a && b; // false
boolean r2 = a || b; // true
boolean r3 = !a;     // false
```

**Short-circuit**: правая часть **может не вычисляться**.

```java
boolean safe = (obj != null) && obj.isValid(); // безопасно
```

---

### **4.2.10.4.2 Побитовые операторы для `boolean`**

Для `boolean` допускаются также:

- `&` — логическое И **без** short-circuit;
    
- `|` — логическое ИЛИ **без** short-circuit;
    
- `^` — XOR (исключающее ИЛИ).
    

```java
boolean a = true;
boolean b = false;

boolean r1 = a & b;  // false
boolean r2 = a | b;  // true
boolean r3 = a ^ b;  // true
```

Разница `&&` vs `&`:

```java
boolean r1 = (obj != null) && obj.isValid(); // OK
boolean r2 = (obj != null) & obj.isValid();  // NPE, если obj == null
```

---

### **4.2.10.4.3 Сравнение (`==`, `!=`)**

```java
boolean a = true;
boolean b = false;

boolean r1 = (a == b); // false
boolean r2 = (a != b); // true
```

Сравнение `boolean` с **числом, строкой, char и т.д.** запрещено:

```java
boolean b1 = (true == 1);   // ошибка компиляции
boolean b2 = (false == 0);  // ошибка компиляции
```

---

### **4.2.10.4.4 Тернарный оператор**

`boolean` — естественный тип условия в `?:`:

```java
boolean cond = x > 0;
int r = cond ? 1 : -1;
```

---

## **4.2.10.5 Приоритет операторов (кратко)**

От более высокого к более низкому (важное для `boolean`):

1. `!`
    
2. `&`
    
3. `^`
    
4. `|`
    
5. `&&`
    
6. `||`
    

Рекомендуется **всегда ставить скобки** в сложной логике вместо опоры на приоритет.

---

## **4.2.10.6 Преобразования и promotions**

### Запрещённые преобразования

Следующее — **ошибка компиляции**:

```java
int x = (int) true;   // нельзя
boolean b = (boolean) 1; // нельзя
char c = (char) false;   // нельзя
```

`boolean`:

- **не участвует** в numeric promotion (`+`, `-`, `*`, `/`, `%`);
    
- не может быть приведён к числовым типам/из них напрямую.
    

### Правильный путь для чисел ↔ boolean

Только через явную логику:

```java
boolean b = x != 0;        // int → boolean
int x = b ? 1 : 0;         // boolean → int

boolean flag = "yes".equalsIgnoreCase(s);
```

---

## **4.2.10.7 Автоупаковка и класс `Boolean`**

### Корректное использование

```java
Boolean b1 = Boolean.TRUE;
Boolean b2 = Boolean.FALSE;
Boolean b3 = Boolean.valueOf(true);

boolean x = b1; // auto-unboxing
```

### Опасность: NPE при unboxing

```java
Boolean b = null;
boolean x = b; // NullPointerException
```

### `==` vs `equals` для `Boolean`

```java
Boolean b1 = Boolean.TRUE;
Boolean b2 = Boolean.valueOf(true);

b1 == b2;         // true из-за кэша, но на это лучше не полагаться
b1.equals(b2);    // true — корректный способ
```

Рекомендация:

- для примитивов: `boolean`,
    
- для nullable значений: `Boolean`, сравнение через `Boolean.TRUE.equals(b)`.
    

---

## **4.2.10.8 `boolean` в управляющих конструкциях**

### Допустимо

```java
boolean ok = check();

if (ok) { ... }

while (!queue.isEmpty()) { ... }

for (; !done; ) { ... }

do {
    ...
} while (retry);

assert value >= 0;
```

### Запрещено

Использовать **не-boolean** в условиях:

```java
int x = 1;
if (x) {} // ошибка компиляции (в отличие от C/C++)
```

Также `switch` **не поддерживает** `boolean`:

```java
boolean b = true;
// switch (b) {} // ошибка
```

---

## **4.2.10.9 Типичные ошибочные примеры**

### 4.2.10.9.1 Присваивание вместо сравнения

```java
boolean b = false;

if (b = true) {   // присваивание, а не сравнение
    // всегда выполняется
}
```

Правильно:

```java
if (b == true) { ... }      // допустимо, но многословно
if (b) { ... }              // рекомендованный стиль
if (!b) { ... }             // для отрицания
```

---

### 4.2.10.9.2 Использование `&` вместо `&&`

```java
if (obj != null & obj.isValid()) {  // obj.isValid() всегда выполняется
    ...
}
```

Правильно:

```java
if (obj != null && obj.isValid()) {
    ...
}
```

---

### 4.2.10.9.3 Null `Boolean` и unboxing

```java
Boolean b = getFlag(); // может вернуть null
if (b) {               // auto-unboxing → NPE
    ...
}
```

Правильно:

```java
if (Boolean.TRUE.equals(b)) {
    ...
}
```

---

## **4.2.10.10 Подводные камни**

- Ожидание, что `boolean` — это `0/1` (как в C);
    
- попытка конвертировать `boolean` в int/long/char приведением;
    
- использование `&`/`|` вместо `&&`/`||`;
    
- unboxing `null` из `Boolean`;
    
- использование `Boolean` в критическом по производительности участке вместо `boolean`;
    
- попытка передавать `boolean` в API, ожидающее числовой тип (и наоборот).
    

---

## **4.2.10.11 Практические рекомендации**

- Для логики **всегда** используйте `boolean`, а не `int`/`String`/`0/1`.
    
- Предпочитайте:
    

```java
if (flag) { ... }     // вместо if (flag == true)
if (!flag) { ... }    // вместо if (flag == false)
```

- Для nullable значений используйте `Boolean` и шаблон:  
    `Boolean.TRUE.equals(value)`.
    
- Для составных условий всегда ставьте скобки, не полагайтесь на приоритет.
    
- В публичных API называйте boolean-методы и поля в форме `isXxx`, `hasXxx`, `canXxx`.
    

---

## **4.2.10.12 Мини-схема (для Obsidian Graph)**

```text
4.2.10 boolean
    ├─ примитивный логический тип
    ├─ значения: true / false
    ├─ не числовой, без cast к int/char
    ├─ операторы: !, &&, ||, &, |, ^
    ├─ сравнение: ==, != (только с boolean)
    ├─ wrapper: Boolean (boxing/unboxing)
    ├─ управление: if / while / for / assert
    ├─ нет switch(boolean)
    ├─ подводные камни: &, unboxing null, MIN_VALUE-ошибки из int-мышления
    └─ рекомендации по стилю и применению
```

---

Если хочешь, могу теперь собрать **общую сводку по всем примитивным типам** или сделать **маленький “index” для раздела 4.2** с перекрёстными ссылками между `char`, `boolean`, `int`, `float`, `double`.