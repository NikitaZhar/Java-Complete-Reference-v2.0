2025-11-23 19:45
Tags: #short #toFormat 


## 4.2.3.1 Определение и диапазон

**Формальное определение.**  
`short` — примитивный **16-битный знаковый** целочисленный тип, реализованный в формате _two’s complement_. Диапазон значений:

- минимум: **−32768**
    
- максимум: **32767**
    

Сводная таблица:

|Свойство|Значение|
|---|---|
|Ключевое слово|`short`|
|Разрядность|16 бит|
|Представление|two’s complement (signed)|
|Диапазон|−32768 … 32767|
|Значение по умолчанию|`0` (для полей и элементов массива)|
|Обёртка|`java.lang.Short`|

**Важно:**

- Все целочисленные литералы без суффиксов имеют тип `int`.
    
- Литералов типа `short` не существует — используется сужающее преобразование от `int`.
    

### Корректные примеры

```java
short s1 = 123;           // константа в диапазоне short — ОК
short s2 = (short) 40000; // явное приведение — ОК, но будет переполнение
```

### Ошибочные примеры

```java
short s3 = 40000; 
// Компиляция: error: incompatible types: possible lossy conversion from int to short

int i = 1000;
short s4 = i; 
// error: possible lossy conversion from int to short
```

### Типичные ошибки и подводные камни

- Ожидание, что литерал `123` — уже `short` (на самом деле `int`).
    
- Присваивание `int` → `short` без явного приведения и проверки диапазона.
    
- Использование `short` без необходимости (вместо стандартного `int`).
    

---

## 4.2.3.2 Практическое применение (и почему почти не используется)

На практике `short` — **специализированный тип хранения**, а не рабочий тип для логики или арифметики.

### 4.2.3.2.1 Где `short` действительно уместен

1. **Бинарные протоколы и форматы**  
    Когда спецификация говорит про 2-байтовое поле (`int16`, `uint16`):
    
    - сетевые протоколы;
        
    - файловые форматы (WAV 16-bit PCM, старые бинарные форматы);
        
    - протоколы устройств и встроенных систем.
        
    
    ```java
    short lengthField = in.readShort();               // читаем 2 байта
    int length = Short.toUnsignedInt(lengthField);    // интерпретируем как 0..65535
    ```
    
2. **Очень большие массивы**  
    При миллионах элементов, значения которых гарантированно помещаются в диапазон `short`:
    
    ```java
    short[] heights = new short[100_000_000]; // ~200 МБ вместо ~400 МБ для int[]
    ```
    
3. **JNI и соответствие C-структурам (`int16_t`)**
    
    ```c
    // C
    typedef struct {
        int16_t type;
        uint16_t length;
    } Header;
    ```
    
    ```java
    // Java
    class Header {
        short type;   // signed int16_t
        short length; // для uint16_t + toUnsignedInt при чтении
    }
    ```
    

### 4.2.3.2.2 Почему `short` почти не используется

- Почти все Java-API оперируют `int` (размеры коллекций, индексы, длины).
    
- Арифметика над `short` выполняется как `int` (promotion), **без преимуществ** по скорости.
    
- Экономия памяти **есть только в массивах**; в объектах её почти нет из-за выравнивания.
    
- Диапазон слишком мал для безопасного использования в бизнес-модели и API.
    

### Типичные ошибки и подводные камни

- Использование `short` в сущностях и DTO «для экономии памяти».
    
- Тип `short` для ID, счётчиков, размеров — приводит к переполнениям и искусленным ограничениям.
    
- Использование `short` в публичном API, где клиентам всё равно нужно работать с `int`.
    

---

## 4.2.3.3 Promotion и отсутствие экономии без массива

### 4.2.3.3.1 Numeric promotion

При любых арифметических и многих логических операциях `byte`, `short`, `char` автоматически **продвигаются до `int`**.

Схема:

```text
если есть double → всё в double
иначе если float → всё в float
иначе если long → всё в long
иначе           → всё в int   // сюда попадают byte, short, char
```

#### Пример

```java
short a = 1000;
short b = 2000;
short c = (short) (a + b); // a + b → int, нужен cast

// Ошибочный вариант:
short c2 = a + b; 
// error: possible lossy conversion from int to short
```

### 4.2.3.3.2 Почему нет реальной экономии вне массивов

- Локальные переменные и параметры хранятся в локальных ячейках фрейма, а JIT всё равно использует 32-битные регистры.
    
- Поля объектов часто дополняются паддингом до границ выравнивания (4/8 байт).
    
- **Единственное место**, где `short` даёт ощутимую экономию памяти — **массовые структуры** (`short[]`, `ShortBuffer`, off-heap).
    

### 4.2.3.3.3 Байткод (для понимания цены)

```java
short a = 1, b = 2;
short c = (short) (a + b);
```

Компилируется в:

```text
iload_1   // a
iload_2   // b
iadd      // int-арифметика
i2s       // приведение int → short
istore_3  // c
```

### Типичные ошибки и подводные камни

- Ожидание, что `short` ускорит вычисления или уменьшит нагрузку на CPU.
    
- Забывание про promotion: `short + short` → `int`.
    
- “Оптимизация” всего подряд до `short`/`byte` без профилирования.
    

---

## 4.2.3.4 Переполнение и арифметические ловушки

### 4.2.3.4.1 Переполнение (overflow) и wrap-around

Переполнение для `short` происходит **без исключений** с оборачиванием по модулю 2¹⁶.

```java
short max = 32767;
short overflow = (short) (max + 1); // -32768
```

Это может быть:

- нормальным и ожидаемым (работа с 16-битными регистрами/форматами),
    
- критической ошибкой в бизнес-логике.
    

### 4.2.3.4.2 `s++` vs `s = s + 1`

```java
short s = 0;
s++;        // ОК: компилятор знает, что шаг = 1 и даёт неявный narrowing
s = s + 1;  // error: possible lossy conversion from int to short
```

### 4.2.3.4.3 Бесконечные циклы

Ошибочный пример:

```java
short i = 0;
while (i <= 40000) { // i промотируется к int, 40000 — int
    i++;             // на 32767 → 32768 → -32768 → условие всё ещё true
}
```

В результате — **бесконечный цикл**.

Корректно:

```java
for (int i = 0; i <= 40000; i++) {
    // ...
}
```

### 4.2.3.4.4 Signed vs unsigned

Частая ловушка при работе с протоколами:

```java
short raw = in.readShort();            // читаем 0xFFFF → -1
int len = Short.toUnsignedInt(raw);    // 65535
byte[] data = new byte[len];           // корректно
```

Ошибочный вариант:

```java
byte[] data = new byte[raw]; // NegativeArraySizeException, если raw < 0
```

### Типичные ошибки и подводные камни

- Ожидание `ArithmeticException` при переполнении.
    
- Ошибки в условиях цикла из-за wrap-around.
    
- Перепутанная signed/unsigned интерпретация значений из бинарных потоков.
    

---

## 4.2.3.5 Best practices

### 4.2.3.5.1 Когда `short` использовать

1. **Поля строго 16-битных бинарных форматов и протоколов**
    
    - Документируйте, signed/unsigned ли поле и как оно трактуется.
        
2. **Очень большие массивы, где важна экономия памяти**
    
    - Например, массив высот, плотные таблицы, индексы в пределах диапазона.
        

### 4.2.3.5.2 Когда `short` не использовать

- Счётчики, индексы, размеры — **только `int`**.
    
- Идентификаторы сущностей, номера заказов, бизнес-сущности.
    
- Публичный API, DTO, REST/JSON модели.
    
- Общая арифметика и вычисления.
    

### 4.2.3.5.3 Безопасные шаблоны

**Проверка диапазона при приведении:**

```java
public static short toShortExact(int value) {
    if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
        throw new IllegalArgumentException("Value out of range for short: " + value);
    }
    return (short) value;
}
```

**Безопасное умножение:**

```java
public static short multiplyPercent(short value, short percent) {
    int result = value * percent / 100;
    if (result < Short.MIN_VALUE || result > Short.MAX_VALUE) {
        throw new ArithmeticException("short overflow: " + result);
    }
    return (short) result;
}
```

**Unsigned-обработка:**

```java
short raw = in.readShort();
int code = Short.toUnsignedInt(raw); // 0..65535
```

### Типичные ошибки и подводные камни

- Отсутствие проверки диапазона при `int → short`.
    
- Попытка “навести порядок” и уменьшить память через массовое использование `short`.
    
- Использование `short` в сериализуемых моделях (JSON/XML), где тип всё равно не сохранится.
    

---

## 4.2.3.6 Anti-patterns

### 4.2.3.6.1 “Микрооптимизация” в бизнес-модели

```java
public class Order {
    private short itemCount; // "чтобы меньше памяти занимать"
}
```

Проблемы:

- жёсткое ограничение диапазона;
    
- отсутствие заметной экономии памяти;
    
- ухудшение читаемости и гибкости модели.
    

### 4.2.3.6.2 `short` как счётчик

```java
for (short i = 0; i < 40000; i++) {
    // ...
}
```

Риск переполнения и бесконечного цикла.

### 4.2.3.6.3 “16-битная арифметика”

```java
short a = 200;
short b = 300;
short c = (short) (a * b); // переполнение + бесполезная pseudo-оптимизация
```

Реально всё равно `int`.

### 4.2.3.6.4 `Short` как ID в БД

```java
@Entity
class User {
    @Id
    private Short id;
}
```

- диапазон ID исчерпывается очень быстро;
    
- нет реальной выгоды по памяти;
    
- лишние ограничения на масштабируемость.
    

### 4.2.3.6.5 `short` в DTO/REST моделях

```java
public record UserDto(short age) {}
```

- на стороне клиента тип часто будет обычным числом без ограничений;
    
- типизация `short` добавляет сложности без выгоды.
    

### Типичные ошибки и подводные камни

- Использование `short` “по привычке”, не отталкиваясь от реальных требований.
    
- Преждевременная оптимизация без профилирования и оценки масштабируемости.
    
- Жёсткие ограничения диапазона в моделях (невозможность эволюции).
    

---

## 4.2.3.7 Примеры + разбор

### 4.2.3.7.1 Бинарный протокол (корректный кейс)

**Задача:** прочитать заголовок:

```text
[ magic: uint16 ][ version: uint8 ][ length: uint16 ][ payload... ]
```

**Корректный код:**

```java
public record MessageHeader(
        int magic,       // уже как unsigned
        int version,
        int length       // 0..65535
) {}

public MessageHeader readHeader(DataInput in) throws IOException {
    short magicShort   = in.readShort();
    byte versionByte   = in.readByte();
    short lengthShort  = in.readShort();

    int magic  = Short.toUnsignedInt(magicShort);
    int length = Short.toUnsignedInt(lengthShort);
    int version = Byte.toUnsignedInt(versionByte);

    if (length > MAX_FRAME_SIZE) {
        throw new IOException("Frame too large: " + length);
    }

    return new MessageHeader(magic, version, length);
}
```

**Ошибочный вариант:**

```java
short length = in.readShort();
byte[] payload = new byte[length]; // length может быть отрицательным
// NegativeArraySizeException в рантайме
```

---

### 4.2.3.7.2 Большой массив с экономией памяти

**Корректно:**

```java
class HeightMap {
    private final int width;
    private final int height;
    private final short[] data; // экономим память

    public HeightMap(int width, int height) {
        this.width = width;
        this.height = height;
        this.data = new short[width * height];
    }

    public void setHeight(int x, int y, int value) {
        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {
            throw new IllegalArgumentException("height out of range: " + value);
        }
        data[index(x, y)] = (short) value;
    }

    public int getHeight(int x, int y) {
        return data[index(x, y)];
    }

    private int index(int x, int y) {
        return y * width + x;
    }
}
```

**Антипаттерн:**

- заменять `int` на `short` в одной-двух переменных «для красоты» — смысла нет.
    

---

### 4.2.3.7.3 Безопасная работа с процентами

**Корректно:**

```java
public short applyDiscount(short priceCents, short discountPercent) {
    int result = priceCents * (100 - discountPercent) / 100;
    if (result < Short.MIN_VALUE || result > Short.MAX_VALUE) {
        throw new ArithmeticException("short overflow: " + result);
    }
    return (short) result;
}
```

**Ошибочный вариант:**

```java
public short applyDiscount(short priceCents, short discountPercent) {
    return (short) (priceCents * (100 - discountPercent) / 100);
    // тихое переполнение, если priceCents большой
}
```

---

### 4.2.3.7.4 NIO `ShortBuffer`

**Корректно:**

```java
ByteBuffer bb = ByteBuffer
        .allocate(1024)
        .order(ByteOrder.LITTLE_ENDIAN);

ShortBuffer sb = bb.asShortBuffer();

// пишем значения
for (int i = 0; i < sb.limit(); i++) {
    sb.put(i, (short) i);
}

// читаем
for (int i = 0; i < sb.limit(); i++) {
    short v = sb.get(i);
    // работаем с v
}
```

**Типичный баг:**

- не учитывать `ByteOrder` и получать “перепутанные” байты при обмене с внешней системой.
    

---

### 4.2.3.7.5 JNI и `int16_t`

```c
// native.c
JNIEXPORT jshort JNICALL
Java_NativeLib_getValue(JNIEnv* env, jclass cls) {
    int16_t v = read_sensor(); // 16-битный датчик
    return (jshort) v;
}
```

```java
public class NativeLib {
    static { System.loadLibrary("native"); }

    public static native short getValue();

    public static int getUnsignedValue() {
        return Short.toUnsignedInt(getValue());
    }
}
```

Подводный камень: несогласованный endian или неправильная интерпретация знака.
