2025-11-25 15:00
Tags: #float #toFormat 

`float` — примитивный 32-битный тип Java, реализующий формат **IEEE 754 binary32**.  
Он представляет аппроксимацию действительных чисел с **ограниченной точностью (~6–7 значимых цифр)** и используется в задачах, где крайне важны скорость и экономия памяти.

---

## **4.2.8.1 Формат binary32**

```
┌ sign(1 bit) ┐ ┌ exponent(8 bits) ┐ ┌ fraction(23 bits) ┐
s               eeeeeeee              fffffffffffffffffffffff
```

Значение вычисляется по формулам IEEE 754:

- нормализованная форма
    
- subnormal форма
    
- специальные значения (NaN, ±Infinity, ±0.0)
    

---

## **4.2.8.2 Диапазоны значений**

|Параметр|Значение|
|---|---|
|Максимальное нормализованное|~3.40282347×10³⁸|
|Минимальное нормализованное|~1.17549435×10⁻³⁸|
|Минимальное subnormal|~1.40129846×10⁻⁴⁵|
|Точность|~6–7 десятичных значащих цифр|

---

## **4.2.8.3 Корректные примеры**

```java
float f1 = 1.0f;
float f2 = 3.14f;
float f3 = 1e10f;
float f4 = Float.POSITIVE_INFINITY;
float f5 = Float.NaN;
```

---

## **4.2.8.4 Ошибочные примеры**

```java
float f = 1.23;     // double literal → отсутствует суффикс f
float g = 1e50f;    // overflow → Infinity
boolean b = (0.1f + 0.2f) == 0.3f; // false — ошибка округления
```

---

## **4.2.8.5 Константы Float.MIN_VALUE и частые ошибки**

Критически важно:

```
Float.MIN_VALUE > 0
```

Поскольку это **минимальное положительное subnormal число**.

|Константа|Значение|Семантика|
|---|---|---|
|`Float.MIN_VALUE`|~1.4×10⁻⁴⁵|min positive _subnormal_|
|`Float.MAX_VALUE`|~3.4×10³⁸|max normal|
|`-Float.MAX_VALUE`|~−3.4×10³⁸|min negative normal|
|_нет константы_|—|min negative subnormal|

---

## **4.2.8.6 Canonical NaN и raw NaN payload**

IEEE 754 допускает множество битовых представлений NaN.  
Java:

- `Float.floatToIntBits()` → нормализует NaN к **canonical NaN**
    
- `Float.floatToRawIntBits()` → сохраняет payload без изменений
    

Пример:

```java
float n1 = Float.intBitsToFloat(0x7FC00001);
float n2 = Float.intBitsToFloat(0x7FFFFFFF);

Float.floatToIntBits(n1) == Float.floatToIntBits(n2);        // true (canonical)
Float.floatToRawIntBits(n1) == Float.floatToRawIntBits(n2);  // false
```

Canonical NaN (binary32):

```
0x7FC00000
```

Важно для сериализации и бинарных протоколов.

---

## **4.2.8.7 Overflow и underflow**

### Overflow → Infinity

```java
float a = 1e38f;
float b = a * 1000f; // +Infinity
```

### Underflow → subnormal или 0.0f

```java
float c = 1e-45f * 0.5f; // subnormal
float d = 1e-45f / 10f;  // 0.0f
```

Переполнение **не приводит к wrap-around**, в отличие от int/long.

---

## **4.2.8.8 Особенности сравнения float**

```java
-0.0f == 0.0f                     // true
Float.compare(-0.0f, 0.0f) < 0    // учитывает sign bit
Float.compare(Float.NaN, 1.0f) > 0
```

`Float.compare()` реализует total ordering IEEE 754.

---

## **4.2.8.9 Приведения типов float**

### double → float

(возможен overflow и потеря точности)

```java
float f = (float) 1e100; // Infinity
```

### long → float

Точная репрезентация только до **2²⁴ (≈ 16 777 216)**:

```java
long x = 16777217; // 2^24 + 1
float f = x;       // 1.6777216E7 — округлено
```

### float → int

```java
(int) 3.9f; // 3
```

---

## **4.2.8.10 Подводные камни float**

- быстрый overflow → Infinity
    
- низкая точность (6–7 digits)
    
- subnormal числа медленные
    
- сильные накопленные ошибки округления
    
- нестабильность в длинных вычислительных цепочках
    
- сравнение значений, близких по величине, ненадёжно
    
- точность целых чисел ограничена диапазоном 2²⁴
    

---

## **4.2.8.11 Практические рекомендации**

Использовать `float`, когда:

- важны память и пропускная способность,
    
- ML/нейросети (тензоры, веса),
    
- GPU/kernels/graphics,
    
- работа с мобильными устройствами, сенсорами.
    

**Замечание:**  
В ML и на GPU (CUDA, Vulkan, OpenGL) subnormal-значения часто **принудительно заменяются на 0** (режимы FTZ/DAZ) для повышения производительности.

Не использовать:

- финансовые вычисления,
    
- научная математика, статистика, физика,
    
- криптография,
    
- все задачи, требующие высокой точности.
    

---

## **4.2.8.12 Endianness и бинарная сериализация**

- `DataOutputStream` → big-endian
    
- `ByteBuffer` → endianness выбирается:
    

```java
ByteBuffer bb = ByteBuffer.allocate(4)
    .order(ByteOrder.LITTLE_ENDIAN)
    .putFloat(f);
```

Критично для:

- сетевых протоколов,
    
- бинарных файлов,
    
- взаимодействия с C/C++ и GPU-буферами.
    

---

## **4.2.8.13 Float vs double**

### float:

- 4 байта
    
- быстрее при больших массивах
    
- оптимален для ML/GPU/graphics
    
- точность ограничена
    

### double:

- 8 байт
    
- точнее (≈ 15–16 digits)
    
- часто быстрее на большинстве CPU
    
- предпочтителен почти везде, кроме GPU/ML
    

---

## **4.2.8.14 Мини-схема**

```
float (binary32)
    ├─ формат: 1 + 8 + 23 бит
    ├─ точность: ~6–7 digits
    ├─ точные целые только до 2^24
    ├─ MIN_VALUE = min positive subnormal
    ├─ canonical NaN + raw payload
    ├─ overflow → Infinity
    ├─ underflow → subnormal / 0
    ├─ compare rules (-0.0f < +0.0f, NaN last)
    ├─ numeric conversions (double, long, int)
    ├─ endianness & binary serialization
    ├─ FTZ/DAZ в GPU/ML
    └─ рекомендации по применению
```

---

Раздел полностью завершён и соответствует уровню **профессионального справочника Java**.  
Готов продолжать — могу собрать **4.2.9 double** или всю главу 4.2 целиком.