2025-10-01 15:25
Tags: #main 

В `JLS` примеры иллюстративны: они демонстрируют правило, но не заменяют формальных определений. Здесь — набор компактных примеров/анти-примеров, помогающих интерпретировать текст `JLS`.

### 1.2.1 Минимальная программа и точка входа
Корректно
```java
public class Hello {
	public static void main(String[] args) {
		System.out.println("Hello, JLS!");
	}
}
```

Объяснение: Требуется `public static void main(String[] args)`. Допустимы дополнительные модификаторы вроде `final`.

Анти-примеры
```java
class Hello {                 // ← не public, если файл называется Hello.java — ошибка
    static void main(String[] args) {} // ← not public
}
public class X {
    public static void main(String... a, String... b) {} // ← более одного varargs — ошибка
}
public class Y {
    public static main(String[] args) {} // ← отсутствует тип возвращаемого значения
}
```

### Типичные ошибки и подводные камни
- Несоответствие имени public-класса имени файла компиляции.
- Неверная сигнатура `main` (нет `public`, нет `static`, нет `void`, неверный тип/кардинальность параметров).
- Ожидание вызова `main` при наличии модульной системы/манифестов — реальный запуск определяется `Main-Class` в JAR или параметрами `java`.

### 1.2.2 Пример с пакетами и импортом
```java
package com.example.app;      // объявление пакета
import java.util.List;        // одиночный импорт
import java.util.*;           // импорт пакетов (не импортирует под-пакеты)

// допустимо иметь одно и то же простое имя из разных пакетов — используется полное имя или явный импорт
public class PkgDemo {
    List<String> xs = new java.util.ArrayList<>();
}
```

Анти-примеры
```java
import java.util.List;
import java.awt.*;
// List conflict:
List<java.awt.Point> pts; // ← неоднозначность, если и java.util.*, и java.awt.* импортированы и есть одноимённые типы
```
Как читать правило: _`Ch. 7 Packages and Modules`_ описывает разрешение имён, приоритеты полных имён, локальных объявлений и импортов.

### 1.2.3 Пример модульной декларации (JPMS)
```java
module com.example.lib {
    exports com.example.lib.api;           // экспорт пакета
    opens com.example.lib.internal to com.example.tooling; // рефлексия
    requires transitive java.sql;          // зависимость
    uses com.example.spi.Service;          // потребление сервиса
    provides com.example.spi.Service with com.example.impl.ServiceImpl; // предоставление
}
```
### Подводные камни
- `exports` разрешает **компиляцию и ссылку**, но не гарантирует рефлексию — для неё нужно `opens`.
    
- Автоматические/безымянные модули допускают «старый» classpath, но правила резолюции инициализации отличаются.
    
### 1.2.4 Примеры для лексики

Числовые литералы
```java
int a = 1_000_000;   // допустимы подчёркивания между цифрами
double d = 1_._0;    // ошибка: подчёркивание рядом с десятичной точкой
int b = 0b_1010;     // ошибка: подчёркивание сразу после префикса
```

Строки и текстовые блоки
```java
String s = "line\nnext";
String tb = """
            multi-line
            text block
            """;
```

Комментарии и разделители
```java
int x = 1 /* comment */ + 2; // ok
// Но комментарии не могут разрывать атомарные токены (идентификатор, литерал и т. п.)
```
### 1.2.5 Порядок инициализации классов
Корректно
```java
class InitDemo {
    static int x = initX();
    static { System.out.println("static block"); }

    static int initX() {
        System.out.println("static field initialized");
        return 42;
    }

    public static void main(String[] args) {
        System.out.println("main, x=" + x);
    }
}
```

Вывод при запуске
```
static field initialized
static block
main, x=42
```

> Объяснение:  
> Порядок: инициализация статических полей в порядке объявления → статические блоки → выполнение `main`.

### 1.2.6 Ошибки definite assignment (DA/DU)
Пример с ошибкой компиляции
```java
public class DAExample {
    public static void main(String[] args) {
        int x;
        if (args.length > 0) {
            x = 1;
        }
        System.out.println(x); // error: variable x might not have been initialized
    }
}
```
> Причина: компилятор не может доказать, что `x` присвоено во всех ветках исполнения перед использованием.

Корректный вариант
```java
int x;
if (args.length > 0) {
    x = 1;
} else {
    x = 0;
}
System.out.println(x); // ок
```

### 1.2.7 Примеры с Unicode-эскейпами
Подводный камень
```java
// На первый взгляд это комментарий
// \u000a System.out.println("executed");
```

> До лексического анализа `\u000a` превращается в символ перевода строки, строка после него становится исполняемым кодом.

Ещё пример
```java
int i\u0066 = 5; // идентификатор if (некорректно)
```

> `Unicode`-эскейпы обрабатываются **до токенизации** исходного кода.  
> Это может изменять смысл программы или вызывать ошибки компиляции.

### 1.2.8 Демонстрация запуска модульной программы

Исходный код
`src/com.example.main/module-info.java`
```java
module com.example.main {
    requires com.example.lib;
}
```

`src/com.example.main/com/example/main/Main.java`
```java
package com.example.main;
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello from module!");
    }
}
```

`src/com.example.lib/module-info.java`
```java
module com.example.lib { }
```
Сборка
```bash
javac --module-source-path src -d out $(find src -name "*.java")
```

Запуск
```bash
java --module-path out --module com.example.main/com.example.main.Main
```

> Этот пример демонстрирует практическую связь между `JLS` и модульной системой при компиляции и выполнении.
