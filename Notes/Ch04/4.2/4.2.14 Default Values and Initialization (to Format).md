2025-11-26 13:09
Tags: #defaults #initialization #primitives #Variables #toFormat 

# **4.2.14.1 Default Values: Общая таблица (JLS §4.12.5)**

Все **поля** (static и instance) получают **начальное значение по умолчанию**, если не инициализированы явно.

|Тип|Значение по умолчанию|
|---|---|
|`byte`|`0`|
|`short`|`0`|
|`int`|`0`|
|`long`|`0L`|
|`char`|`'\u0000'`|
|`float`|`0.0f`|
|`double`|`0.0d`|
|`boolean`|`false`|
|Любая ссылка (`String`, `Object`, массивы)|`null`|

---

# **4.2.14.2 Поля: initialization rules**

Поля получают значения:

1. **Статические поля (class variables):**
    
    - сначала default value
        
    - затем static initializers (в порядке объявления)
        
    - затем static blocks
        
2. **Экземплярные поля (instance variables):**
    
    - сначала default value
        
    - затем instance initializers
        
    - затем constructors
        

Гарантия:  
**к моменту начала выполнения тела конструктора все поля уже имеют корректное значение (default или явное).**

### Пример

```java
class A {
    int x;          // default → 0
    String s;       // default → null
}
```

---

# **4.2.14.3 Локальные переменные: нет default values (JLS §4.12.5)**

**Локальные переменные обязаны быть инициализированы явно до использования.**

Такой код — ошибка компиляции:

```java
void f() {
    int x;
    System.out.println(x); // error: variable x might not have been initialized
}
```

Компилятор выполняет **definite assignment analysis (DAA)**.

---

# **4.2.14.4 Final переменные: definite assignment (JLS §4.12.4)**

`final` переменные должны быть **инициализированы ровно 1 раз**, инициализация должна быть:

- явной
    
- и подтверждённой анализом компилятора (DAA)
    

Пример:

```java
final int x;
x = 10; // OK
x = 20; // error
```

В конструкторах:

```java
final int y;

A(boolean flag) {
    if (flag) y = 1;
    else      y = 2; // OK — обе ветки инициализируют
}
```

---

# **4.2.14.5 Статические финальные константы (compile-time constants)**

Если `final static` переменная инициализирована **compile-time constant expression**, то:

- является _constant variable_ (JLS §15.28)
    
- может использоваться в switch labels, annotations, array dimensions
    
- подставляется во все места использования (inlined)
    

Пример:

```java
static final int N = 10; // compile-time constant
```

---

# **4.2.14.6 Initializers и порядок инициализации**

## **4.2.14.6.1 Instance initialization order**

```
1) default values
2) field initializers
3) instance initialization blocks { ... }
4) constructor
```

## **4.2.14.6.2 Static initialization order**

```
1) static default values
2) static field initializers
3) static initialization blocks
```

---

# **4.2.14.7 Инициализация массивов (JLS §10.6)**

Массивы всегда:

- создаются и размещаются в heap
    
- получают значения по умолчанию **для каждого элемента**
    

### Пример:

```java
int[] a = new int[3]; 
// {0, 0, 0}

String[] s = new String[3];
// {null, null, null}
```

---

# **4.2.14.8 Инициализация ссылок**

Любая ссылка получает default value:

```
null
```

Пример:

```java
class A {
    Object o;  // null
}
```

---

# **4.2.14.9 Инициализация для примитивов**

В таблице выше.

Важно: `char` инициализируется:

```java
'\u0000'
```

что не является `'0'`, пробелом или пустой строкой.

---

# **4.2.14.10 Динамическая инициализация и порядок вычисления**

Java гарантирует:

- **лево-направо** порядок вычисления выражений
    
- порядок инициализации полей **строго определён**
    
- статическая инициализация класса выполняется **один раз** при первом использовании класса
    

Пример:

```java
class A {
    static int x = f(); // 1
    static int y = g(); // 2
}
```

---

# **4.2.14.11 Инициализация цикличных ссылок (супер-класс → под-класс)**

Порядок:

```
1) загрузка super-класса
2) static initialization super-класса
3) static initialization sub-класса
4) создание объекта:
    4.1) fields super → initializers super → super constructor
    4.2) fields sub → initializers sub → sub constructor
```

---

# **4.2.14.12 Lazy инициализация**

Не относится к JLS, но важна:

```java
private volatile Helper helper;
Helper getHelper() {
    if (helper == null) {
        synchronized (this) {
            if (helper == null)
                helper = new Helper();
        }
    }
    return helper;
}
```

---

# **4.2.14.13 Типичные ошибки**

- ожидание, что **локальные переменные имеют default value**
    
- использование uninitialized final-полей
    
- забытый `break` в конструкторе → поле может остаться неинициализированным
    
- путаница `'0'` vs `'\u0000'`
    
- зависимость порядка static-инициализации между классами
    
- использование констант `static final` после изменения их значения в байткоде → старые клиенты используют inlined значения
    

---

# **4.2.14.14 Практические рекомендации**

- всегда явно инициализируй локальные переменные
    
- избегай сложной статической инициализации
    
- ограничивай side effects в static blocks
    
- используй final поля, если возможно — они повышают безопасность и упрощают reasoning
    
- знай порядок инициализации super/sub классов
    
- будь осторожен с lazy initialization и concurrency
    

---

# **4.2.14.15 Мини-схема**

```
4.2.14 Default Values and Initialization
    ├─ default values (примитивы + ссылки)
    ├─ initialization of fields
    ├─ initialization of locals
    ├─ final variables & definite assignment
    ├─ compile-time constants
    ├─ static vs instance initialization
    ├─ array initialization
    ├─ super → sub initialization order
    ├─ lazy initialization
    ├─ typical mistakes
    └─ recommendations
```

---

Раздел полностью готов.  
Если хочешь — могу подготовить следующий:  
**4.2.15 Assignment Context**, **4.3 Reference Types**, или **4.2.XX String Conversion**.