2025-11-26 13:26
Tags: #primitives #toFormat 

# **4.2.16.1 Общие принципы**

1. **Используйте примитивы по умолчанию.**  
    Они безопаснее, быстрые, не требуют выделения памяти и не создают проблем с null.
    
2. **Wrapper-классы (`Integer`, `Double`, и т.д.) используйте только при необходимости:**
    
    - generics
        
    - коллекции
        
    - сериализация
        
    - API-требования
        
    - необходимость null-состояний
        
3. **Всегда учитывайте разницу между примитивами и их boxed-версиями:**
    
    - поведение `==`
        
    - возможный NPE при unboxing
        
    - семантика equals
        

---

# **4.2.16.2 Рекомендации для целых чисел (byte/short/int/long)**

## **4.2.16.2.1 int — тип по умолчанию**

Используйте `int`, если диапазон достаточно широкий.  
Только в редких случаях переходите на `long`:

- работа с timestamp
    
- работа с Big Data
    
- расчёт хэшей
    
- арифметика над большими промежуточными значениями
    

## **4.2.16.2.2 избегайте byte/short в арифметике**

В Java:

```
byte + byte → int
short + short → int
```

Это делает их менее полезными.

Используйте `byte`/`short` **только в структурах данных**, а не в вычислениях.

## **4.2.16.2.3 integer overflow должен быть явным**

Используйте:

```java
Math.addExact()
Math.multiplyExact()
```

для критически важных операций.

## **4.2.16.2.4 избегайте сдвигов с непредсказуемым поведением**

Не пишите:

```java
1 << 32
```

Используйте:

```java
1 << (n & 31)
```

---

# **4.2.16.3 Рекомендации для `char`**

- Не используйте `char` как «символ Unicode».  
    Это — **UTF-16 code unit**, работающий с surrogate pairs.
    
- Для реальных символов используйте:
    

```java
int codePoint = s.codePointAt(i);
```

- Для итерации:
    

```java
s.codePoints()
```

- Для подсчёта длины:
    

```java
s.codePointCount(0, s.length())
```

---

# **4.2.16.4 Рекомендации для `boolean`**

- Избегайте boxed `Boolean` там, где не требуется `null`.
    
- В коллекциях применяйте примитивные библиотеки (fastutil, Trove).
    
- Используйте короткие логические операторы:
    

```
&& → short-circuit
|| → short-circuit
```

---

# **4.2.16.5 Рекомендации для `float`/`double`**

## **4.2.16.5.1 double — тип по умолчанию**

Используйте `double` вместо `float`, если:

- нет строгих требований к памяти
    
- нужна точность
    
- требуется стабильность результатов
    
- важна переносимость вычислений
    

## **4.2.16.5.2 float — только в особых случаях**

Применяйте:

- ML-модели
    
- графика, игры
    
- структуры данных высокой плотности
    
- GPU/OpenGL/Vulkan
    

## **4.2.16.5.3 избегайте сравнения float/double через ==**

Используйте:

```java
Math.abs(a - b) < epsilon
```

или `Double.compare()`.

## **4.2.16.5.4 помните про NaN и signed zero**

```java
0.0 == -0.0 // true
Double.compare(0.0, -0.0) // > 0
```

NaN всегда ведёт себя особым образом.

## **4.2.16.5.5 учитывайте неассоциативность**

```java
(a + b) + c != a + (b + c)
```

Особенно в parallel streams.

## **4.2.16.5.6 избегайте subnormal значений в hot-path**

Subnormal:

- медленные
    
- могут уничтожить точность
    

Чаще всего лучше ограничивать значения порогами.

---

# **4.2.16.6 Boxing/Unboxing: практические правила**

- Избегайте autoboxing в циклах и горячих путях исполнения.
    
- Не храните примитивы в `List<Integer>` там, где возможны специализированные структуры.
    
- Не полагайтесь на кэширование Integer/Long вне диапазонов [-128..127].
    
- Всегда проверяйте boxed-значения на null.
    

Опасное выражение:

```java
Integer x = null;
int y = x + 1; // NPE
```

---

# **4.2.16.7 Работа с массивами и коллекциями**

## **4.2.16.7.1 Массивы примитивов предпочтительнее списков**

Если важны:

- скорость
    
- отсутствие GC
    
- отсутствие boxing
    

Используйте:

```java
int[] data;
double[] values;
```

## **4.2.16.7.2 При необходимости nullable значений — переходите к boxed**

Но избегайте коллекций boxed-типа для больших числовых наборов.

---

# **4.2.16.8 Тернарный оператор и подводные камни**

Тернарный оператор может:

- привести к unexpected unboxing
    
- promote выражение к более широкому типу
    
- скрыть ошибку типа
    

Пример:

```java
Integer x = null;
int y = flag ? x : 0; // NPE
```

---

# **4.2.16.9 Неявные преобразования типов**

## 4.2.16.9.1 Избегайте скрытого numeric promotion

```java
int i = 1;
double d = 0.1;
var r = i + d; // double
```

Если важна производительность, приводите явно.

## 4.2.16.9.2 Не допускайте silent narrowing conversions

```java
int x = (int) 1e100; // Infinity → MAX_VALUE
```

## 4.2.16.9.3 Всегда учитывайте правила widening > boxing > varargs

---

# **4.2.16.10 Производительность: GC, CPU, память**

## 4.2.16.10.1 Примитивы быстрее и легче

Боксинг создаёт объекты → вызывает GC → ухудшает locality.

## 4.2.16.10.2 Escape analysis может устранить boxing

Но не всегда:

- если значение уходит в коллекцию
    
- если передаётся в другие методы
    
- если хранится в массиве
    

## 4.2.16.10.3 double быстрее float на многих CPU

Причина: архитектуры оптимизированы под 64-битный формат.

---

# **4.2.16.11 Безопасность и надёжность**

- Всегда проверяйте overflow в финансовых/критических системах.
    
- Избегайте неявного приведения типа при преобразовании из внешних данных.
    
- Будьте внимательны с десериализацией: возможен payload в NaN.
    
- Не допускайте неопределённой публикации final-полей.
    

---

# **4.2.16.12 Когда примитивы нельзя использовать**

Используйте wrapper-классы только если нужно:

- `null` как состояние
    
- сохранение в коллекциях
    
- использование в generic-API
    
- сериализация
    
- атомарные типы: `AtomicInteger`, `AtomicLong`
    

Примитив нельзя сделать volatile/atomic, их надо оборачивать.

---

# **4.2.16.13 Резюме по выбору типов**

|Требование|Рекомендуемый тип|
|---|---|
|Простые числовые вычисления|`int`, `double`|
|Высокая точность|`double`|
|Финансы|`BigDecimal`|
|Огромные массивы|`float`, `int`, `short`, `byte`|
|Практически все общие задачи|`int`, `double`, `boolean`|
|Работа с Unicode|`int` + code points|
|Нужен null|wrapper-класс|

---

# **4.2.16.14 Мини-схема**

```
4.2.16 Practical Usage Guidelines
    ├─ общие принципы
    ├─ правила для целых типов
    ├─ правила для char
    ├─ правила для boolean
    ├─ правила для float/double
    ├─ boxing/unboxing
    ├─ массивы и коллекции
    ├─ тернарный оператор
    ├─ неявные преобразования
    ├─ производительность
    ├─ безопасность
    ├─ выбор типов
    └─ резюме
```

