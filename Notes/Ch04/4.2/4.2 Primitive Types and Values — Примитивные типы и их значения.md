2025-10-20 15:25
Tags: #PrimitiveTypes #Values #toCheck #toFormat 

## [[4.2.0 Overview — Общий обзор примитивных типов (to format)]]
## [[4.2.1 Integral Types — Целочисленные типы (to format)]]
## [[4.2.2 byte (to format)]]



## **4.2.3 short**

4.2.3.1 Определение и диапазон  
4.2.3.2 Практическое применение (и почему почти не используется)  
4.2.3.3 Promotion и отсутствие экономии без массива  
4.2.3.4 Переполнение и арифметические ловушки  
4.2.3.5 Best practices  
4.2.3.6 Anti-patterns  
4.2.3.7 Примеры + разбор

---

## **4.2.4 int**

4.2.4.1 Определение и диапазон  
4.2.4.2 int как стандартный числовой тип в Java  
4.2.4.3 Использование в циклах, индексах, коллекциях  
4.2.4.4 Переполнение и методы `Math.addExact`  
4.2.4.5 Best practices (int по умолчанию)  
4.2.4.6 Anti-patterns (использование int для timestamp, ID)  
4.2.4.7 Примеры

---

## **4.2.5 long**

4.2.5.1 Определение и диапазон  
4.2.5.2 Использование: время, ID, counters > int  
4.2.5.3 Арифметика и overflow  
4.2.5.4 Big values и взаимодействие с unsigned API  
4.2.5.5 Best practices  
4.2.5.6 Anti-patterns  
4.2.5.7 Примеры

---

## **4.2.6 char**

4.2.6.1 Определение и диапазон (`0 … 65535`)  
4.2.6.2 char как целочисленный беззнаковый тип  
4.2.6.3 UTF-16 и суррогатные пары (проблемы)  
4.2.6.4 Ошибки при работе со строками и Unicode  
4.2.6.5 Best practices (использовать int для Unicode code points)  
4.2.6.6 Примеры

---

## **4.2.7 Floating-Point Types — Общие принципы**

4.2.7.1 IEEE 754: формат, знак, порядок, мантисса  
4.2.7.2 Infinity, NaN, +0.0 / -0.0  
4.2.7.3 Потеря точности, денормализованные числа  
4.2.7.4 Почему float/double ≠ математическая арифметика  
4.2.7.5 Best practices  
4.2.7.6 Anti-patterns  
4.2.7.7 Примеры

---

## **4.2.8 float**

4.2.8.1 Диапазон и точность  
4.2.8.2 Назначение (графика, массивы больших объёмов)  
4.2.8.3 Проблемы сравнения  
4.2.8.4 Best practices  
4.2.8.5 Примеры

---

## **4.2.9 double**

4.2.9.1 Стандартный тип с плавающей точкой  
4.2.9.2 Потеря точности  
4.2.9.3 Ошибки сравнения, epsilon  
4.2.9.4 BigDecimal как альтернатива  
4.2.9.5 Примеры

---

## **4.2.10 boolean**

4.2.10.1 Единственный логический тип  
4.2.10.2 Логические операторы и short-circuit  
4.2.10.3 boolean и память (JVM оптимизации)  
4.2.10.4 Boxing и NPE  
4.2.10.5 Примеры

---

## **4.2.11 Operations on Primitive Types — Операции над примитивами**

4.2.11.1 Арифметические операции  
4.2.11.2 Побитовые операции  
4.2.11.3 Операции сравнения  
⚠ ошибки: integer division, operator precedence, overflow  
4.2.11.4 Примеры + правильное применение

---

## **4.2.12 Promotions and Conversions — Преобразования примитивных типов**

4.2.12.1 Widening conversion  
4.2.12.2 Narrowing conversion  
4.2.12.3 Numeric promotions  
4.2.12.4 Таблица допустимых преобразований  
4.2.12.5 Ошибки

---

## **4.2.13 Boxing and Unboxing — Упаковка и распаковка**

4.2.13.1 Wrapper-классы  
4.2.13.2 Автоматическое упаковка/распаковка  
4.2.13.3 Кэширование значений  
4.2.13.4 Ошибки (`NullPointerException`, `==` против `.equals()`)  
4.2.13.5 Примеры

---

## **4.2.14 Primitive Literals — Литералы примитивов**

4.2.14.1 Целочисленные литералы  
4.2.14.2 Литералы с плавающей точкой  
4.2.14.3 Символьные и escape-последовательности  
4.2.14.4 Булевы литералы  
4.2.14.5 Суффиксы `L`, `F`, `D`

---

## **4.2.15 Default Values and Initialization — Значения по умолчанию**

4.2.15.1 Значения по умолчанию для полей  
4.2.15.2 Локальные переменные (не инициализируются)  
4.2.15.3 Таблица значений по умолчанию

---

## **4.2.16 Special Cases and Edge Behavior — Особые случаи и крайние поведения**

4.2.16.1 Underflow и overflow  
4.2.16.2 Denormalized numbers  
4.2.16.3 +0.0 и -0.0  
4.2.16.4 NaN propagation

---

## **4.2.17 Practical Usage Guidelines — Практическое применение и выбор типов**

4.2.17.1 Как выбирать тип по назначению  
4.2.17.2 Типы для производительности  
4.2.17.3 Типы для точности  
4.2.17.4 Типы для экономии памяти

---

## **4.2.18 Performance and JVM Considerations — Производительность и работа JVM**

4.2.18.1 Stack vs Heap  
4.2.18.2 Escape analysis  
4.2.18.3 Auto-boxing overhead  
4.2.18.4 JIT оптимизации

---

## **4.2.19 Summary and Cross-References — Обобщение и связи**

4.2.19.1 Краткое сравнение типов  
4.2.19.2 Табличное резюме  
4.2.19.3 Практические выводы  
4.2.19.4 Связи с Generics, Memory Model, Exceptions

