2025-11-26 13:14
Tags: #primitives #toFormat 

Специальные случаи и поведение на границах — это совокупность особенностей примитивов Java, возникающих при переполнениях, работе со специальными значениями IEEE 754, преобразованиях, сдвигах, обработке NaN, signed zero, особенностях инициализации и работе компилятора и JVM.

Раздел аккумулирует _все_ нетривиальные свойства, которые важно знать для безопасного промышленного программирования.

---

# **4.2.15.1 Integer Overflow (JLS §4.2.2)**

Java использует **двухкомплементарную арифметику** и не генерирует исключений при переполнении.

```java
int x = Integer.MAX_VALUE + 1; // -2147483648
```

То же справедливо для `byte`, `short`, `long`.

Для безопасных вычислений:

```java
Math.addExact()
Math.subtractExact()
Math.multiplyExact()
```

---

# **4.2.15.2 Integer Division vs Floating-Point Division**

## **4.2.15.2.1 Integer division (JLS §15.17.2)**

```java
5 / 2  → 2
-5 / 2 → -2
```

Деление на ноль:

```java
int x = 1 / 0; // ArithmeticException
```

---

## **4.2.15.2.2 Floating-point division (IEEE 754)**

```java
1.0 / 0.0  → +Infinity
-1.0 / 0.0 → -Infinity
0.0 / 0.0  → NaN
```

Никаких исключений.

---

# **4.2.15.3 Signed Zero (IEEE 754, JLS §4.2.3)**

IEEE 754 определяет два нуля:

```
+0.0
-0.0
```

Они **равны**, но отличаются семантически.

```java
0.0 == -0.0                  // true
Double.compare(0.0, -0.0)    // > 0
1.0 / -0.0                   // -Infinity
```

---

# **4.2.15.4 NaN (Not a Number)**

## **4.2.15.4.1 NaN не равен НИЧЕМУ**

```java
Double.NaN == Double.NaN // false
```

## **4.2.15.4.2 любое сравнение → false**

```java
Double.NaN < 1.0  // false
Double.NaN > 1.0  // false
Double.NaN == 1.0 // false
```

## **4.2.15.4.3 правильная проверка**

```java
Double.isNaN(x)
```

---

# **4.2.15.5 Canonical vs Non-canonical NaN**

Java нормализует NaN при:

- `Float.floatToIntBits()`
    
- `Double.doubleToLongBits()`
    

и сохраняет payload через:

- `Float.floatToRawIntBits()`
    
- `Double.doubleToRawLongBits()`
    

Важно для бинарных протоколов и сериализации.

---

# **4.2.15.6 Subnormal Values (Denormals)**

Характеристики:

- уменьшают точность
    
- могут быть **в десятки раз медленнее**
    
- на некоторых CPU существует режим FTZ/DAZ (flush-to-zero / denormals-are-zero)
    

Пример:

```java
float x = 1e-45f; // subnormal
```

---

# **4.2.15.7 Narrowing Truncation и Sign Extension (JLS §5.1.3)**

### `byte`/`short` → `int` — sign-extension

```java
byte b = (byte)0xFF; // -1
int i = b;           // -1, со знаком
```

### `int → char` — маскирование верхних битов

```java
int x = -1;
char c = (char)x; // '\uFFFF'
```

---

# **4.2.15.8 Numeric Promotions: Edge Cases (JLS §5.6)**

### **4.2.15.8.1 char + short → int**

```java
char c = 10;
short s = 20;

var r = c + s; // int
```

### **4.2.15.8.2 Смешивание типов → неожиданные результаты**

```java
int i = 1;
double d = 0.1;
var r = i + d; // double
```

### **4.2.15.8.3 NaN ломает транзитивность**

```java
Double.NaN < -1   // false
-1 < 1            // true
Double.NaN < 1    // false
```

---

# **4.2.15.9 Constant-Folding Overflow (JLS §15.28)**

Переполнение compile-time:

```java
int x = Integer.MAX_VALUE + 1; 
// результат вычисляется на compile-time → -2147483648
```

---

# **4.2.15.10 MIN_VALUE Anomalies**

`Integer.MIN_VALUE == -Integer.MIN_VALUE`

```java
int x = Integer.MIN_VALUE;
int y = -x; // тот же MIN_VALUE
```

То же для `long`, `short`, `byte`.

---

# **4.2.15.11 Casting float/double → int**

По JLS:

- `NaN → 0`
    
- `+∞ → Integer.MAX_VALUE`
    
- `−∞ → Integer.MIN_VALUE`
    

```java
(int) Double.NaN → 0
```

---

# **4.2.15.12 Array Defaults**

Массивы **всегда** заполняются default values:

- числа → 0
    
- boolean → false
    
- char → '\u0000'
    
- ссылки → null
    

---

# **4.2.15.13 Illegal Forward Reference (JLS §8.3.3)**

```java
int y = x + 1; // error
int x = 10;
```

---

# **4.2.15.14 Initialization Order Pitfalls**

- static → super → fields → instance init → constructor
    
- нарушение порядка = неожиданные значения
    

---

# **4.2.15.15 Ternary Operator Edge Cases (JLS §15.25)**

### Примеры:

```java
true ? 1 : 1.0     // 1.0 (double)
false ? 1 : null   // null
```

### Опасный случай:

```java
Integer x = null;
int y = true ? x : 0; // NPE — unboxing
```

---

# **4.2.15.16 String Conversion Edge Case**

```java
String s = "" + null; // "null"
```

Конкатенация строк преобразует `null` → `"null"`, что не соответствует поведению в других контекстах.

---

# **4.2.15.17 Floating-Point Loss of Algebraic Properties (IEEE 754)**

Ни одна из привычных математических аксиом не выполняется гарантированно:

```java
(a + b) + c != a + (b + c)
(a * b) * c != a * (b * c)
(a + b) - b != a
```

Это критично для:

- параллельных вычислений
    
- reduce-операций в Stream API
    
- Big Data систем (Spark, Flink, MapReduce)
    

Даже сортировка с суммированием может зависеть от порядка.

---

# **4.2.15.18 Memory Model Edge Case: Unsafe Publication of Final Fields**

JMM гарантирует корректность final-ициализации **только при корректной публикации**.

Следующий код потенциально опасен:

```java
class A { final int x; A() { x = 42; } }
A a;

new Thread(() -> a = new A()).start();

// может увидеть 0 при неправильной публикации
int v = a.x;
```

Опасности:

- утечка `this` из конструктора
    
- публикация без synchronization/happens-before
    
- использование в многопоточности до завершения конструктора
    

---

# **4.2.15.19 Constant-Folding Side Effects (Compile-Time Infinity/NaN)**

Java вычисляет выражения типа:

```java
double x = 1.0 / 0.0;
```

**на этапе компиляции**, а не выполнения.

То есть division реально не выполняется, а в байткод записывается уже готовое значение `Infinity`.

Это важно для анализа байткода и производительности.

---

# **4.2.15.20 Shift Overflow Semantics (JLS §15.19)**

Сдвиги работают **по модулю разрядной ширины**:

```
int:  shift = n & 0x1F  (mod 32)
long: shift = n & 0x3F  (mod 64)
```

Примеры ловушек:

```java
1 << 32   // 1 << (32 % 32 = 0) → 1
-1 >>> 32 // -1 >>> 0 → -1
```

Это одна из самых частых ошибок в low-level алгоритмах.

---

# **4.2.15.21 Типичные ошибки**

- ожидание, что `1/0.0` бросает исключение
    
- использование `==` для сравнения float/double или boxed
    
- игнорирование signed zero
    
- потеря точности при promotions
    
- неверная работа с MIN_VALUE
    
- NPE в тернарных операциях
    
- reliance на порядок вычисления (он фиксирован, но часто случайно неверно понимается)
    
- недооценка subnormal
    
- ошибки в shift-операциях
    
- утечка `this` и некорректная публикация final-полей
    

---

# **4.2.15.22 Рекомендации**

- избегайте смешанного int/double, если важна точность
    
- всегда проверяйте на NaN через `isNaN`
    
- проверяйте overflow через `addExact()`
    
- избегайте subnormal в hot-paths
    
- используйте `Double.compare`, а не `==`
    
- будьте крайне внимательны со сдвигами
    
- при многопоточности — корректная публикация final-полей
    
- помните про algebraic anomalies floating-point
    

---

# **4.2.15.23 Мини-схема**

```
4.2.15 Special Cases and Edge Behavior
    ├─ integer overflow
    ├─ integer vs fp division
    ├─ signed zero
    ├─ NaN semantics
    ├─ canonical vs raw NaN
    ├─ subnormal values
    ├─ truncation & sign extension
    ├─ numeric promotions
    ├─ constant-fold overflow
    ├─ MIN_VALUE anomalies
    ├─ fp→int casting rules
    ├─ array defaults
    ├─ illegal forward reference
    ├─ initialization pitfalls
    ├─ ternary operator traps
    ├─ string-conversion anomalies
    ├─ fp algebraic non-properties
    ├─ unsafe final-field publication
    ├─ compile-time Infinity/NaN
    ├─ shift wrap-around
    ├─ pitfalls summary
    └─ recommendations
```

---

Раздел полностью завершён.  
Если хочешь — я подготовлю следующий раздел:  
**4.2.16 String Conversion**,  
или можем перейти к **главе 4.3 Reference Types**.