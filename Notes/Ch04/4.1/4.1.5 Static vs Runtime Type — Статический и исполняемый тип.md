2025-10-27 13:45
Tags: #toFormat

4.1.5 Static vs Runtime Type — Статический и исполняемый тип

## **4.1.5.1 Основное различие**

В Java каждый объект или выражение имеет **два уровня типизации**:

|Вид типа|Когда определяется|Кем используется|Роль|
|---|---|---|---|
|**Статический тип (compile-time type)**|На этапе компиляции|Компилятором|Определяет корректность кода и допустимость операций|
|**Исполняемый тип (runtime type)**|Во время выполнения программы|JVM|Определяет фактическое поведение и конкретную реализацию методов|

> Статический тип — это _обещание_, данное компилятору.  
> Исполняемый тип — это _фактическая природа объекта_ во время выполнения.

---

## **4.1.5.2 Статический тип (compile-time type)**

- Является частью исходного кода.
    
- Определяется объявлением переменной, параметра метода или выражения.
    
- Используется компилятором для:
    
    - проверки наличия методов и полей,
        
    - выбора перегруженного метода,
        
    - контроля совместимости типов.
        

```java
Number n = Integer.valueOf(5);
// Статический тип переменной n: Number
```

Переменная `n` на этапе компиляции рассматривается как переменная типа `Number`. Это означает, что компилятор разрешит вызов только тех методов, которые определены в типе `Number`.

---

## **4.1.5.3 Исполняемый тип (runtime type)**

- Это реальный тип объекта, находящегося в памяти JVM.
    
- Может быть подтипом статического типа (полиморфизм).
    
- Определяет, какой метод будет вызван при динамической диспетчеризации.
    

```java
Number n = Integer.valueOf(5);
System.out.println(n.getClass()); // Выведет: class java.lang.Integer
```

Хотя переменная объявлена как `Number`, фактический объект имеет тип `Integer`.

---

## **4.1.5.4 Полиморфизм: взаимодействие типов**

```java
Number x = Double.valueOf(3.14);
System.out.println(x); // будет вызван метод toString() класса Double
```

- **Статический тип**: Number
    
- **Исполняемый тип**: Double
    

Метод `toString()` вызывается из класса `Double`, а не из `Number`, поскольку JVM использует _runtime type_ объекта.

---

## **4.1.5.5 Приведение типов (casting)**

Статический тип определяет, _можно ли написать приведение_, а исполняемый тип определяет, _можно ли его выполнить_.

Примеры ошибок времени выполнения из-за расхождения статического и runtime-типа
```java
// ClassCastException: статически допустимо, но фактический тип — Double
Number n = Double.valueOf(3.14);
Integer i = (Integer) n; // ClassCastException
```

```java
// ArrayStoreException: ковариантность массивов + проверка компонентного типа в runtime
Object[] arr = new String[1];
arr[0] = 42; // ArrayStoreException
```
Эти примеры иллюстрируют, что корректность приведения на уровне компиляции не гарантирует его успешность во время выполнения, а также что для массивов компонентный тип проверяется JVM в runtime (см. [[4.3.3 Array Types]]).


---

## **4.1.5.6 Примитивные типы: совпадение статического и runtime типа**

Для примитивных значений различия между статическим и исполняемым типом не существует:

```java
int x = 10;
// Статический тип: int
// Исполняемый тип: также int (примитивы не имеют подтипов)
```

---

## **4.1.5.7 Влияние на generics и type erasure**

Параметры типов generics существуют **только на этапе компиляции**:

```java
List<String> list = new ArrayList<>();
System.out.println(list.getClass()); // class java.util.ArrayList
```

- **Статический тип**: `List<String>`
    
- **Исполняемый тип**: `ArrayList` (без информации о типе элементов)
    

Это поведение объясняется механизмом стирания типов (см. [[4.5.8 Type Erasure and Bridge Methods]]).

---

## **4.1.5.8 Случаи совпадения и различия**

|Ситуация|Статический тип|Runtime тип|Комментарий|
|---|---|---|---|
|Примитив|`int`|`int`|Совпадает|
|Объект|`Number n`|`Integer`|Различается|
|Массив|`Object[] arr = new String[1]`|`String[]`|Различается, возможна ошибка в runtime|
|Обобщение (generics)|`List<String>`|`ArrayList`|Тип параметра стирается|

---

## **4.1.5.9 Вывод**

- Статический тип обеспечивает **типобезопасность и проверку корректности кода**.
    
- Исполняемый тип обеспечивает **фактическую реализацию поведения** и поддерживает **полиморфизм**.
    
- Понимание различия между ними является ключевым для правильной работы с наследованием, generics, приведениями типов и исключениями времени выполнения.
    

---

## **Cross-References**

- См. также:
    
    - **[[4.1.4 Type vs Value]]** — понятия типа и значения.
        
    - **[[4.1.6 Subtypes and Supertypes]]** — отношения подтипирования.
        
    - **[[4.3.3 Array Types]]** — ковариантность массивов.
        
    - **[[4.5.8 Type Erasure and Bridge Methods]]** — стирание типов и потеря информации о generics.
        
    - **[[4.9 ClassLoader and Type Identity]]** — определение идентичности типа на уровне JVM.
        
