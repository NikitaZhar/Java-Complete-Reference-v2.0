2025-10-10 12:06
Tags: #Types #Values #PrimitiveTypes 

## [[4.1.0 Overview — Общий обзор видов типов и значений]]
## [[4.1.1 Definition of Type — Определение типа]]
## [[4.1.2 Definition of Value — Определение значения]]
## [[4.1.3 High-Level Classification of Types — Высокоуровневая классификация типов]]
## [[4.1.4 Type vs Value — Тип и значение. Различие]]
## [[4.1.5 Static vs Runtime Type — Статический и исполняемый тип]]
## [[4.1.6 Subtypes and Supertypes — Подтипы и надтипы]]
## [[4.1.7 JVM Memory Model — Модель памяти JVM и представление типов]]
## [[4.1.8 Common Pitfalls — Типичные ошибки в понимании типов и значений]]

2025-10-27 12:36
Tags: #

4.1.0 Overview — Общий обзор видов типов и значений

## **4.1.0.1 Цель подраздела**

Этот подраздел формирует фундаментальные понятия системы типов Java. Он определяет, что такое _тип_ и _значение_, объясняет их роль в языке и задаёт основу, на которую опираются все последующие разделы — от примитивных типов и ссылочных объектов до обобщений, полиморфизма и преобразований типов.

Раздел 4.1 не описывает синтаксис языка или конкретные реализации. Его назначение — ввести **строгую понятийную модель**, которая затем используется во всей спецификации.

---

## **4.1.0.2 Ключевые принципы системы типов Java**

Java является **строго типизированным** (`strongly typed`) и **статически типизированным** (`statically typed`) языком. Это означает:

- Каждый элемент программы (переменная, выражение, параметр, поле, результат метода) **обязан иметь тип**, известный на этапе компиляции.
    
- Каждое вычисление приводит к появлению **значения**, принадлежащего **ровно одному типу**.
    
- Тип определяет:
    
    - множество допустимых значений;
        
    - набор операций, разрешённых для этих значений;
        
    - совместимость с другими типами;
        
    - гарантии поведения на этапе компиляции и выполнения.
        

> Тип — это формальная абстракция.  
> Значение — это конкретная сущность, существующая во время выполнения программы.

**Номинальная типизация.** Совместимость типов в Java определяется **декларациями** `extends`/`implements` (номинальная система типов), а не совпадением «формы» (набора членов). Язык **не поддерживает union-типы** на уровне синтаксиса; для моделирования альтернатив используются иерархии (в т.ч. `sealed`) и `Optional`. См. [[4.1.6 Subtypes and Supertypes]] и дальнейшие разделы о ссылочных типах.


---

## **4.1.0.3 Область охвата раздела 4.1**

В этом разделе вводятся:

- формальное определение **типа** и **значения**;
    
- **общая классификация типов** (примитивные и ссылочные);
    
- различие между **статическим типом** и **исполняемым типом**;
    
- основы **подтипирования**;
    
- связь типов с моделью памяти JVM.
    

Подробное описание конкретных типов (примитивных, ссылочных, параметризованных), а также механизмы стирания типов, преобразований и обобщений рассматриваются в следующих разделах главы 4.

---

## **4.1.0.4 Взаимосвязь типа и значения**

- Тип задаёт допустимую форму и поведение данных.
    
- Значение является экземпляром (представителем) множества, определяемого типом.
    
- Тип может существовать независимо от значения (например, тип `int` существует, даже если переменная не инициализирована).
    
- Значение не может существовать без типа (нельзя иметь «просто 42»; в Java это всегда «42 типа `int`»).
    

---

## **4.1.0.5 Высокоуровневая классификация**

В Java различается два основных рода типов:

|Категория типов|Характеристика|Определены в|Примеры|
|---|---|---|---|
|Примитивные (Primitive Types)|Представляют непосредственные значения|Раздел 4.2|`int`, `double`, `boolean`|
|Ссылочные (Reference Types)|Представляют ссылки на объекты или `null`|Раздел 4.3|классы, интерфейсы, массивы, обобщённые переменные типов|

> Все сложные структуры данных (включая строки, массивы, записи `record`, перечисления `enum` и типы обобщений) относятся к ссылочным типам.

---

## **4.1.0.6 Значение раздела 4.1 для понимания Java**

Понимание системы типов и значений является основой для:

- контроля типобезопасности;
    
- механизма полиморфизма;
    
- правил преобразования типов (`widening` и `narrowing`);
    
- работы с `null` и исключениями `ClassCastException` и `NullPointerException`;
    
- понимания поведения JVM при размещении данных в памяти.
    

---

## **4.1.0.7 Структура подразделов 4.1**

|Подраздел|Название|Содержание|
|---|---|---|
|**4.1.1**|Definition of Type|формальное определение типа|
|**4.1.2**|Definition of Value|определение значения и его свойства|
|**4.1.3**|High-Level Classification of Types|разделение на примитивные и ссылочные типы|
|**4.1.4**|Type vs Value|различие между абстракцией типа и конкретным значением|
|**4.1.5**|Static vs Runtime Type|статический и исполняемый тип, полиморфизм|
|**4.1.6**|Subtypes and Supertypes|отношения подтипирования и совместимости|
|**4.1.7**|JVM Memory Model|связь типов и значений с моделью памяти|
|**4.1.8**|Common Pitfalls|типовые ошибки и ссылки на соответствующие разделы|

---

## **4.1.0.8 Связь с последующими разделами**

Дальнейшее развитие понятий происходит в следующих подразделах:

- **[[4.1.1 Definition of Type]]** — начало формального определения.
    
- **[[4.2 Primitive Types and Values — Примитивные типы и их значения]]** — конкретные значения примитивов.
    
- **[[4.3 Reference Types and Values]]** — объекты, массивы, `null`.
    
- **[[4.5 Generics and Type Variables]]** — параметризованные типы, стирание и вариативность.
    
- **[[4.9 ClassLoader and Type Identity]]** — идентичность типов на уровне JVM.
    

---
2025-10-27 13:37
Tags: #

4.1.1 Definition of Type — Определение типа

## **4.1.1.1 Формальное определение**

**Тип** в Java — это формальная характеристика данных, которая определяет:

1. **Множество допустимых значений**, которые может принимать выражение или переменная.
    
2. **Набор разрешённых операций**, которые могут быть применены к этим значениям.
    
3. **Правила совместимости** с другими типами (можно ли использовать значение данного типа в контексте другого типа).
    
4. **Контракт времени компиляции и выполнения**, определяющий корректность программы и поведение при её исполнении.
    

Тип задаёт _абстракцию_ данных: он не является значением сам по себе, а описывает свойства значений.

> Тип можно рассматривать как математическое множество, а значение — как конкретный элемент этого множества.

---

## **4.1.1.2 Роль типа в системе языка**

Типы выполняют в Java две ключевые роли:

### **1. Роль на этапе компиляции**

- Компилятор использует типы для:
    
    - проверки корректности выражений;
        
    - проверки совместимости при присваивании и передаче аргументов;
        
    - выбора перегруженных методов;
        
    - выявления ошибок ещё до выполнения программы.
        
- Тип выражения всегда известен на этапе компиляции.
    

### **2. Роль во время выполнения**

- Для ссылочных типов (reference types) существует **исполняемый тип** — фактический тип объекта в памяти JVM.
    
- JVM использует тип во время выполнения для:
    
    - динамической диспетчеризации методов (полиморфизм),
        
    - проверки приведения типов,
        
    - обработки исключений (`ClassCastException` при ошибочном приведении).
        

> Для примитивных типов статический тип полностью соответствует runtime-представлению.  
> Для ссылочных — статический и исполняемый тип могут различаться.

---

## **4.1.1.3 Тип как средство ограничения и гарантии корректности**

Тип **ограничивает** то, какие операции допустимы:

- Невозможно вызвать метод, не определённый типом.
    
- Нельзя выполнить арифметическую операцию над типом, который её не поддерживает.
    
- Нельзя присвоить значение одного типа переменной несовместимого типа.
    

```java
int x = 10;
String s = x; // Ошибка компиляции: несоответствие типов
```

Типы также гарантируют **типобезопасность** программы: корректная программа, прошедшая проверку типов, не нарушает модель памяти и не приводит к недопустимым операциям с данными (за исключением использования небезопасных механизмов).

---

## **4.1.1.4 Тип как часть контракта программы**

Тип определяет, _как именно_ поведение объекта или значения будет трактоваться:

- тип `int` означает целое число фиксированного диапазона;
    
- тип `String` означает объект, представляющий последовательность символов;
    
- тип `List<T>` означает структуру данных, содержащую элементы некоторого типа `T`;
    
- тип `void` определяет отсутствие возвращаемого значения (см. [[4.3.0 Reference Types — Overview]]).
    

Тип также определяет **идентичность на уровне JVM**: два типа считаются различными, даже если имеют одинаковую структуру, если они загружены разными загрузчиками классов.

**Ограничение:** `void` — это специальное обозначение отсутствия возвращаемого значения в сигнатуре метода и не является типом значений; `java.lang.Void` — ссылочный тип-маркер, используемый в обобщениях. См. [[Reference Types and Values → Special Reference Forms]].


---

## **4.1.1.5 Тип как элемент системы совместимости (Subtyping)**

Типы образуют **иерархию**:

- Один тип может быть _подтипом_ другого.
    
- Значение подтипа может использоваться там, где ожидается надтип.
    
- Тип определяет _контекст допустимого использования_ значения.
    

```java
Number n = Integer.valueOf(10); // Integer является подтипом Number
```

Подтипирование подробно рассматривается в разделе [[4.1.6 Subtypes and Supertypes]].

---

## **4.1.1.6 Типы на этапе компиляции и во время выполнения**

Java различает:

|Вид типа|Описание|Роль|
|---|---|---|
|**Compile-time type**|Статический тип, известный компилятору|Проверка корректности кода|
|**Runtime type**|Фактический тип объекта в куче|Определяет поведение и реальную реализацию методов|

```java
Number n = Double.valueOf(3.14);
// Статический тип: Number
// Исполняемый тип: Double
```

---

## **4.1.1.7 Вывод**

Тип — это **основной элемент системы языка**, отвечающий за формальное описание данных, проверку корректности программы и обеспечение её предсказуемого поведения.  
Без строгого определения типа невозможно сформировать следующие понятия: значения, переменные, выражения, наследование, полиморфизм, generics, преобразования и память JVM.

---

## **Cross-References**

- См. также:
    
    - **[[4.1.2 Definition of Value]]** — что такое значение и как оно связано с типом.
        
    - **[[4.1.3 High-Level Classification of Types]]** — примитивные и ссылочные типы.
        
    - **[[4.1.5 Static vs Runtime Type]]** — различия между статическим и исполняемым типом.
        
    - **[[4.3.0 Reference Types — Overview]]** — виды ссылочных типов и `null`.
        
    - **[[4.5.0 Generics — Overview]]** — типовые переменные и параметризованные типы.
        
2025-10-27 13:40
Tags: #

4.1.2 Definition of Value — Определение значения

## **4.1.2.1 Формальное определение**

**Значение** — это конкретная сущность, получаемая в результате вычисления выражения или хранящаяся в переменной.  
Каждое значение **обязательно принадлежит ровно одному типу**, и тип полностью определяет свойства этого значения и разрешённые над ним операции.

> Значение — это _элемент множества_, заданного типом.

---

## **4.1.2.2 Свойства значений**

Для любого значения в Java выполняются следующие условия:

1. **Значение не может существовать вне типа**:
    
    - нельзя иметь «просто 5»; корректно говорить «значение 5 типа `int`».
        
2. **Тип определяет способ хранения и поведения значения**.
    
3. **Каждое выражение при вычислении либо даёт значение своего типа, либо вызывает исключение**.
    
4. **Для ссылочных типов** значение может быть либо ссылкой на объект, либо специальным значением `null`.
    

---

## **4.1.2.3 Категории значений**

Все значения в Java относятся к одной из следующих категорий:

| Категория                       | Примеры                     | Описание                                                                                                    |
| ------------------------------- | --------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **Примитивные значения**        | `42`, `3.14`, `true`, `'A'` | Хранятся непосредственно                                                                                    |
| **Ссылочные значения**          | ссылка на объект в куче     | Указывают на объект или `null`                                                                              |
| **Специальное значение `null`** | `null`                      | Обозначает отсутствие объекта                                                                               |
| **Литералы класса**             | `String.class`, `int.class` | Значения типа `Class`, представляющие тип как объект метаданных. См. [[Class Literals and Class Metadata]]. |

Каждое значение интерпретируется в соответствии с типовой системой. Например, `null` имеет особый «null type» и совместимо со всеми ссылочными типами, но несовместимо с примитивными.



---

## **4.1.2.4 Значения примитивных и ссылочных типов**

|Характеристика|Примитивные значения|Ссылочные значения|
|---|---|---|
|Представление|Непосредственно (битовый формат)|Ссылка (указатель на объект в куче)|
|Возможность быть `null`|Нет|Да (значение `null`)|
|Изменяемость|Неизменяемы|Зависит от объекта|
|Хранение|Стек или внутри объекта|Ссылка в стеке + объект в куче|

---

## **4.1.2.5 Значение vs отсутствие значения**

- Значение **существует**, если выражение завершилось успешно.
    
- В случае исключения (`exception`) значение **не создаётся**.
    
- Значение `null` **является значением**, но **обозначает отсутствие объекта**.
    

```java
String s = null; // переменная имеет значение null, но не указывает на объект
```

---

## **4.1.2.6 Значение и вычисление выражений**

Каждое выражение в Java имеет:

- **тип** (определяется на этапе компиляции),
    
- **значение** (появляется при выполнении).
    

```java
int x = 5 + 3; // выражение 5 + 3 имеет тип int и значение 8
String s = "a" + "b"; // выражение имеет тип String и значение "ab"
```

Если вычисление приводит к ошибке (например, деление на ноль для целых типов), значение **не будет создано**, и выполнение продолжится через механизм исключений.

---

## **4.1.2.7 Runtime-существование значений**

- Примитивное значение _существует непосредственно_.
    
- Ссылочное значение _существует как ссылка_, которая может указывать на объект или содержать `null`.
    
- Объекты, на которые указывают ссылочные значения, размещаются в куче (`heap`) и управляются JVM.
    

---

## **4.1.2.8 Вывод**

Значение является **конкретным проявлением абстракции типа во время выполнения программы**.  
Тип определяет возможное множество, значение — конкретный элемент этого множества.  
Тип без значения — допустимая абстракция; значение без типа — невозможно.

---

## **Cross-References**

- См. также:
    
    - **[[4.1.1 Definition of Type]]** — формальное описание множества, которому принадлежит значение.
        
    - **[[4.1.4 Type vs Value]]** — различие между абстракцией типа и конкретной сущностью.
        
    - **[[4.1.5 Static vs Runtime Type]]** — влияние типа на вычисление значений.
        
    - **[[4.3.1 Null Type]]** — значение `null` как особая категория.
        
    - **[[4.2 Primitive Types and Values — Примитивные типы и их значения]]** — конкретные наборы примитивных значений.
        
    - **[[4.3.0 Reference Types — Overview]]** — объекты, ссылки и хранение значений в памяти.
        
2025-10-27 13:42
Tags: #


4.1.3 High-Level Classification of Types — Высокоуровневая классификация типов
## **4.1.3.1 Основное разделение**

Все типы в Java разделяются на **две фундаментальные категории**:

|Категория|Характеристика|Где подробно описано|
|---|---|---|
|**Primitive Types**|Определяют непосредственные значения|Раздел [[4.2 Primitive Types and Values — Примитивные типы и их значения]]|
|**Reference Types**|Представляют ссылки на объекты, массивы или `null`|Раздел [[4.3 Reference Types and Values]]|

Это разделение является ключевым и определяет:

- способ хранения значений,
    
- возможные операции,
    
- поведение при передаче и копировании,
    
- участие в системе подтипирования.
    

---

## **4.1.3.2 Примитивные типы (Primitive Types)**

Примитивные типы являются **встроенными в язык** и не определяются пользователем.

**Свойства:**

- значения хранятся непосредственно;
    
- имеют фиксированный размер;
    
- не являются объектами;
    
- не допускают значение `null`;
    
- не участвуют в наследовании.
    

Примеры: `int`, `double`, `boolean`, `char`.

> Полный набор примитивных типов и их представление рассматривается в разделе [[4.2]].

---

## **4.1.3.3 Ссылочные типы (Reference Types)**

Ссылочные типы представляют **ссылки** на объекты в памяти JVM.

К ним относятся:

|Подвид ссылочного типа|Описание|Пример|
|---|---|---|
|**Class Types**|Пользовательские и встроенные классы|`String`, `ArrayList`|
|**Interface Types**|Определяют контракт поведения|`Runnable`, `List`|
|**Array Types**|Упорядоченные последовательности элементов одного типа|`int[]`, `String[]`|
|**Type Variables**|Параметры обобщённых типов|`T`, `E`, `K, V`|

> **Примечание о типовых переменных.** Переменные типа (`T`, `E`, `K`, `V`) существуют **только на этапе компиляции**; во время выполнения их информация стирается (non-reifiable). Они участвуют в проверке типов, но не определяют отдельного runtime-представления. См. [[4.5 Generics and Type Variables]] и [[Reifiable vs Non-Reifiable Types]].


**Свойства:**

- ссылки могут указывать на объект или иметь значение `null`;
    
- объекты размещаются в куче (`heap`);
    
- поддерживается наследование и полиморфизм;
    
- типовые переменные существуют только на этапе компиляции (информация стирается при выполнении).
    

---

## **4.1.3.4 Особое значение `null`**

- `null` является **единственным значением специального "null-type"**.
    
- Может быть присвоено любой переменной ссылочного типа.
    
- Не может быть присвоено переменной примитивного типа.
    

Подробнее: [[4.3.1 Null Type]]

---

## **4.1.3.5 Сравнение примитивных и ссылочных типов**

|Характеристика|Примитивные типы|Ссылочные типы|
|---|---|---|
|Представление|значение хранится напрямую|ссылка на объект|
|Размещение|стек или поле объекта|ссылка в стеке, объект в куче|
|Поддержка `null`|нет|да (`null`)|
|Участие в наследовании|нет|да (подтипы и надтипы)|
|Изменяемость|неизменяемы|зависит от типа объекта|
|Использование в generics|невозможно|возможно|

---

## **4.1.3.6 Роль классификации**

Это разделение на примитивные и ссылочные типы лежит в основе:

- **модели памяти JVM** (см. [[4.1.7 JVM Memory Model]]),
    
- **системы подтипирования** (см. [[4.1.6 Subtypes and Supertypes]]),
    
- **правил преобразования типов** (см. главу 5),
    
- **обобщённых типов и стирания** (см. [[4.5 Generics and Type Variables]]).
    

---

## **4.1.3.7 Вывод**

Высокоуровневая классификация типов определяет фундаментальную структуру системы типов Java.  
Каждый тип в языке принадлежит к одной из двух основных категорий: _примитивной_ или _ссылочной_.  
Дальнейшие подразделы этой главы описывают их поведение, взаимодействие и ограничения.

---

## **Cross-References**

- См. также:
    
    - **[[4.1.2 Definition of Value]]** — значения, соответствующие типам.
        
    - **[[4.2 Primitive Types and Values — Примитивные типы и их значения]]** — все примитивные типы и их диапазоны.
        
    - **[[4.3 Reference Types and Values]]** — классы, интерфейсы, массивы, `null`.
        
    - **[[4.1.5 Static vs Runtime Type]]** — как тип влияет на выполнение.
        
    - **[[4.1.7 JVM Memory Model]]** — размещение примитивов и объектов в памяти.
        


Смежные специальные ссылочные типы рассматриваются далее:
- **Enum Types** — перечисления (см. [[Enum Types]]),
- **Record Types** — записные классы (см. [[Record Types]]),
- **Annotation Types** — аннотационные типы (см. [[Annotation Types]]),
- **Class Literals и объекты `Class`** (см. [[Class Literals and Class Metadata]]).
2025-10-27 13:44
Tags: #


4.1.4 Type vs Value — Тип и значение. Различие
## **4.1.4.1 Концептуальное разделение**

В системе типов Java необходимо строго различать понятия **типа** и **значения**, поскольку они принадлежат к разным уровням абстракции:

- **Тип** — это _абстрактная модель_, определяющая множество допустимых значений и операций.
    
- **Значение** — это _конкретный представитель_ этого множества, возникающий при выполнении программы.
    

> Тип существует на уровне компиляции как правило, значение существует на уровне выполнения как факт.

---

## **4.1.4.2 Тип как описание, значение как экземпляр**

|Характеристика|Тип|Значение|
|---|---|---|
|Природа|Абстракция|Конкретная сущность|
|Множество|Определяет множество значений|Является элементом этого множества|
|Роль|Определяет, _что возможно делать_|Является _тем, с чем выполняются действия_|
|Существование|Может существовать без значения|Не может существовать без типа|

---

## **4.1.4.3 Пример на примитивном типе**

```java
int x;     // тип: int; значение временно отсутствует (переменная не инициализирована)
x = 42;    // значение 42 принадлежит типу int
```

- Здесь `int` — абстракция (тип), `42` — конкретное значение данного типа.
    
- Тип `int` существует независимо от того, существует ли переменная `x` или какое значение она содержит.
    

---

## **4.1.4.4 Пример на ссылочном типе**

```java
String s = null;     // тип: String; значение: null (отсутствие объекта)
s = "Java";          // тип: String; значение: ссылка на объект String в куче
```

- Тип `String` задаёт структуру и поведение объектов типа String.
    
- Значение `"Java"` — конкретный объект (или ссылка на него).
    
- Значение `null` — тоже значение, но означает отсутствие объекта.
    

---

## **4.1.4.5 Тип определяет допустимость операций**

- Операции применимы **к типу**, а не к значению напрямую.
    
- Значение может находиться в состоянии ошибки только в контексте типа.
    

```java
int a = 5;
int b = a + 1;   // операция сложения допустима, т.к. тип int поддерживает +
String s = "x";
String t = s + "y"; // допустимо, т.к. тип String поддерживает конкатенацию
int x = s + 1;  // ошибка компиляции: тип String не поддерживает +
```

---

## **4.1.4.6 Несовместимость типов даже при наличии совместимых значений**

```java
int x = 1;
String s = "1";
x == s; // ошибка: типы несовместимы, несмотря на одинаковое «значение» по смыслу
```

---

## **4.1.4.7 Тип определяет поведение при выполнении**

При полиморфизме исполняемый (runtime) тип определяет конкретную реализацию метода:

```java
Number n = Double.valueOf(3.14);
System.out.println(n.getClass()); // Double
```

- Статический тип: Number
    
- Значение имеет исполняемый тип: Double
    
- Именно значение (его runtime-тип) определяет, какой метод будет вызван.
    

---

## **4.1.4.8 Вывод**

- Тип — это _контракт_.
    
- Значение — _фактическое состояние программы_.
    
- Тип существует даже без значения.
    
- Значение всегда принадлежит типу.
    

> Тип задаёт правила. Значение проявляет эти правила на практике.

---

## **Cross-References**

- См. также:
    
    - **[[4.1.1 Definition of Type]]** — формальные свойства типа.
        
    - **[[4.1.2 Definition of Value]]** — природа и классификация значений.
        
    - **[[4.1.5 Static vs Runtime Type]]** — взаимодействие типов и значений во время выполнения.
        
    - **[[4.3.1 Null Type]]** — значение, представляющее отсутствие объекта.
        
    - **[[4.2 Primitive Types and Values — Примитивные типы и их значения]]** — конкретные множества значений примитивов.
        
2025-10-27 13:45
Tags: #

4.1.5 Static vs Runtime Type — Статический и исполняемый тип

## **4.1.5.1 Основное различие**

В Java каждый объект или выражение имеет **два уровня типизации**:

|Вид типа|Когда определяется|Кем используется|Роль|
|---|---|---|---|
|**Статический тип (compile-time type)**|На этапе компиляции|Компилятором|Определяет корректность кода и допустимость операций|
|**Исполняемый тип (runtime type)**|Во время выполнения программы|JVM|Определяет фактическое поведение и конкретную реализацию методов|

> Статический тип — это _обещание_, данное компилятору.  
> Исполняемый тип — это _фактическая природа объекта_ во время выполнения.

---

## **4.1.5.2 Статический тип (compile-time type)**

- Является частью исходного кода.
    
- Определяется объявлением переменной, параметра метода или выражения.
    
- Используется компилятором для:
    
    - проверки наличия методов и полей,
        
    - выбора перегруженного метода,
        
    - контроля совместимости типов.
        

```java
Number n = Integer.valueOf(5);
// Статический тип переменной n: Number
```

Переменная `n` на этапе компиляции рассматривается как переменная типа `Number`. Это означает, что компилятор разрешит вызов только тех методов, которые определены в типе `Number`.

---

## **4.1.5.3 Исполняемый тип (runtime type)**

- Это реальный тип объекта, находящегося в памяти JVM.
    
- Может быть подтипом статического типа (полиморфизм).
    
- Определяет, какой метод будет вызван при динамической диспетчеризации.
    

```java
Number n = Integer.valueOf(5);
System.out.println(n.getClass()); // Выведет: class java.lang.Integer
```

Хотя переменная объявлена как `Number`, фактический объект имеет тип `Integer`.

---

## **4.1.5.4 Полиморфизм: взаимодействие типов**

```java
Number x = Double.valueOf(3.14);
System.out.println(x); // будет вызван метод toString() класса Double
```

- **Статический тип**: Number
    
- **Исполняемый тип**: Double
    

Метод `toString()` вызывается из класса `Double`, а не из `Number`, поскольку JVM использует _runtime type_ объекта.

---

## **4.1.5.5 Приведение типов (casting)**

Статический тип определяет, _можно ли написать приведение_, а исполняемый тип определяет, _можно ли его выполнить_.

Примеры ошибок времени выполнения из-за расхождения статического и runtime-типа
```java
// ClassCastException: статически допустимо, но фактический тип — Double
Number n = Double.valueOf(3.14);
Integer i = (Integer) n; // ClassCastException
```

```java
// ArrayStoreException: ковариантность массивов + проверка компонентного типа в runtime
Object[] arr = new String[1];
arr[0] = 42; // ArrayStoreException
```
Эти примеры иллюстрируют, что корректность приведения на уровне компиляции не гарантирует его успешность во время выполнения, а также что для массивов компонентный тип проверяется JVM в runtime (см. [[4.3.3 Array Types]]).


---

## **4.1.5.6 Примитивные типы: совпадение статического и runtime типа**

Для примитивных значений различия между статическим и исполняемым типом не существует:

```java
int x = 10;
// Статический тип: int
// Исполняемый тип: также int (примитивы не имеют подтипов)
```

---

## **4.1.5.7 Влияние на generics и type erasure**

Параметры типов generics существуют **только на этапе компиляции**:

```java
List<String> list = new ArrayList<>();
System.out.println(list.getClass()); // class java.util.ArrayList
```

- **Статический тип**: `List<String>`
    
- **Исполняемый тип**: `ArrayList` (без информации о типе элементов)
    

Это поведение объясняется механизмом стирания типов (см. [[4.5.8 Type Erasure and Bridge Methods]]).

---

## **4.1.5.8 Случаи совпадения и различия**

|Ситуация|Статический тип|Runtime тип|Комментарий|
|---|---|---|---|
|Примитив|`int`|`int`|Совпадает|
|Объект|`Number n`|`Integer`|Различается|
|Массив|`Object[] arr = new String[1]`|`String[]`|Различается, возможна ошибка в runtime|
|Обобщение (generics)|`List<String>`|`ArrayList`|Тип параметра стирается|

---

## **4.1.5.9 Вывод**

- Статический тип обеспечивает **типобезопасность и проверку корректности кода**.
    
- Исполняемый тип обеспечивает **фактическую реализацию поведения** и поддерживает **полиморфизм**.
    
- Понимание различия между ними является ключевым для правильной работы с наследованием, generics, приведениями типов и исключениями времени выполнения.
    

---

## **Cross-References**

- См. также:
    
    - **[[4.1.4 Type vs Value]]** — понятия типа и значения.
        
    - **[[4.1.6 Subtypes and Supertypes]]** — отношения подтипирования.
        
    - **[[4.3.3 Array Types]]** — ковариантность массивов.
        
    - **[[4.5.8 Type Erasure and Bridge Methods]]** — стирание типов и потеря информации о generics.
        
    - **[[4.9 ClassLoader and Type Identity]]** — определение идентичности типа на уровне JVM.
        
2025-10-27 13:47
Tags: #

4.1.6 Subtypes and Supertypes — Подтипы и надтипы

## **4.1.6.1 Основное понятие**

**Подтип** — это тип, значения которого могут использоваться в любом контексте, где ожидается значение другого типа (надтипа), **без нарушения типобезопасности**.

Если тип `B` является подтипом типа `A`, то справедливо:

```
B <: A  (B is a subtype of A)
A :> B  (A is a supertype of B)
```

> Принцип: **всякий объект подтипа может рассматриваться как объект надтипа**, даже если его конкретная реализация отличается.

---

## **4.1.6.2 Роль подтипирования**

Подтипирование лежит в основе:

- **Наследования классов**
    
- **Реализации интерфейсов**
    
- **Полиморфизма**
    
- **Совместимости при присваивании**
    
- **Передачи аргументов и возврата результатов методов**
    

---

## **4.1.6.3 Формальные источники подтипов**

### **1. Наследование классов**

Если класс `B` объявлен как `extends A`, то `B` — подтип `A`.

```java
class A {}
class B extends A {} // B <: A
```

### **2. Реализация интерфейсов**

Если класс или интерфейс объявлен как `implements I`, он является подтипом интерфейса `I`.

```java
interface I {}
class C implements I {} // C <: I
```

### **3. Массивы (ковариантность)**

Массивы в Java ковариантны:

```
Если T <: S, то T[] <: S[]
```

Однако это может привести к ошибкам времени выполнения (см. [[4.3.3 Array Types]]).

```java
String[] arr = new String[1];
Object[] objArr = arr; // допустимо: String[] <: Object[]
```

### **4. Специальные типы**

- Тип `Object` является **надтипом всех ссылочных типов**.
    
- Тип `null` (Null Type) является **подтипом всех ссылочных типов** (см. [[4.3.1 Null Type]]).
    

---

## **4.1.6.4 Пример корректного подтипирования**

```java
Number n = Integer.valueOf(5); // Integer <: Number
Object o = n;                 // Number <: Object
```

---

## **4.1.6.5 Присваивание и контекст совместимости**

Если `B <: A`, то значение типа `B` может быть присвоено переменной типа `A`.

```java
A a = new B(); // полиморфное присваивание
```

---

## **4.1.6.6 Полиморфизм (runtime dispatch)**

Подтип может переопределять методы надтипа. При вызове методов определяется фактический (runtime) тип объекта.

```java
class A {
    void m() { System.out.println("A"); }
}
class B extends A {
    void m() { System.out.println("B"); }
}

A obj = new B();
obj.m(); // Выведет "B"
```

- Статический тип: `A`
    
- Исполняемый тип: `B`
    
- Вызывается реализация подтипа `B`.
    

---

## **4.1.6.7 Приведение типов (casting) и подтипирование**

Если объект имеет подтип `B`, его можно привести к надтипу `A` **без приведения**:

```java
B b = new B();
A a = b; // неявное приведение
```

Обратное приведение требует проверки во время выполнения:

```java
A a = new B();
B b = (B) a; // допустимо, фактический объект — B
```

Если фактический тип объекта не соответствует, будет исключение:

```java
A a = new A();
B b = (B) a; // ClassCastException
```

---

## **4.1.6.8 Подтипирование и тип `Object`**

- `Object` является **корнем всей иерархии ссылочных типов**.
    
- Все классы и массивы **являются подтипами `Object`**.
    
- Примитивные типы **не являются подтипами `Object`**.
    

```java
Object o1 = "text"; // String <: Object
Object o2 = new int[5]; // int[] <: Object
```

---

## **4.1.6.9 Особый случай: тип `null`**

- Значение `null` совместимо с любой ссылочной переменной.
    
- Считается подтипом всех ссылочных типов.
    

```java
String s = null;
Object o = null;
Runnable r = null;
```

Подробнее: [[4.3.1 Null Type]]

---

## **4.1.6.10 Подтипирование и безопасность типов**

Подтипирование служит фундаментом **типобезопасности**:

- гарантирует, что поведение объекта будет соответствовать ожиданиям контракта его надтипа;
    
- предотвращает нарушение модели памяти.
    

Нарушения возможны только при использовании небезопасных конструкций (`raw types`, рефлексия и пр.) и приводят к исключениям времени выполнения.

---

## **4.1.6.11 Вывод**

- Подтипирование определяет **совместимость типов** и **возможность подстановки** одного типа вместо другого.
    
- Java использует **номинальную** систему типов: совместимость основана **на объявлении**, а не на структуре.
    
- Это фундамент для наследования, интерфейсов, полиморфизма и generics.
    

> Если `B <: A`, то любое значение `B` может быть использовано там, где ожидается значение `A`.

---

## **Cross-References**

- См. также:
    
    - **[[4.1.5 Static vs Runtime Type]]** — влияние подтипирования на полиморфизм.
        
    - **[[4.3.1 Null Type]]** — `null` как подтип всех ссылочных типов.
        
    - **[[4.3.3 Array Types]]** — ковариантность массивов.
        
    - **[[4.5.0 Generics — Overview]]** — инвариантность обобщённых типов.
        
    - **[[4.9 ClassLoader and Type Identity]]** — идентичность типов на уровне JVM.
        
2025-10-27 13:48
Tags: #

4.1.7 JVM Memory Model — Модель памяти JVM и представление типов

## **4.1.7.1 Назначение модели памяти**

Модель памяти в JVM определяет:

- **где и как** хранятся значения примитивных и ссылочных типов;
    
- **как работает доступ к значениям**;
    
- **какие типы данных могут находиться в стеке и куче**;
    
- **как тип влияет на форму хранения значения**.
    

> Тип данных определяет не только поведение, но и область хранения значения во время выполнения программы.

---

## **4.1.7.2 Основные области памяти JVM**

|Область|Назначение|Какие значения хранятся|
|---|---|---|
|**Stack (стек)**|Временные данные вызовов методов|примитивные значения, ссылки на объекты|
|**Heap (куча)**|Долговременное хранение объектов|объекты классов, массивы, строки, записи (record), enum|

**Примитивы** могут храниться:

- как _отдельные значения_ в стеке;
    
- как _поля объектов_, где объект находится в куче.
    

**Ссылки** всегда хранятся в стеке (или в поле объекта), а **сами объекты — в куче**.

---

## **4.1.7.3 Представление примитивных и ссылочных значений**

| Тип                        | Где хранится значение                                                                                        | Комментарий                                              |
| -------------------------- | ------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------- |
| Примитив (`int`, `double`) | непосредственно в стеке (или внутри объекта в куче)                                                          | значение записывается напрямую                           |
| Ссылка (`String`, массив)  | в стеке (или в поле объекта)                                                                                 | содержит адрес объекта в куче                            |
| Объект                     | в куче                                                                                                       | доступен только через ссылку                             |
| `null`                     | специальное ссылочное значение; хранится там же, где хранится сама переменная или поле (как значение ссылки) | специальное ссылочное значение, не указывающее на объект |

---

## **4.1.7.4 Пример хранения значений**

```java
int x = 10;         // x находится в стеке, значение 10 — примитив
String s = "Java";  // s находится в стеке, значение — ссылка на объект в куче
```

- Примитив `10` хранится непосредственно.
    
- Переменная `s` содержит ссылку, указывающую на строковый объект в куче.
    

---

## **4.1.7.5 Объекты и ссылки**

- Все ссылочные значения **указывают на объекты**, созданные с использованием оператора `new` или полученные через литералы.
    
- Объекты размещаются **только в куче**, независимо от того, где объявлена переменная.
    
- Несколько ссылок могут указывать на один объект.
    

```java
String a = new String("ABC");
String b = a; // обе ссылки указывают на один объект
```

---

## **4.1.7.6 Передача значений в методы**

В Java все аргументы передаются **по значению** (_pass-by-value_).

- Для примитивов передаётся **само значение**.
    
- Для ссылочных типов передаётся **копия ссылки**, а не сам объект.
    

```java
void test(String s) { ... }

String x = "Hi";
test(x); // передаётся копия ссылки на объект String
```

Изменение объекта внутри метода влияет на исходный объект, но переназначение ссылки — нет.

---

## **4.1.7.7 Значение `null` и отсутствие объекта**

- `null` — это допустимое значение _любой переменной ссылочного типа_.
    
- Оно обозначает отсутствие связи с объектом.
    
- Попытка обращения к методу или полю через `null` вызывает `NullPointerException`.
    

Подробнее: [[4.3.1 Null Type]]

---

## **4.1.7.8 Тип и размещение в памяти**

|Категория типа|Пример|Представление в памяти|
|---|---|---|
|Примитивный тип|`int x = 5;`|значение `5` хранится прямо|
|Классовый тип|`Point p;`|`p` хранит ссылку, объект Point — в куче|
|Массив|`int[] a;`|ссылка хранится в стеке, массив — в куче|
|Enum|`Color.RED`|ссылка на заранее созданный объект enum|
|Record|`Point(int x, int y)`|объект в куче, поля неизменяемы|

---

## **4.1.7.9 Вывод**

- Тип определяет **не только набор допустимых значений**, но и **их представление в памяти JVM**.
    
- Примитивы существуют как непосредственные значения.
    
- Все сложные данные являются объектами и размещаются в куче.
    
- Ссылки на объекты передаются по значению.
    
- Понимание этой модели необходимо для анализа поведения программы, предотвращения ошибок (`NullPointerException`, `ClassCastException`) и понимания полиморфизма.
    

---

## **Cross-References**

- См. также:
    
    - **[[4.1.3 High-Level Classification of Types]]** — разделение на примитивные и ссылочные типы.
        
    - **[[4.1.5 Static vs Runtime Type]]** — влияние типа на поведение во время выполнения.
        
    - **[[4.1.6 Subtypes and Supertypes]]** — совместимость ссылочных типов.
        
    - **[[4.3 Reference Types and Values]]** — структуры ссылочных объектов.
        
    - **[[4.2 Primitive Types and Values — Примитивные типы и их значения]]** — специфика примитивов.
        
2025-10-27 13:50
Tags: #

4.1.8 Common Pitfalls — Типичные ошибки в понимании типов и значений

## **4.1.8.1 Назначение раздела**

Этот раздел обобщает частые концептуальные ошибки, возникающие при неправильном понимании природы типов, значений, ссылок и памяти. Каждая ошибка указана кратко и снабжена ссылкой на раздел, где приведено подробное объяснение и примеры.

> Данный список служит не для объяснения, а для ориентации: _каждый пункт — это указатель на последующий тематический узел спецификации_.

---

## **4.1.8.2 Ошибки, связанные с различием между типом и значением**

|Ошибка|Суть проблемы|См. раздел|
|---|---|---|
|Смешение типа и значения|Попытка использовать значение без учета его типа или делать вывод о типе на основании значения|[[4.1.4 Type vs Value]]|
|Непонимание зависимости операций от типа|Операция допустима только в рамках типа, а не для конкретного значения|[[4.1.1 Definition of Type]]|

---

## **4.1.8.3 Ошибки, связанные с `null` и ссылками**

| Ошибка                                                                  | Причина                                                                     | См. раздел                         |
| ----------------------------------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------- |
| Сравнение ссылок вместо значений (`==` вместо `.equals()`)              | `==` сравнивает ссылки, а не содержимое                                     | [[4.3.2 Identity and Equality]]    |
| Попытка использовать `null` как объект                                  | Значение `null` не ссылается на объект и не поддерживает вызов методов      | [[4.3.1 Null Type]]                |
| Неверное предположение, что `null` является значением примитивного типа | Примитивы не допускают `null`                                               | [[4.2 Primitive Types and Values — Примитивные типы и их значения]] |
| Использование `==` для строк                                            | Интернирование может дать “случайный” `true`, сравнивайте через `.equals()` | [[Identity and Equality]]          |

---

## **4.1.8.4 Ошибки, связанные с подтипированием и полиморфизмом**

|Ошибка|Причина|См. раздел|
|---|---|---|
|Предположение, что статический тип определяет поведение|Поведение определяется runtime-типом объекта|[[4.1.5 Static vs Runtime Type]]|
|Неправильное приведение типов|Приведение разрешено статически, но может быть невозможно во время выполнения|[[4.1.6 Subtypes and Supertypes]]|

---

## **4.1.8.5 Ошибки, связанные с памятью и моделью значений**

|Ошибка|Причина|См. раздел|
|---|---|---|
|Ожидание, что переменная "содержит объект"|Переменная ссылочного типа содержит только ссылку|[[4.1.7 JVM Memory Model]]|
|Непонимание передачи аргументов|Передача по значению (в том числе копии ссылки)|[[4.1.7 JVM Memory Model]]|

---

## **4.1.8.6 Специфические ошибки, связанные с массивами и обёртками**

| Ошибка                                          | Причина                                                     | См. раздел                            |
| ----------------------------------------------- | ----------------------------------------------------------- | ------------------------------------- |
| Ошибочное использование ковариантности массивов | Массивы ковариантны, но проверяются JVM во время выполнения | [[4.3.3 Array Types]]                 |
| Использование `==` с обёртками примитивов       | Кеширование и автоупаковка приводят к ошибкам сравнения     | [[4.2.x Boxing and Wrapper Types]]    |
| Unboxing `null`                                 | Распаковка `null` вызывает `NullPointerException`           | [[Boxing/Unboxing and Wrapper Types]] |

---

## **4.1.8.7 Ошибки, связанные с generics (обобщениями)**

|Ошибка|Причина|См. раздел|
|---|---|---|
|Предположение, что `List<String>` является подтипом `List<Object>`|Обобщённые типы инвариантны|[[4.5.4 Wildcards (PECS)]]|
|Путаница между compile-time и runtime типами в generics|Стирание типов (`type erasure`)|[[4.5.8 Type Erasure and Bridge Methods]]|
|Создание массива параметризованного типа|Generic types are not reifiable|[[4.5.9 Reifiable vs Non-Reifiable]]|

---

## **4.1.8.8 Вывод**

- Все перечисленные ошибки имеют **одну общую причину**: непонимание фундаментального различия между _типом_ и _значением_, а также между _статикой_ и _исполнением_.
    
- Раздел 4.1 создаёт базу, позволяющую избежать этих ошибок.
    
- Каждый из последующих разделов главы 4 углубляет конкретную тему и устраняет соответствующее заблуждение.
    

---

## **Cross-References**

Для более глубокого изучения см. следующие разделы:

- **[[4.1.4 Type vs Value]]**
    
- **[[4.1.5 Static vs Runtime Type]]**
    
- **[[4.1.6 Subtypes and Supertypes]]**
    
- **[[4.3.1 Null Type]]**
    
- **[[4.3.2 Identity and Equality]]**
    
- **[[4.3.3 Array Types]]**
    
- **[[4.2 Primitive Types and Values — Примитивные типы и их значения]]**
    
- **[[4.5 Generics and Type Variables]]**
    
